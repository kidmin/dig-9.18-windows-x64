diff --git a/Makefile.am b/Makefile.am
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,28 +1,3 @@
 include $(top_srcdir)/Makefile.top
 
-SUBDIRS = . lib doc bin fuzz
-
-if HAVE_CMOCKA
-SUBDIRS += tests
-endif HAVE_CMOCKA
-
-BUILT_SOURCES = bind.keys.h
-CLEANFILES = bind.keys.h
-
-bind.keys.h: bind.keys Makefile
-	${PERL} ${top_srcdir}/util/bindkeys.pl ${top_srcdir}/bind.keys > $@
-
-dist_sysconf_DATA = bind.keys
-
-.PHONY: doc
-
-EXTRA_DIST =			\
-	util/bindkeys.pl	\
-	contrib			\
-	COPYRIGHT		\
-	LICENSE			\
-	*.md
-
-dist-hook:
-	find $(distdir) -type f -name .gitignore -delete
-	git rev-parse --short HEAD | cut -b1-7 > $(distdir)/srcid
+SUBDIRS = . lib bin
diff --git a/Makefile.top b/Makefile.top
--- a/Makefile.top
+++ b/Makefile.top
@@ -4,6 +4,7 @@
 ACLOCAL_AMFLAGS = -I $(top_srcdir)/m4
 
 AM_CFLAGS =					\
+	-D_UCRT					\
 	$(STD_CFLAGS)
 
 AM_CPPFLAGS =					\
@@ -12,23 +13,16 @@ AM_CPPFLAGS =					\
 	-I$(srcdir)/include
 
 AM_LDFLAGS =					\
+	-no-undefined				\
+	-mcrtdll=ucrt				\
 	$(STD_LDFLAGS)
 LDADD =
 
-if HOST_MACOS
-AM_LDFLAGS +=					\
-	-Wl,-flat_namespace
-endif HOST_MACOS
-
-if HAVE_JEMALLOC
-LIBISC_CFLAGS = $(JEMALLOC_CFLAGS)
-LIBISC_LIBS = $(JEMALLOC_LIBS)
-else
 LIBISC_CFLAGS =
 LIBISC_LIBS =
-endif
 
 LIBISC_CFLAGS +=						\
+	-DNGHTTP2_STATICLIB				\
 	-I$(top_srcdir)/include				\
 	-I$(top_srcdir)/lib/isc/include			\
 	-I$(top_builddir)/lib/isc/include
@@ -42,12 +36,6 @@ LIBDNS_CFLAGS = \
 LIBDNS_LIBS = \
 	$(top_builddir)/lib/dns/libdns.la
 
-LIBNS_CFLAGS = \
-	-I$(top_srcdir)/lib/ns/include
-
-LIBNS_LIBS = \
-	$(top_builddir)/lib/ns/libns.la
-
 LIBIRS_CFLAGS = \
 	-I$(top_srcdir)/lib/irs/include
 
diff --git a/bin/Makefile.am b/bin/Makefile.am
--- a/bin/Makefile.am
+++ b/bin/Makefile.am
@@ -1 +1 @@
-SUBDIRS = named rndc dig delv dnssec tools nsupdate check confgen tests plugins
+SUBDIRS = dig
diff --git a/bin/dig/Makefile.am b/bin/dig/Makefile.am
--- a/bin/dig/Makefile.am
+++ b/bin/dig/Makefile.am
@@ -5,8 +5,7 @@ AM_CPPFLAGS +=			\
 	$(LIBDNS_CFLAGS)	\
 	$(LIBISCCFG_CFLAGS)	\
 	$(LIBIRS_CFLAGS)	\
-	$(LIBBIND9_CFLAGS)	\
-	$(LIBIDN2_CFLAGS)
+	$(LIBBIND9_CFLAGS)
 
 LDADD +=			\
 	libdighost.la		\
@@ -14,8 +13,7 @@ LDADD +=			\
 	$(LIBDNS_LIBS)		\
 	$(LIBISCCFG_LIBS)	\
 	$(LIBIRS_LIBS)		\
-	$(LIBBIND9_LIBS)	\
-	$(LIBIDN2_LIBS)
+	$(LIBBIND9_LIBS)
 
 noinst_LTLIBRARIES = libdighost.la
 
@@ -23,17 +21,4 @@ libdighost_la_SOURCES =		\
 	dighost.h		\
 	dighost.c
 
-bin_PROGRAMS = dig host nslookup
-
-nslookup_CPPFLAGS =		\
-	$(AM_CPPFLAGS)
-
-nslookup_LDADD =		\
-	$(LDADD)
-
-if HAVE_READLINE
-nslookup_CPPFLAGS +=		\
-	$(READLINE_CFLAGS)
-nslookup_LDADD +=		\
-	$(READLINE_LIBS)
-endif HAVE_READLINE
+bin_PROGRAMS = dig
diff --git a/bin/dig/dig.c b/bin/dig/dig.c
--- a/bin/dig/dig.c
+++ b/bin/dig/dig.c
@@ -19,6 +19,8 @@
 #include <stdlib.h>
 #include <time.h>
 
+#include <winsock2.h>
+
 #include <isc/app.h>
 #include <isc/attributes.h>
 #include <isc/dir.h>
@@ -68,7 +70,7 @@ static char domainopt[DNS_NAME_MAXTEXT];
 static char hexcookie[81];
 
 static bool short_form = false, printcmd = true, plusquest = false,
-	    pluscomm = false, ipv4only = false, ipv6only = false, digrc = true;
+	    pluscomm = false, ipv4only = false, ipv6only = false;
 static uint32_t splitwidth = 0xffffffff;
 
 /*% opcode text */
@@ -155,7 +157,8 @@ help(void) {
 	       "debugging)\n"
 	       "                 -p port             (specify port number)\n"
 	       "                 -q name             (specify query name)\n"
-	       "                 -r                  (do not read ~/.digrc)\n"
+	       "                 -r                  (ignored: .digrc is not "
+	       "supported on this build)\n"
 	       "                 -t type             (specify query type)\n"
 	       "                 -u                  (display times in usec "
 	       "instead of msec)\n"
@@ -243,12 +246,6 @@ help(void) {
 	       "                                      while using plain HTTP)\n"
 	       "                 +[no]identify       (ID responders in short "
 	       "answers)\n"
-#ifdef HAVE_LIBIDN2
-	       "                 +[no]idnin          (Parse IDN names "
-	       "[default=on on tty])\n"
-	       "                 +[no]idnout         (Convert IDN response "
-	       "[default=on on tty])\n"
-#endif /* ifdef HAVE_LIBIDN2 */
 	       "                 +[no]ignore         (Don't revert to TCP for "
 	       "TC responses.)\n"
 	       "                 +[no]keepalive      (Request EDNS TCP "
@@ -386,7 +383,7 @@ received(unsigned int bytes, isc_sockaddr_t *from, dig_query_t *query) {
 		printf(";; SERVER: %s(%s) (%s)\n", fromtext, query->userarg,
 		       proto);
 		time(&tnow);
-		(void)localtime_r(&tnow, &tmnow);
+		(void)localtime_s(&tmnow, &tnow);
 
 		if (strftime(time_str, sizeof(time_str),
 			     "%a %b %d %H:%M:%S %Z %Y", &tmnow) > 0U)
@@ -1663,21 +1660,13 @@ plus_option(char *option, bool is_batchfile, bool *need_clone,
 				switch (cmd[3]) {
 				case 'i':
 					FULLCHECK("idnin");
-#ifndef HAVE_LIBIDN2
 					fprintf(stderr, ";; IDN input support"
 							" not enabled\n");
-#else  /* ifndef HAVE_LIBIDN2 */
-					lookup->idnin = state;
-#endif /* ifndef HAVE_LIBIDN2 */
 					break;
 				case 'o':
 					FULLCHECK("idnout");
-#ifndef HAVE_LIBIDN2
 					fprintf(stderr, ";; IDN output support"
 							" not enabled\n");
-#else  /* ifndef HAVE_LIBIDN2 */
-					lookup->idnout = state;
-#endif /* ifndef HAVE_LIBIDN2 */
 					break;
 				default:
 					goto invalid_option;
@@ -2311,8 +2300,7 @@ dash_option(char *option, char *next, dig_lookup_t **lookup,
 			/* deprecated */
 			break;
 		case 'r':
-			debug("digrc (late)");
-			digrc = false;
+			/* ignored: .digrc is unsupported */
 			break;
 		case 'u':
 			(*lookup)->use_usec = true;
@@ -2578,12 +2566,7 @@ preparse_args(int argc, char **argv) {
 						    ISC_MEM_DEBUGRECORD;
 				break;
 			case 'r':
-				/*
-				 * Must be done early, because ~/.digrc
-				 * is read before command line parsing
-				 */
-				debug("digrc (early)");
-				digrc = false;
+				/* ignored: .digrc is unsupported */
 				break;
 			case '4':
 				if (ipv6only) {
@@ -2652,10 +2635,6 @@ parse_args(bool is_batchfile, bool config_only, int argc, char **argv) {
 	char *bargv[64];
 	int rc;
 	char **rv;
-#ifndef NOPOSIX
-	char *homedir;
-	char rcfile[PATH_MAX];
-#endif /* ifndef NOPOSIX */
 	bool need_clone = true;
 
 	/*
@@ -2676,36 +2655,6 @@ parse_args(bool is_batchfile, bool config_only, int argc, char **argv) {
 		default_lookup->adflag = true;
 		default_lookup->edns = DEFAULT_EDNS_VERSION;
 		default_lookup->sendcookie = true;
-
-#ifndef NOPOSIX
-		/*
-		 * Treat ${HOME}/.digrc as a special batchfile
-		 */
-		INSIST(batchfp == NULL);
-		homedir = getenv("HOME");
-		if (homedir != NULL && digrc) {
-			unsigned int n;
-			debug("digrc (open)");
-			n = snprintf(rcfile, sizeof(rcfile), "%s/.digrc",
-				     homedir);
-			if (n < sizeof(rcfile)) {
-				batchfp = fopen(rcfile, "r");
-			}
-		}
-		if (batchfp != NULL) {
-			while (fgets(batchline, sizeof(batchline), batchfp) !=
-			       0)
-			{
-				debug("config line %s", batchline);
-				bargc = split_batchline(batchline, bargv, 62,
-							".digrc argv");
-				bargv[0] = argv[0];
-				argv0 = argv[0];
-				parse_args(true, true, bargc, (char **)bargv);
-			}
-			fclose(batchfp);
-		}
-#endif /* ifndef NOPOSIX */
 	}
 
 	if (is_batchfile && !config_only) {
@@ -3061,6 +3010,9 @@ dig_setup(int argc, char **argv) {
 	progname = argv[0];
 	preparse_args(argc, argv);
 
+	WSADATA wsaData = {0};
+	INSIST(WSAStartup(MAKEWORD(2, 2), &wsaData) == 0);
+
 	result = isc_app_start();
 	check_result(result, "isc_app_start");
 
diff --git a/bin/dig/dighost.c b/bin/dig/dighost.c
--- a/bin/dig/dighost.c
+++ b/bin/dig/dighost.c
@@ -30,10 +30,6 @@
 #include <string.h>
 #include <unistd.h>
 
-#ifdef HAVE_LIBIDN2
-#include <idn2.h>
-#endif /* HAVE_LIBIDN2 */
-
 #include <isc/app.h>
 #include <isc/base64.h>
 #include <isc/file.h>
@@ -113,15 +109,6 @@ int lookup_counter = 0;
 
 static char servercookie[256];
 
-#ifdef HAVE_LIBIDN2
-static void
-idn_locale_to_ace(const char *src, char *dst, size_t dstlen);
-static void
-idn_ace_to_locale(const char *src, char **dst);
-static isc_result_t
-idn_output_filter(isc_buffer_t *buffer, unsigned int used_org);
-#endif /* HAVE_LIBIDN2 */
-
 isc_nmhandle_t *keep = NULL;
 isc_sockaddr_t keepaddr;
 
@@ -603,9 +590,6 @@ clone_server_list(dig_serverlist_t src, dig_serverlist_t *dest) {
 dig_lookup_t *
 make_empty_lookup(void) {
 	dig_lookup_t *looknew;
-#ifdef HAVE_LIBIDN2
-	bool idn_allowed = isatty(1) ? (getenv("IDN_DISABLE") == NULL) : false;
-#endif /* HAVE_LIBIDN2 */
 
 	debug("make_empty_lookup()");
 
@@ -621,10 +605,6 @@ make_empty_lookup(void) {
 		.besteffort = true,
 		.opcode = dns_opcode_query,
 		.badcookie = true,
-#ifdef HAVE_LIBIDN2
-		.idnin = idn_allowed,
-		.idnout = idn_allowed,
-#endif /* HAVE_LIBIDN2 */
 		.udpsize = -1,
 		.edns = -1,
 		.recurse = true,
@@ -2221,10 +2201,6 @@ setup_lookup(dig_lookup_t *lookup) {
 
 	REQUIRE(lookup != NULL);
 
-#ifdef HAVE_LIBIDN2
-	char idn_origin[MXNAME], idn_textname[MXNAME];
-#endif /* HAVE_LIBIDN2 */
-
 	INSIST(!free_now);
 
 	debug("setup_lookup(%p)", lookup);
@@ -2254,13 +2230,6 @@ setup_lookup(dig_lookup_t *lookup) {
 	 * TLD.
 	 */
 	textname = lookup->textname;
-#ifdef HAVE_LIBIDN2
-	if (lookup->idnin) {
-		idn_locale_to_ace(textname, idn_textname, sizeof(idn_textname));
-		debug("idn_textname: %s", idn_textname);
-		textname = idn_textname;
-	}
-#endif /* HAVE_LIBIDN2 */
 
 	/*
 	 * If the name has too many dots, force the origin to be NULL
@@ -2287,14 +2256,6 @@ setup_lookup(dig_lookup_t *lookup) {
 		check_result(result, "dns_message_gettempname");
 		/* XXX Helper funct to conv char* to name? */
 		origin = lookup->origin->origin;
-#ifdef HAVE_LIBIDN2
-		if (lookup->idnin) {
-			idn_locale_to_ace(origin, idn_origin,
-					  sizeof(idn_origin));
-			debug("trying idn origin %s", idn_origin);
-			origin = idn_origin;
-		}
-#endif /* HAVE_LIBIDN2 */
 		len = (unsigned int)strlen(origin);
 		isc_buffer_init(&b, origin, len);
 		isc_buffer_add(&b, len);
@@ -4793,202 +4754,11 @@ destroy_libs(void) {
 	}
 }
 
-#ifdef HAVE_LIBIDN2
-static isc_result_t
-idn_output_filter(isc_buffer_t *buffer, unsigned int used_org) {
-	char src[MXNAME], *dst = NULL;
-	size_t srclen, dstlen;
-	isc_result_t result = ISC_R_SUCCESS;
-
-	/*
-	 * Copy name from 'buffer' to 'src' and terminate it with NULL.
-	 */
-	srclen = isc_buffer_usedlength(buffer) - used_org;
-	if (srclen >= sizeof(src)) {
-		warn("Input name too long to perform IDN conversion");
-		goto cleanup;
-	}
-	memmove(src, (char *)isc_buffer_base(buffer) + used_org, srclen);
-	src[srclen] = '\0';
-
-	systemlocale(LC_ALL);
-
-	/*
-	 * Convert 'src' to the current locale's character encoding.
-	 */
-	idn_ace_to_locale(src, &dst);
-
-	resetlocale(LC_ALL);
-
-	/*
-	 * Check whether the converted name will fit back into 'buffer'.
-	 */
-	dstlen = strlen(dst);
-	if (isc_buffer_length(buffer) < used_org + dstlen) {
-		result = ISC_R_NOSPACE;
-		goto cleanup;
-	}
-
-	/*
-	 * Put the converted name back into 'buffer'.
-	 */
-	isc_buffer_subtract(buffer, srclen);
-	memmove(isc_buffer_used(buffer), dst, dstlen);
-	isc_buffer_add(buffer, dstlen);
-
-	/*
-	 * Clean up.
-	 */
-cleanup:
-	if (dst != NULL) {
-		idn2_free(dst);
-	}
-
-	return result;
-}
-
-/*%
- * Convert 'src', which is a string using the current locale's character
- * encoding, into an ACE string suitable for use in the DNS, storing the
- * conversion result in 'dst', which is 'dstlen' bytes large.
- *
- * 'dst' MUST be large enough to hold any valid domain name.
- */
-static void
-idn_locale_to_ace(const char *src, char *dst, size_t dstlen) {
-	const char *final_src;
-	char *ascii_src;
-	int res;
-
-	systemlocale(LC_ALL);
-
-	/*
-	 * We trust libidn2 to return an error if 'src' is too large to be a
-	 * valid domain name.
-	 */
-	res = idn2_to_ascii_lz(src, &ascii_src, IDN2_NONTRANSITIONAL);
-	if (res == IDN2_DISALLOWED) {
-		res = idn2_to_ascii_lz(src, &ascii_src, IDN2_TRANSITIONAL);
-	}
-	if (res != IDN2_OK) {
-		fatal("'%s' is not a legal IDNA2008 name (%s), use +noidnin",
-		      src, idn2_strerror(res));
-	}
-
-	/*
-	 * idn2_to_ascii_lz() normalizes all strings to lower case, but we
-	 * generally don't want to lowercase all input strings; make sure to
-	 * return the original case if the two strings differ only in case.
-	 */
-	final_src = (strcasecmp(src, ascii_src) == 0 ? src : ascii_src);
-
-	(void)strlcpy(dst, final_src, dstlen);
-
-	idn2_free(ascii_src);
-
-	resetlocale(LC_ALL);
-}
-
-/*%
- * Convert 'src', which is an ACE string suitable for use in the DNS, into a
- * string using the current locale's character encoding, storing the conversion
- * result in 'dst'.
- *
- * The caller MUST subsequently release 'dst' using idn2_free().
- */
-static void
-idn_ace_to_locale(const char *src, char **dst) {
-	char *local_src, *utf8_src;
-	int res;
-
-	systemlocale(LC_ALL);
-
-	/*
-	 * We need to:
-	 *
-	 *  1) check whether 'src' is a valid IDNA2008 name,
-	 *  2) if it is, output it in the current locale's character encoding.
-	 *
-	 * Unlike idn2_to_ascii_*(), idn2_to_unicode_*() functions are unable
-	 * to perform IDNA2008 validity checks.  Thus, we need to decode any
-	 * Punycode in 'src', check if the resulting name is a valid IDNA2008
-	 * name, and only once we ensure it is, output that name in the current
-	 * locale's character encoding.
-	 *
-	 * We could just use idn2_to_unicode_8zlz() + idn2_to_ascii_lz(), but
-	 * then we would not be able to universally tell invalid names and
-	 * character encoding errors apart (if the current locale uses ASCII
-	 * for character encoding, the former function would fail even for a
-	 * valid IDNA2008 name, as long as it contained any non-ASCII
-	 * character).  Thus, we need to take a longer route.
-	 *
-	 * First, convert 'src' to UTF-8, ignoring the current locale.
-	 */
-	res = idn2_to_unicode_8z8z(src, &utf8_src, 0);
-	if (res != IDN2_OK) {
-		fatal("Bad ACE string '%s' (%s), use +noidnout", src,
-		      idn2_strerror(res));
-	}
-
-	/*
-	 * Then, check whether decoded 'src' is a valid IDNA2008 name
-	 * and if disallowed character is found, fallback to IDNA2003.
-	 */
-	res = idn2_to_ascii_8z(utf8_src, NULL, IDN2_NONTRANSITIONAL);
-	if (res == IDN2_DISALLOWED) {
-		res = idn2_to_ascii_8z(utf8_src, NULL, IDN2_TRANSITIONAL);
-	}
-	if (res != IDN2_OK) {
-		fatal("'%s' is not a legal IDNA2008 name (%s), use +noidnout",
-		      src, idn2_strerror(res));
-	}
-
-	/*
-	 * Finally, try converting the decoded 'src' into the current locale's
-	 * character encoding.
-	 */
-	res = idn2_to_unicode_8zlz(utf8_src, &local_src, 0);
-	if (res != IDN2_OK) {
-		static bool warned = false;
-
-		res = idn2_to_ascii_8z(utf8_src, &local_src, 0);
-		if (res != IDN2_OK) {
-			fatal("Cannot represent '%s' "
-			      "in the current locale nor ascii (%s), "
-			      "use +noidnout or a different locale",
-			      src, idn2_strerror(res));
-		} else if (!warned) {
-			fprintf(stderr,
-				";; Warning: cannot represent '%s' "
-				"in the current locale",
-				local_src);
-			warned = true;
-		}
-	}
-
-	/*
-	 * Free the interim conversion result.
-	 */
-	idn2_free(utf8_src);
-
-	*dst = local_src;
-
-	resetlocale(LC_ALL);
-}
-#endif /* HAVE_LIBIDN2 */
-
 void
 dig_idnsetup(dig_lookup_t *lookup, bool active) {
-#ifdef HAVE_LIBIDN2
-	isc_result_t result;
-	result = dns_name_settotextfilter(
-		(active && lookup->idnout) ? idn_output_filter : NULL);
-	check_result(result, "dns_name_settotextfilter");
-#else
 	UNUSED(lookup);
 	UNUSED(active);
 	return;
-#endif /* HAVE_LIBIDN2 */
 }
 
 bool
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -17,9 +17,8 @@
 m4_define([bind_VERSION_MAJOR], 9)dnl
 m4_define([bind_VERSION_MINOR], 18)dnl
 m4_define([bind_VERSION_PATCH], 41)dnl
-m4_define([bind_VERSION_EXTRA], )dnl
+m4_define([bind_VERSION_EXTRA], +unofficial+windows-x64+extra+UNSTABLE.1)dnl
 m4_define([bind_DESCRIPTION], [(Extended Support Version)])dnl
-m4_define([bind_SRCID], [m4_esyscmd_s([git rev-parse --short HEAD | cut -b1-7])])dnl
 m4_define([bind_PKG_VERSION], [[bind_VERSION_MAJOR.bind_VERSION_MINOR.bind_VERSION_PATCH]bind_VERSION_EXTRA])dnl
 
 #
@@ -33,7 +32,6 @@ AC_DEFINE([PACKAGE_VERSION_MINOR], ["][bind_VERSION_MINOR]["], [BIND 9 Minor par
 AC_DEFINE([PACKAGE_VERSION_PATCH], ["][bind_VERSION_PATCH]["], [BIND 9 Patch part of the version])
 AC_DEFINE([PACKAGE_VERSION_EXTRA], ["][bind_VERSION_EXTRA]["], [BIND 9 Extra part of the version])
 AC_DEFINE([PACKAGE_DESCRIPTION], [m4_ifnblank(bind_DESCRIPTION, [" ]bind_DESCRIPTION["], [])], [An extra string to print after PACKAGE_STRING])
-AC_DEFINE([PACKAGE_SRCID], ["][bind_SRCID]["], [A short hash from git])
 
 bind_CONFIGARGS="${ac_configure_args:-default}"
 AC_DEFINE_UNQUOTED([PACKAGE_CONFIGARGS], ["$bind_CONFIGARGS"], [Either 'defaults' or used ./configure options])
@@ -47,21 +45,14 @@ AC_CANONICAL_BUILD
 AC_CANONICAL_HOST
 AC_CANONICAL_TARGET
 
-AC_CONFIG_SRCDIR([bin/named/main.c])
+AC_CONFIG_SRCDIR([bin/dig/dig.c])
 AM_INIT_AUTOMAKE([1.14 tar-pax foreign subdir-objects dist-xz no-dist-gzip -Wall -Werror])
 AM_SILENT_RULES([yes])
-AM_EXTRA_RECURSIVE_TARGETS([test unit doc])
 
 AC_CONFIG_HEADERS([config.h])
 AC_CONFIG_MACRO_DIR([m4])
 
-#
-# Enable maintainer mode by default only when building from git repository
-# and not cross compling
-#
-AS_IF([test "$cross_compiling" = no],
-      [AM_MAINTAINER_MODE(m4_ifset([bind_SRCID],[enable],[disable]))],
-      [AM_MAINTAINER_MODE([disable])])
+AM_MAINTAINER_MODE([disable])
 
 #
 # Enable system extensions to C and POSIX
@@ -138,13 +129,6 @@ AX_CHECK_COMPILE_FLAG([-Werror -fno-delete-null-pointer-checks],
 AX_CHECK_COMPILE_FLAG([-fdiagnostics-show-option],
 		      [STD_CFLAGS="$STD_CFLAGS -fdiagnostics-show-option"])
 
-AX_CHECK_LINK_FLAG([-Wl,--export-dynamic],
-		   [STD_LDFLAGS="$STD_LDFLAGS -Wl,--export-dynamic"])
-
-host_macos=no
-AS_CASE([$host],[*-darwin*],[host_macos=yes])
-AM_CONDITIONAL([HOST_MACOS], [test "$host_macos" = "yes"])
-
 #
 # Change defaults for developers if not explicity set.
 # Needs to be before the option is tested.
@@ -157,9 +141,6 @@ AC_ARG_ENABLE([developer],
 AS_IF([test "$enable_developer" = "yes"],
       [DEVELOPER_MODE=yes
        STD_CPPFLAGS="$STD_CPPFLAGS -DISC_MEM_DEFAULTFILL=1 -DISC_MEM_TRACKLINES=1 -DISC_LIST_CHECKINIT=1"
-       test "${enable_fixed_rrset+set}" = set || enable_fixed_rrset=yes
-       test "${enable_querytrace+set}" = set || enable_querytrace=yes
-       test "${with_cmocka+set}" = set || with_cmocka=yes
        test "${with_zlib+set}" = set || with_zlib=yes
        test "${enable_warn_error+set}" = set || enable_warn_error=yes
        ])
@@ -186,93 +167,14 @@ PKG_PROG_PKG_CONFIG
 AS_IF([test -z "$PKG_CONFIG"],
       [AC_MSG_ERROR([The pkg-config script could not be found or is too old.])])
 
-# Fuzzing is not included in pairwise testing as fuzzing tools are
-# not present in the relevant Docker image.
-#
-# [pairwise: skip]
-AC_ARG_ENABLE([fuzzing],
-	      [AS_HELP_STRING([--enable-fuzzing=<afl|libfuzzer|ossfuzz>],
-			      [Enable fuzzing using American Fuzzy Lop or libFuzzer (default=no)])],
-	      [],
-	      [enable_fuzzing=no])
-
-AC_MSG_CHECKING([whether to enable fuzzing mode])
-AS_CASE([$enable_fuzzing],
-	[no],[AC_MSG_RESULT([no])],
-	[afl],[
-	  AC_MSG_RESULT([using AFL])
-	  AC_DEFINE([ENABLE_AFL], [1],
-		    [Define to enable American Fuzzy Lop test harness])
-	  STD_CFLAGS="$STD_CFLAGS -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1"
-	  FUZZ_LOG_COMPILER="afl.sh"],
-	[libfuzzer],[
-	  AC_MSG_RESULT([using libFuzzer])
-	  STD_CFLAGS="$STD_CFLAGS -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 -fsanitize=fuzzer-no-link,address,undefined"
-	  LDFLAGS="$LDFLAGS -fsanitize=address,undefined"
-	  FUZZ_LDFLAGS="-fsanitize=fuzzer,address,undefined"
-	  FUZZ_LOG_COMPILER="libfuzzer.sh"],
-	[ossfuzz],[
-	    AC_MSG_RESULT([using OSS-Fuzz])
-	    FUZZ_LDFLAGS="$LIB_FUZZING_ENGINE"],
-	[*],[AC_MSG_ERROR([You need to explicitly select the fuzzer])])
-AM_CONDITIONAL([HAVE_FUZZ_LOG_COMPILER], [test -n "$FUZZ_LOG_COMPILER"])
-AC_SUBST([FUZZ_LOG_COMPILER])
-AC_SUBST([FUZZ_LDFLAGS])
-
-AS_IF([test "$enable_fuzzing" = "afl"],
-      [AC_MSG_CHECKING("for AFL enabled compiler")
-       AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],
-					  [#ifndef __AFL_COMPILER
-					   #error AFL compiler required
-					   #endif
-					  ])],
-			 [AC_MSG_RESULT([yes])],
-			 [AC_MSG_ERROR([set CC=afl-<gcc|clang> when --enable-fuzzing=afl is used])])
-      ])
-
-#
-# Perl is optional; it is used only by some of the system test scripts.
-#
-AC_PATH_PROGS([PERL], [perl5 perl])
-AC_SUBST([PERL])
-AM_CONDITIONAL([HAVE_PERL], [test -n "$PERL"])
-
-#
-# Python is optional, it is used only by some of the system test scripts.
-#
-AM_PATH_PYTHON([3.6], [], [:])
-AM_CONDITIONAL([HAVE_PYTHON], [test "$PYTHON" != ":"])
-
-AC_PATH_PROGS([PYTEST], [pytest-3 py.test-3 pytest py.test pytest-pypy], [])
-AS_IF([test -z "$PYTEST"],
-      [AC_MSG_WARN([pytest not found, some system tests will be skipped])])
-AC_SUBST([PYTEST])
-AM_CONDITIONAL([HAVE_PYTEST], [test -n "$PYTEST"])
-
-#
-# xsltproc is optional, it is used only by system test scripts.
-#
-AC_PATH_PROG([XSLTPROC], [xsltproc])
-
-#
-# Using Solaris linker with gcc on Solaris breaks Thread Local Storage
-#
-AS_CASE([$host],
-	[*-solaris*],[
-	    AS_IF([test "$GCC" = "yes"],
-		  [LDFLAGS="$LDFLAGS -zrelax=transtls"
-		   AC_MSG_WARN([When using GNU C Compiler on Solaris, -zrelax=transtls linker flag is used to fix bug in Thread Local Storage])
-		  ])
-	])
-
-AC_CHECK_HEADERS([sys/param.h sys/socket.h])
-AC_CHECK_HEADERS([fcntl.h regex.h sys/time.h unistd.h sys/mman.h sys/sockio.h sys/select.h sys/sysctl.h net/if6.h net/route.h linux/netlink.h linux/rtnetlink.h], [], [],
+AC_CHECK_HEADERS([sys/param.h winsock2.h])
+AC_CHECK_HEADERS([fcntl.h sys/time.h unistd.h sys/mman.h sys/sockio.h sys/select.h net/if6.h net/route.h], [], [],
 		 [$ac_includes_default
 		  #ifdef HAVE_SYS_PARAM_H
 		  # include <sys/param.h>
 		  #endif
 		  #ifdef HAVE_SYS_SOCKET_H
-		  # include <sys/socket.h>
+		  # include <winsock2.h>
 		  #endif
 		 ])
 
@@ -302,22 +204,6 @@ AS_CASE([$host],
 			[define if the ARM yield instruction is available])],
 	     [AC_MSG_RESULT([no])])])
 
-#
-# Check for pause support on SPARC processors
-#
-AS_CASE([$host],
-	[sparc*],
-	[AC_MSG_CHECKING([for pause instruction support])
-	 AC_COMPILE_IFELSE(
-	     [AC_LANG_PROGRAM([[]],
-			     [[__asm__ __volatile__ ("pause")]])],
-	     [AC_MSG_RESULT([yes])
-	      AC_DEFINE([HAVE_SPARC_PAUSE], [1],
-			[define if the SPARC pause instruction is available])],
-	     [AC_MSG_RESULT([no])])])
-
-AC_CHECK_FUNCS([sysctlbyname])
-
 #
 # Older versions of HP/UX don't define seteuid() and setegid()
 #
@@ -328,28 +214,6 @@ AC_TYPE_SIZE_T
 AC_TYPE_SSIZE_T
 AC_TYPE_UINTPTR_T
 
-#
-# check for uname library routine
-#
-AC_MSG_CHECKING([for uname])
-AC_COMPILE_IFELSE(
-  [AC_LANG_PROGRAM(
-     [[#include <sys/utsname.h>
-       #include <stdio.h>
-      ]],
-     [[
-       struct utsname uts;
-       uname(&uts);
-       printf("running on %s %s %s for %s\n",
-	      uts.sysname, uts.release, uts.version, uts.machine);
-     ]])],
-  [AC_MSG_RESULT(yes)
-   AC_DEFINE([HAVE_UNAME], [1], [define if uname is available])
-  ],
-  [AC_MSG_RESULT(no)
-   AC_MSG_WARN([uname is not correctly supported])
-  ])
-
 #
 # check for GCC noreturn attribute
 #
@@ -360,80 +224,11 @@ AX_GCC_FUNC_ATTRIBUTE([noreturn])
 #
 AX_GCC_FUNC_ATTRIBUTE([malloc])
 
-AC_MSG_CHECKING([for extended malloc attributes])
-AC_COMPILE_IFELSE(
-  [AC_LANG_PROGRAM(
-     [[
-       #include <stddef.h>
-       #include <stdlib.h>
-	   __attribute__ ((malloc, malloc (free, 1))
-	   void * xmalloc(size_t sz) { return malloc(sz); }
-     ]],
-     [[
-       void *p = xmalloc(8);
-	   free(p);
-     ]])],
-  [AC_MSG_RESULT(yes)
-   AC_DEFINE([HAVE_MALLOC_EXT_ATTR], [1], [define if extended attributes for malloc are available])
-  ],
-  [AC_MSG_RESULT(no)])
-
 #
 # check for GCC returns_nonnull attribute
 #
 AX_GCC_FUNC_ATTRIBUTE([returns_nonnull])
 
-#
-# GeoIP support?
-#
-# Should be on by default if libmaxminddb exists.
-#
-# [pairwise: --enable-geoip --with-maxminddb=auto, --enable-geoip --with-maxminddb=yes, --disable-geoip]
-AC_ARG_ENABLE([geoip],
-	      [AS_HELP_STRING([--disable-geoip],
-			      [support GeoIP2 geolocation ACLs if available [default=yes]])],
-	      [], [enable_geoip="yes"])
-
-# [pairwise: skip]
-AC_ARG_WITH([maxminddb],
-	    [AS_HELP_STRING([--with-maxminddb=PATH],
-			    [Build with MaxMind GeoIP2 support (auto|yes|no|path) [default=auto]])],
-	    [], [with_maxminddb="auto"])
-
-AS_IF([test "$enable_geoip" = "yes"],
-      [AS_CASE([$with_maxminddb],
-	       [no],[AC_MSG_ERROR([Use '--disable-geoip' to disable the GeoIP])],
-	       [auto],[PKG_CHECK_MODULES([MAXMINDDB], [libmaxminddb],
-					 [AC_DEFINE([HAVE_GEOIP2], [1], [Build with GeoIP2 support])
-					  PKG_CHECK_VAR([MAXMINDDB_PREFIX], [libmaxminddb], [prefix], [], [AC_MSG_ERROR([libmaxminddb prefix not found in pkg-config; set MAXMINDDB_PREFIX in the environment])])
-					 ],[:])],
-	       [yes],[PKG_CHECK_MODULES([MAXMINDDB], [libmaxminddb],
-					[AC_DEFINE([HAVE_GEOIP2], [1], [Build with GeoIP2 support])
-					 PKG_CHECK_VAR([MAXMINDDB_PREFIX], [libmaxminddb], [prefix], [], [AC_MSG_ERROR([libmaxminddb prefix not found in pkg-config; set MAXMINDDB_PREFIX in the environment])])
-					])],
-	       [ # default
-		   AX_SAVE_FLAGS([maxminddb])
-		   MAXMINDDB_CFLAGS="-I$with_maxminddb/include"
-		   MAXMINDDB_LIBS="-L$with_maxminddb/lib"
-		   CFLAGS="$CFLAGS $MAXMINDDB_CFLAGS"
-		   LIBS="$LIBS $MAXMINDDB_LIBS"
-		   AC_SEARCH_LIBS([MMDB_open], [maxminddb],
-				  [AC_DEFINE([HAVE_GEOIP2], [1], [Build with GeoIP2 support])
-				   MAXMINDDB_LIBS="$MAXMINDDB_LIBS $ac_cv_search_MMDB_open"
-				   AC_MSG_NOTICE([GeoIP2 default database path set to $with_maxminddb/share/GeoIP])
-				   AS_VAR_COPY([MAXMINDDB_PREFIX], [with_maxminddb])
-				  ],
-				  [AC_MSG_ERROR([GeoIP2 requested, but libmaxminddb not found])])
-		   AX_RESTORE_FLAGS([maxminddb])
-	       ])
-       AC_ARG_VAR([MAXMINDDB_PREFIX], [value of prefix for MAXMINDDB, overriding pkg-config])
-])
-
-AM_CONDITIONAL([HAVE_GEOIP2], [test -n "$MAXMINDDB_LIBS"])
-
-AC_SUBST([MAXMINDDB_CFLAGS])
-AC_SUBST([MAXMINDDB_LIBS])
-
 AX_PTHREAD
 
 LIBS="$PTHREAD_LIBS $LIBS"
@@ -494,7 +289,7 @@ LIBS="$LIBS $LIBUV_LIBS"
 # libuv recvmmsg support
 AC_CHECK_DECLS([UV_UDP_MMSG_FREE, UV_UDP_MMSG_CHUNK], [], [], [[#include <uv.h>]])
 AC_MSG_CHECKING([whether struct msghdr uses padding for alignment])
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include <sys/socket.h>],
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include <winsock2.h>],
 				   [const struct msghdr h = { .__pad1 = 0, .__pad2 = 0 };])],
 		  [AC_MSG_RESULT([yes])
 		   AC_DEFINE([HAVE_DECL_UV_UDP_RECVMMSG],
@@ -532,18 +327,6 @@ AM_CONDITIONAL([HAVE_LIBNGHTTP2], [test -n "$LIBNGHTTP2_LIBS"])
 #
 AC_CHECK_FUNCS([flockfile getc_unlocked])
 
-#
-# Look for sysconf or other ways to allow detection of the number of processors.
-#
-AC_CHECK_FUNCS([sysconf])
-AC_CHECK_FUNCS(sysconf sched_getaffinity cpuset_getaffinity)
-AC_CHECK_HEADERS([sys/cpuset.h], [], [],
-		 [$ac_includes_default
-		  #ifdef HAVE_SYS_PARAM_H
-		  # include <sys/param.h>
-		  #endif
-		 ])
-
 #
 # Do we want to use pthread rwlock?
 #
@@ -690,152 +473,6 @@ AC_SUBST([OPENSSL_LIBS])
 
 AC_CHECK_FUNCS([clock_gettime])
 
-# [pairwise: --with-gssapi=yes, --with-gssapi=auto, --without-gssapi]
-AC_ARG_WITH([gssapi],
-	    [AS_HELP_STRING([--with-gssapi=[PATH|[/path/]krb5-config]],
-			   [Specify path for system-supplied GSSAPI
-				[default=auto]])],
-	    [], [with_gssapi="auto"])
-
-KRB5_CONFIG=
-AS_CASE([$with_gssapi],
-	[no],[AC_MSG_CHECKING([for GSSAPI support])
-	      AC_MSG_RESULT([no])],
-	[yes],[AC_PATH_PROG([KRB5_CONFIG], [krb5-config])
-	       AS_IF([test -z "$KRB5_CONFIG"],
-		     [AC_MSG_ERROR([krb5-config required but not found])])],
-	[auto],[AC_PATH_PROG([KRB5_CONFIG], [krb5-config])],
-	[*krb5-config*],[KRB5_CONFIG="$with_gssapi"],
-	[AC_MSG_ERROR([--with-gssapi requires yes|no|auto|/path/to/krb5-config])])
-
-GSSAPI_CFLAGS=
-GSSAPI_LIBS=
-KRB5_CFLAGS=
-KRB5_LIBS=
-AS_IF([test -n "$KRB5_CONFIG"],
-      [AC_MSG_CHECKING([for gssapi libraries])
-       AX_SAVE_FLAGS([gssapi])
-       GSSAPI_CFLAGS=`"$KRB5_CONFIG" --cflags gssapi`
-       GSSAPI_LIBS=`"$KRB5_CONFIG" --libs gssapi`
-       CFLAGS="$CFLAGS $GSSAPI_CFLAGS"
-       LIBS="$LIBS $GSSAPI_LIBS"
-       AC_MSG_RESULT([$GSSAPI_CFLAGS $GSSAPI_LIBS])
-       AC_CHECK_HEADERS([gssapi/gssapi.h], [],
-			[AC_CHECK_HEADERS([gssapi.h], [],
-					  [AC_MSG_ERROR([neither gssapi/gssapi.h nor gssapi.h found])])])
-       AC_CHECK_HEADERS([gssapi/gssapi_krb5.h],
-			[AC_CHECK_HEADERS([gssapi_krb5.h], []
-					  [AC_MSG_ERROR([neither gssapi/gssapi_krb5.h nor gssapi_krb5.h found])])])
-       AC_CHECK_FUNCS([gss_acquire_cred],[],
-		      [AC_MSG_ERROR([linking with $GSSAPI_LIBS does not work])])
-       AX_RESTORE_FLAGS([gssapi])
-
-       AC_MSG_CHECKING([for krb5 libraries])
-       AX_SAVE_FLAGS([krb5])
-       KRB5_CFLAGS=`"$KRB5_CONFIG" --cflags krb5`
-       KRB5_LIBS=`$KRB5_CONFIG --libs krb5`
-       CFLAGS="$CFLAGS $KRB5_CFLAGS"
-       LIBS="$CFLAGS $KRB5_LIBS"
-       AC_MSG_RESULT([$KRB5_CFLAGS $KRB5_LIBS])
-       AC_CHECK_HEADERS([krb5/krb5.h], [],
-			[AC_CHECK_HEADERS([krb5.h], [],
-					  [AC_MSG_ERROR([neither krb5/krb5.h nor krb5 found])])])
-       AC_CHECK_FUNCS([krb5_init_context], [],
-		      [AC_MSG_ERROR([linking with $KRB5_LIBS failed])])
-       AX_RESTORE_FLAGS([krb5])
-
-       AC_DEFINE([HAVE_GSSAPI], [1], [Define to 1 if you have the Kerberos Framework available])
-       # kludge to silence compiler warnings which recommend use of GSS.framework on macOS
-       AS_CASE([$host],[*-darwin*],[CFLAGS="$CFLAGS -Wno-deprecated-declarations"])])
-AM_CONDITIONAL([HAVE_GSSAPI], [test -n "$GSSAPI_LIBS"])
-AC_SUBST([GSSAPI_CFLAGS])
-AC_SUBST([GSSAPI_LIBS])
-AC_SUBST([KRB5_CFLAGS])
-AC_SUBST([KRB5_LIBS])
-
-#
-# was --with-lmdb specified?
-#
-
-# [pairwise: --with-lmdb=auto, --with-lmdb=yes, --without-lmdb]
-AC_ARG_WITH([lmdb],
-	    [AS_HELP_STRING([--with-lmdb=@<:@PATH@:>@],
-			    [use LMDB library @<:@default=auto@:>@, optionally specify the prefix for lmdb library])],
-	    [:],
-	    [with_lmdb="auto"])
-
-ac_lib_lmdb_found=no
-AS_CASE([$with_lmdb],
-	[no],[],
-	[auto|yes], [PKG_CHECK_MODULES([LMDB], [lmdb],
-				       [ac_lib_lmdb_found=yes],
-				       [for ac_lib_lmdb_path in /usr /usr/local /opt /opt/local; do
-						AX_LIB_LMDB([$ac_lib_lmdb_path],
-							    [ac_lib_lmdb_found=yes
-							     break])
-					done
-				       ])],
-	[AX_LIB_LMDB([$with_lmdb],[ac_lib_lmdb_found=yes])])
-
-# don't fail when in automatic mode
-AS_IF([test "$with_lmdb" = "auto" && test "$ac_lib_lmdb_found" = "no"],
-      [with_lmdb=no])
-
-# hard fail when LMDB requested, but not found
-AS_IF([test "$with_lmdb" != "no" && test "$ac_lib_lmdb_found" != "yes"],
-      [AC_MSG_ERROR([LMDB requested, but not found])])
-
-AS_IF([test "$ac_lib_lmdb_found" = "yes"],
-      [AC_DEFINE([HAVE_LMDB], [1], [Use lmdb library])])
-
-AC_SUBST([LMDB_CFLAGS])
-AC_SUBST([LMDB_LIBS])
-AM_CONDITIONAL([HAVE_LMDB], [test -n "$LMDB_LIBS"])
-
-#
-# was --with-libxml2 specified?
-#
-# [pairwise: --with-libxml2=auto, --with-libxml2=yes, --without-libxml2]
-AC_ARG_WITH([libxml2],
-	    [AS_HELP_STRING([--with-libxml2],
-			    [build with libxml2 library [yes|no|auto] (default is auto)])],
-	    [], [with_libxml2="auto"])
-
-AS_CASE([$with_libxml2],
-	[no],[],
-	[auto],[PKG_CHECK_MODULES([LIBXML2], [libxml-2.0 >= 2.6.0],
-				  [AC_DEFINE([HAVE_LIBXML2], [1], [Use libxml2 library])],
-				  [:])],
-	[yes],[PKG_CHECK_MODULES([LIBXML2], [libxml-2.0 >= 2.6.0],
-				 [AC_DEFINE([HAVE_LIBXML2], [1], [Use libxml2 library])])],
-	[AC_MSG_ERROR([Specifying libxml2 installation path is not supported, adjust PKG_CONFIG_PATH instead])])
-
-AM_CONDITIONAL([HAVE_LIBXML2], [test -n "$LIBXML2_LIBS"])
-
-#
-# was --with-json-c specified?
-#
-# [pairwise: --with-json-c=detect, --with-json-c=yes, --without-json-c]
-AC_ARG_WITH([json-c],
-	    [AS_HELP_STRING([--with-json-c],
-			    [build with json-c library [yes|no|detect] (default is detect)])],
-	    [], [with_json_c="detect"])
-
-AS_CASE([$with_json_c],
-	[no],[],
-	[detect],[PKG_CHECK_MODULES([JSON_C], [json-c >= 0.11],
-				    [AC_DEFINE([HAVE_JSON_C], [1], [Use json-c library])],
-				    [:])],
-	[yes],[PKG_CHECK_MODULES([JSON_C], [json-c >= 0.11],
-				 [AC_DEFINE([HAVE_JSON_C], [1], [Use json-c library])])],
-	[AC_MSG_ERROR([Specifying json-c installation path is not supported, adjust PKG_CONFIG_PATH instead])]
-       )
-
-AM_CONDITIONAL([HAVE_JSON_C], [test -n "$JSON_C_LIBS"])
-
-AC_SUBST([JSON_C_CFLAGS])
-AC_SUBST([JSON_C_LIBS])
-
 #
 # was --with-zlib specified?
 #
@@ -873,8 +510,8 @@ AC_COMPILE_IFELSE(
   [AC_LANG_PROGRAM(
      [[
        #include <sys/types.h>
-       #include <sys/socket.h>
-       #include <netinet/in.h>
+       #include <winsock2.h>
+       #include <ws2tcpip.h>
      ]],
      [[
        struct sockaddr_in6 sin6;
@@ -908,97 +545,6 @@ AS_IF([test "$enable_tcp_fastopen" = "yes"],
 #
 AC_CHECK_FUNCS([strlcpy strlcat strnstr])
 
-#
-# Check for readline support
-#
-
-# editline is not included in pairwise testing as the library
-# is not present in the relevant Docker image.
-#
-# GNU Readline is not included in pairwise testing as the library
-# in the relevant Docker image does not support pkg-config.
-#
-# [pairwise: --with-readline=auto, --with-readline=yes, --with-readline=libedit, --without-readline]
-AC_ARG_WITH([readline],
-	    [AS_HELP_STRING([--with-readline=yes|no|libedit|readline],
-			    [specify readline library [default auto]])],
-	    [], [with_readline="auto"])
-
-AS_CASE([$with_readline],
-	[no],[],
-	[auto|yes],
-	[PKG_CHECK_MODULES([READLINE], [libedit],
-			   [AC_DEFINE([HAVE_READLINE_LIBEDIT], [1], [Build with libedit support])],
-			   [PKG_CHECK_MODULES([READLINE], [libeditline],
-					      [AC_DEFINE([HAVE_READLINE_EDITLINE], [1], [Build with editline support.])],
-					      [PKG_CHECK_MODULES([READLINE], [readline],
-								 [AC_DEFINE([HAVE_READLINE_READLINE], [1], [Build with readline support.])],
-								 [AS_IF([test "$with_readline" = "yes"],
-									[AC_MSG_ERROR([readline support requested, but none of the libraries have been found.])])])])])],
-	[libedit],
-	[PKG_CHECK_MODULES([READLINE], [libedit],
-			   [AC_DEFINE([HAVE_READLINE_LIBEDIT], [1], [Build with libedit support])])],
-	[editline],
-	[PKG_CHECK_MODULES([READLINE], [libeditline],
-			   [AC_DEFINE([HAVE_READLINE_EDITLINE], [1], [Build with editline support])])],
-	[readline],
-	[PKG_CHECK_MODULES([READLINE], [readline],
-			   [AC_DEFINE([HAVE_READLINE_READLINE], [1], [Build with readline support])])],
-	[AC_MSG_ERROR([Unknown readline '$with_readline' library requested.])])
-AM_CONDITIONAL([HAVE_READLINE], [test -n "$READLINE_LIBS"])
-AC_SUBST([READLINE_CFLAGS])
-AC_SUBST([READLINE_LIBS])
-
-#
-# Security Stuff
-#
-# Note it is very recommended to *not* disable chroot(),
-# this is only because chroot() was made obsolete by Posix.
-#
-# [pairwise: --enable-chroot, --disable-chroot]
-AC_ARG_ENABLE(chroot, AS_HELP_STRING([--disable-chroot], [disable chroot]))
-case "$enable_chroot" in
-	yes|'')
-		AC_CHECK_FUNCS(chroot)
-		;;
-	no)
-		;;
-esac
-
-LIBCAP_LIBS=""
-AC_MSG_CHECKING([whether to enable Linux capabilities])
-
-# [pairwise: --enable-linux-caps, --disable-linux-caps]
-AC_ARG_ENABLE([linux-caps],
-	      [AS_HELP_STRING([--disable-linux-caps],
-			      [disable Linux capabilities])],
-	      [],
-	      [AS_CASE([$host],
-		       [*-linux*],[enable_linux_caps=yes],
-		       [enable_linux_caps=no])])
-
-AS_IF([test "$enable_linux_caps" = "yes"],
-      [AC_MSG_RESULT([yes])
-       AC_CHECK_HEADERS([sys/capability.h],
-			[],
-			[AC_MSG_ERROR(m4_normalize([sys/capability.h header is required for Linux capabilities support.
-						    Either install libcap or use --disable-linux-caps.]))])
-       AX_SAVE_FLAGS([cap])
-       AC_SEARCH_LIBS([cap_set_proc], [cap],
-		      [LIBCAP_LIBS="$ac_cv_search_cap_set_proc"],
-		      [AC_MSG_ERROR(m4_normalize([libcap is required for Linux capabilities support.
-						  Either install libcap or use --disable-linux-caps.]))])
-       AX_RESTORE_FLAGS([cap])],
-      [AC_MSG_RESULT([no])])
-AC_SUBST([LIBCAP_LIBS])
-
-case "$host" in
-*-solaris*)
-	AC_DEFINE(NEED_SECURE_DIRECTORY, 1,
-		  [Define if connect does not honour the permission on the UNIX domain socket.])
-	;;
-esac
-
 #
 # Time Zone Stuff
 #
@@ -1149,311 +695,6 @@ AC_LINK_IFELSE(
   [AC_MSG_RESULT([no])
   ])
 
-#
-# Activate "rrset-order fixed" or not?
-#
-# [pairwise: --enable-fixed-rrset, --disable-fixed-rrset]
-AC_ARG_ENABLE([fixed-rrset],
-	      [AS_HELP_STRING([--enable-fixed-rrset],
-			      [enable fixed rrset ordering [default=no]])],
-	      [], [enable_fixed_rrset="no"])
-AS_IF([test "$enable_fixed_rrset" = "yes"],
-      [AC_DEFINE([DNS_RDATASET_FIXED], [1],
-		 [Define to enable "rrset-order fixed" syntax.])])
-
-#
-# Activate dnstap?
-#
-# [pairwise: --enable-dnstap, --disable-dnstap]
-AC_ARG_ENABLE([dnstap],
-	      [AS_HELP_STRING([--enable-dnstap],
-			      [enable dnstap support
-			       (requires fstrm, protobuf-c)])],
-	      [], [enable_dnstap=no])
-
-AS_IF([test "$enable_dnstap" != "no"],
-      [PKG_CHECK_MODULES([DNSTAP], [libfstrm libprotobuf-c], [],
-			 [AC_MSG_FAILURE([Required libraries (fstrm, protobuf-c) were not found, please install them.])])
-       AC_PATH_PROG([FSTRM_CAPTURE], [fstrm_capture])
-       AC_PATH_PROG([PROTOC_C], [protoc-c])
-       AS_IF([test -z "$PROTOC_C"],
-	     [AC_MSG_ERROR([protoc-c compiler not found])])
-       AC_DEFINE([HAVE_DNSTAP], 1, [Define to 1 to enable dnstap support])
-      ])
-
-AC_SUBST([DNSTAP_CFLAGS])
-AC_SUBST([DNSTAP_LIBS])
-AM_CONDITIONAL([HAVE_DNSTAP], [test "$enable_dnstap" != "no"])
-#
-# The following sections deal with tools used for formatting
-# the documentation.  They are all optional, unless you are
-# a developer editing the documentation source.
-#
-
-#
-# Look for sphinx-build
-#
-AC_ARG_VAR([SPHINX_BUILD], [path to sphinx-build binary used to build the documentation])
-AC_PATH_PROG([SPHINX_BUILD], [sphinx-build], [])
-AM_CONDITIONAL([HAVE_SPHINX_BUILD], [test -n "$SPHINX_BUILD"])
-
-AC_PATH_PROG([XELATEX], [xelatex], [])
-AC_PATH_PROG([LATEXMK], [latexmk], [])
-AM_CONDITIONAL([HAVE_XELATEX], [test -n "$XELATEX" && test -n "$LATEXMK"])
-
-#
-# Build the man pages only if we have prebuilt manpages or we can build them from RST sources
-#
-AM_CONDITIONAL([BUILD_MANPAGES], [test -e doc/man/named.conf.5in || test -n "$SPHINX_BUILD"])
-
-#
-# Pull release date from changelog.rst file last modification date
-# for reproducible builds
-#
-release_date=`date -u -r doc/arm/changelog.rst +%Y-%m-%d`
-AC_SUBST([RELEASE_DATE], $release_date)
-
-#
-# Look for Doxygen
-#
-AC_PATH_PROGS([DOXYGEN], [doxygen])
-
-AC_CONFIG_FILES([doc/doxygen/doxygen-input-filter],
-		[chmod +x doc/doxygen/doxygen-input-filter])
-
-#
-# Look for curl
-#
-
-AC_PATH_PROG(CURL, curl, curl)
-AC_SUBST(CURL)
-
-#
-# Look for nc
-#
-
-AC_PATH_PROGS(NC, nc, nc)
-AC_SUBST(NC)
-
-#
-# IDN support using libidn2
-#
-
-LIBIDN2_CFLAGS=
-LIBIDN2_LIBS=
-
-# [pairwise: --with-libidn2=yes, --without-libidn2]
-AC_ARG_WITH([libidn2],
-	    [AS_HELP_STRING([--with-libidn2[=PATH]], [enable IDN support using GNU libidn2 [yes|no(default)|path]])],
-	    [with_libidn2="$withval"], [with_libidn2="no"])
-AS_CASE([$with_libidn2],
-	[yes],	[PKG_CHECK_MODULES([LIBIDN2], [libidn2],
-				   [AC_DEFINE([HAVE_LIBIDN2], [1], [Define if libidn2 was found])])],
-	[no],	[],
-	[*],	[AX_SAVE_FLAGS([libidn2])
-		 LIBIDN2_CFLAGS="-I$with_libidn2/include"
-		 LIBIDN2_LIBS="-L$with_libidn2/lib"
-		 CFLAGS="$CFLAGS $LIBIDN2_CFLAGS"
-		 LIBS="$LIBS $LIBIDN2_LIBS"
-		 AC_CHECK_HEADERS([idn2.h],
-				  [],
-				  [AC_MSG_ERROR([idn2.h not found])])
-		 AC_SEARCH_LIBS([idn2_to_ascii_lz], [idn2],
-				[LIBIDN2_LIBS="$LIBIDN2_LIBS $ac_cv_search_idn2_to_ascii_lz"
-				 AC_DEFINE([HAVE_LIBIDN2], [1], [Define if libidn2 was found])],
-				[AC_MSG_ERROR([libidn2 requested, but not found])])
-		AX_RESTORE_FLAGS([libidn2])])
-AC_SUBST([LIBIDN2_CFLAGS])
-AC_SUBST([LIBIDN2_LIBS])
-
-#
-# Check whether to build with cmocka unit testing framework
-#
-# [pairwise: --with-cmocka=detect, --with-cmocka=yes, --without-cmocka]
-AC_ARG_WITH([cmocka],
-	    [AS_HELP_STRING([--with-cmocka=detect],[enable CMocka based tests (default is detect)])],
-	    [],[with_cmocka=detect])
-
-AS_CASE([$with_cmocka],
-	[no],[],
-	[detect],[PKG_CHECK_MODULES([CMOCKA], [cmocka >= 1.1.3],
-				    [AC_DEFINE([HAVE_CMOCKA], [1], [Use CMocka])
-				     with_cmocka=yes],[with_cmocka=no])],
-	[yes],[PKG_CHECK_MODULES([CMOCKA], [cmocka >= 1.1.3],
-				 [AC_DEFINE([HAVE_CMOCKA], [1], [Use CMocka])])],
-	[AC_MSG_ERROR([Use PKG_CONFIG_PATH to specify path to CMocka library])]
-       )
-AC_SUBST([CMOCKA_CFLAGS])
-AC_SUBST([CMOCKA_LIBS])
-
-AM_CONDITIONAL([HAVE_CMOCKA], [test "$with_cmocka" = "yes"])
-
-#
-# Compile with jemalloc (either provided as package or wired in the system on FreeBSD)
-#
-# [pairwise: --with-jemalloc=detect, --with-jemalloc=yes, --without-jemalloc]
-AC_ARG_WITH([jemalloc],
-	    [AS_HELP_STRING([--with-jemalloc=detect],[enable jemalloc memory allocator (default is detect)])],
-	    [],[with_jemalloc=detect])
-
-AS_CASE([$with_jemalloc],
-	[no],[],
-	[yes],[AX_CHECK_JEMALLOC(
-		 [AC_DEFINE([HAVE_JEMALLOC], [1], [Define to 1 if jemalloc is available])],
-		 [AC_MSG_ERROR([jemalloc not found])])],
-	[AX_CHECK_JEMALLOC(
-	   [AC_DEFINE([HAVE_JEMALLOC], [1], [Define to 1 if jemalloc is available])
-	    with_jemalloc=yes],
-	   [AC_MSG_WARN([jemalloc not found; performance will be reduced])
-	    with_jemalloc=no])])
-
-AS_IF([test "$with_jemalloc" = "no"],
-      [AS_CASE([$host],
-	       [*-freebsd*],[AC_MSG_ERROR([You cannot compile without jemalloc; jemalloc is the system allocator on FreeBSD])])])
-
-AM_CONDITIONAL([HAVE_JEMALLOC], [test "$with_jemalloc" = "yes"])
-
-#
-# was --enable-querytrace or --enable-singletrace specified?
-#
-# [pairwise: --enable-singletrace --enable-querytrace, --disable-singletrace --enable-querytrace, --disable-singletrace --disable-querytrace]
-AC_ARG_ENABLE([singletrace],
-	      AS_HELP_STRING([--enable-singletrace],
-			     [enable single-query trace logging
-			      [default=no]]),
-	      enable_singletrace="$enableval", enable_singletrace="no")
-
-AC_MSG_CHECKING([whether to enable single-query trace logging])
-case "$enable_singletrace" in
-yes)
-	enable_querytrace=yes
-	AC_MSG_RESULT(yes)
-	AC_DEFINE(WANT_SINGLETRACE, 1, [Define to enable single-query tracing.])
-	;;
-no)
-	AC_MSG_RESULT(no)
-	;;
-*)
-	AC_MSG_ERROR("--enable-singletrace requires yes or no")
-	;;
-esac
-
-# [pairwise: skip]
-AC_ARG_ENABLE(querytrace,
-	      AS_HELP_STRING([--enable-querytrace],
-			     [enable very verbose query trace logging
-				[default=no]]),
-	      enable_querytrace="$enableval",
-	      enable_querytrace="$enable_singletrace")
-
-AC_MSG_CHECKING([whether to enable query trace logging])
-case "$enable_querytrace" in
-yes)
-	AC_MSG_RESULT(yes)
-	AC_DEFINE(WANT_QUERYTRACE, 1, [Define to enable very verbose query trace logging.])
-	;;
-no)
-       AS_IF([test "$enable_singletrace" = "yes"],
-	     [AC_MSG_ERROR([--enable-singletrace requires --enable-querytrace])])
-	AC_MSG_RESULT(no)
-	;;
-*)
-	AC_MSG_ERROR("--enable-querytrace requires yes or no (not $enable_querytrace)")
-	;;
-esac
-
-#
-# Was --disable-auto-validation specified?
-#
-
-validation_default=auto
-
-# [pairwise: --enable-auto-validation, --disable-auto-validation]
-AC_ARG_ENABLE(auto-validation,
-	      AS_HELP_STRING([--enable-auto-validation],
-			     [turn on DNSSEC validation by default, using the IANA root key [default=yes]]),
-	      [:],[enable_auto_validation=yes])
-AS_IF([test "$enable_auto_validation" = "no"],[validation_default=yes])
-AC_DEFINE_UNQUOTED([VALIDATION_DEFAULT], ["$validation_default"], [the default value of dnssec-validation option])
-
-#
-#
-# Response policy rewriting using DNS Response Policy Service (DNSRPS)
-# interface.
-#
-# DNSRPS can be compiled into BIND everywhere with a reasonably
-# modern C compiler.  It is enabled on systems with dlopen() and librpz.so.
-#
-dnsrps_avail=yes
-AC_MSG_CHECKING([for librpz __attribute__s])
-AC_COMPILE_IFELSE(
-  [AC_LANG_PROGRAM(
-     [[]],
-     [[
-       extern void f(char *p __attribute__((unused)), ...)
-       __attribute__((format(printf,1,2))) __attribute__((__noreturn__));
-     ]])],
-  [
-    librpz_have_attr=yes
-    AC_DEFINE([LIBRPZ_HAVE_ATTR], [1], [have __attribute__s used in librpz.h])
-    AC_MSG_RESULT([yes])
-  ],[
-    librpz_have_attr=no
-    AC_MSG_RESULT([no])
-  ])
-
-# [pairwise: --enable-dnsrps --enable-dnsrps-dl, --disable-dnsrps]
-AC_ARG_ENABLE([dnsrps-dl],
-	      [AS_HELP_STRING([--enable-dnsrps-dl],
-			      [DNS Response Policy Service delayed link
-			       [default=$librpz_dl]])],
-	      [enable_librpz_dl="$enableval"], [enable_librpz_dl="$with_dlopen"])
-
-AS_IF([test "$enable_librpz_dl" = "yes" -a "$with_dlopen" = "no"],
-      [AC_MSG_ERROR([DNS Response Policy Service delayed link requires dlopen to be enabled])])
-
-# [pairwise: skip]
-AC_ARG_WITH([dnsrps-libname],
-	    [AS_HELP_STRING([--with-dnsrps-libname],
-			    [DNSRPS provider library name (librpz.so)])],
-	    [librpz_name="$withval"], [librpz_name="librpz.so"])
-
-# [pairwise: skip]
-AC_ARG_WITH([dnsrps-dir],
-	    [AS_HELP_STRING([--with-dnsrps-dir],
-			    [path to DNSRPS provider library])],
-	    [librpz_path="$withval/$librpz_name"], [librpz_path="$librpz_name"])
-AC_DEFINE_UNQUOTED([DNSRPS_LIBRPZ_PATH], ["$librpz_path"],
-		   [dnsrps $librpz_name])
-AS_IF([test "$enable_librpz_dl" = "yes"],
-      [
-	dnsrps_lib_open=2
-      ],[
-	dnsrps_lib_open=1
-	# Add librpz.so to linked libraries if we are not using dlopen()
-	AC_SEARCH_LIBS([librpz_client_create], [rpz], [],
-		[dnsrps_lib_open=0
-		 dnsrps_avail=no])
-      ])
-AC_DEFINE_UNQUOTED([DNSRPS_LIB_OPEN], [$dnsrps_lib_open],
-		   [0=no DNSRPS  1=static link  2=dlopen()])
-
-# [pairwise: skip]
-AC_ARG_ENABLE([dnsrps],
-	      AS_HELP_STRING([--enable-dnsrps],
-			     [enable DNS Response Policy Service API]),
-	      [enable_dnsrps=$enableval], [enable_dnsrps=no])
-
-AS_IF([test "$enable_dnsrps" != "no"],[
-	AS_IF([test "$dnsrps_avail" != "yes"],
-	      [AC_MSG_ERROR([dlopen and librpz.so needed for DNSRPS])])
-	AS_IF([test "$dnsrps_lib_open" = "0"],
-	      [AC_MSG_ERROR([dlopen and librpz.so needed for DNSRPS])])
-	AC_DEFINE([USE_DNSRPS], [1], [Enable DNS Response Policy Service API])
-      ])
-
-AC_CHECK_HEADERS([glob.h])
-
 #
 # Support for constructor and destructor attributes
 #
@@ -1472,74 +713,18 @@ AC_CONFIG_FILES([Makefile])
 # Binaries
 
 AC_CONFIG_FILES([bin/Makefile
-		 bin/named/Makefile
-		 bin/rndc/Makefile
-		 bin/dig/Makefile
-		 bin/delv/Makefile
-		 bin/dnssec/Makefile
-		 bin/tools/Makefile
-		 bin/nsupdate/Makefile
-		 bin/check/Makefile
-		 bin/confgen/Makefile
-		 bin/plugins/Makefile])
+		 bin/dig/Makefile])
 
 # Libraries
 
 AC_CONFIG_FILES([lib/Makefile
 		 lib/isc/Makefile
 		 lib/dns/Makefile
-		 lib/ns/Makefile
 		 lib/irs/Makefile
 		 lib/isccfg/Makefile
 		 lib/isccc/Makefile
 		 lib/bind9/Makefile])
 
-# Documentation
-
-AC_CONFIG_FILES([doc/Makefile
-		 doc/arm/Makefile
-		 doc/man/Makefile
-		 doc/misc/Makefile])
-
-# Unit Tests
-
-AC_CONFIG_FILES([tests/Makefile
-		 tests/isc/Makefile
-		 tests/dns/Makefile
-		 tests/ns/Makefile
-		 tests/irs/Makefile
-		 tests/isccfg/Makefile
-		 tests/libtest/Makefile])
-
-AC_CONFIG_FILES([tests/unit-test-driver.sh],
-		[chmod +x tests/unit-test-driver.sh])
-
-# System Tests
-
-AC_CONFIG_FILES([bin/tests/Makefile
-		 bin/tests/system/Makefile
-		 bin/tests/system/conf.sh
-		 bin/tests/system/dyndb/driver/Makefile
-		 bin/tests/system/dlzexternal/driver/Makefile
-		 bin/tests/system/hooks/driver/Makefile])
-
-AC_CONFIG_FILES([bin/tests/system/ifconfig.sh],
-		[chmod +x bin/tests/system/ifconfig.sh])
-AC_CONFIG_FILES([bin/tests/system/legacy.run.sh],
-		[chmod +x bin/tests/system/legacy.run.sh])
-AC_CONFIG_FILES([bin/tests/system/start.sh],
-		[chmod +x bin/tests/system/start.sh])
-AC_CONFIG_FILES([bin/tests/system/stop.sh],
-		[chmod +x bin/tests/system/stop.sh])
-
-# Fuzz Tests
-
-AC_CONFIG_FILES([fuzz/Makefile])
-
-# Misc
-
-AC_CONFIG_FILES([util/check-make-install.sh])
-
 #
 # Do it
 #
@@ -1562,32 +747,12 @@ report() {
     if test "yes" = "$enable_full_report" -o "standard" = "$with_locktype"; then
 	echo "    Mutex lock type: $with_locktype"
     fi
-    test "no" = "$enable_dnstap" || \
-	    echo "    Allow 'dnstap' packet logging (--enable-dnstap)"
-    test -z "$MAXMINDDB_LIBS" || echo "    GeoIP2 access control (--enable-geoip)"
-    test -z "$GSSAPI_LIBS" || echo "    GSS-API (--with-gssapi)"
 
     # these lines are only printed if run with --enable-full-report
     if test "yes" = "$enable_full_report"; then
-	test -z "$LIBXML2_LIBS" || echo "    XML statistics (--with-libxml2)"
-	test -z "$JSON_C_LIBS" || echo "    JSON statistics (--with-json-c): $JSON_C_CFLAGS $JSON_C_LIBS"
 	test -z "$ZLIB_LIBS" || echo "    HTTP zlib compression (--with-zlib)"
-	test -z "$LMDB_LIBS" || echo "    LMDB database to store configuration for 'addzone' zones (--with-lmdb)"
-	test -z "$LIBIDN2_LIBS" || echo "    IDN support (--with-libidn2)"
     fi
 
-    test "yes" = "$enable_dnsrps" && \
-	echo "    DNS Response Policy Service interface (--enable-dnsrps)"
-    test "yes" = "$enable_fixed_rrset" && \
-	echo "    Allow 'fixed' rrset-order (--enable-fixed-rrset)"
-    test "yes" = "$enable_querytrace" && \
-	echo "    Very verbose query trace logging (--enable-querytrace)"
-    test "yes" = "$enable_singletrace" && \
-	echo "    Single-query trace logging (--enable-singletrace)"
-    test -z "$HAVE_CMOCKA" || echo "    CMocka Unit Testing Framework (--with-cmocka)"
-
-    test "auto" = "$validation_default" && echo "    DNSSEC validation active by default (--enable-auto-validation)"
-
     echo "-------------------------------------------------------------------------------"
 
     echo "Features disabled or unavailable on this platform:"
@@ -1607,31 +772,7 @@ report() {
       echo
     fi
 
-    test "no" = "$enable_dnstap" && \
-	    echo "    Allow 'dnstap' packet logging (--enable-dnstap)"
-    test -z "$MAXMINDDB_LIBS" && echo "    GeoIP2 access control (--enable-geoip)"
-    test -z "$GSSAPI_LIBS" && echo "    GSS-API (--with-gssapi)"
-
-    test "no" = "$enable_dnsrps" && \
-	echo "    DNS Response Policy Service interface (--enable-dnsrps)"
-
-    test "yes" = "$enable_fixed_rrset" || \
-	echo "    Allow 'fixed' rrset-order (--enable-fixed-rrset)"
-
-    test "yes" = "$validation_default" && echo "    DNSSEC validation requires configuration (--enable-auto-validation)"
-
-    test "yes" = "$enable_querytrace" || \
-	echo "    Very verbose query trace logging (--enable-querytrace)"
-    test "yes" = "$enable_singletrace" || \
-	echo "    Single-query trace logging (--enable-singletrace)"
-
-    test "no" = "$with_cmocka" && echo "    CMocka Unit Testing Framework (--with-cmocka)"
-
-    test -z "$LIBXML2_LIBS" && echo "    XML statistics (--with-libxml2)"
-    test -z "$JSON_C_LIBS" && echo "    JSON statistics (--with-json-c)"
     test -z "$ZLIB_LIBS" && echo "    HTTP zlib compression (--with-zlib)"
-    test -z "$LMDB_LIBS" && echo "    LMDB database to store configuration for 'addzone' zones (--with-lmdb)"
-    test -z "$LIBIDN2_LIBS" && echo "    IDN support (--with-libidn2)"
 
     echo "-------------------------------------------------------------------------------"
     echo "Configured paths:"
diff --git a/lib/Makefile.am b/lib/Makefile.am
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -1,3 +1,3 @@
 include $(top_srcdir)/Makefile.top
 
-SUBDIRS = isc dns isccc ns isccfg bind9 irs
+SUBDIRS = isc dns isccc isccfg bind9 irs
diff --git a/lib/bind9/Makefile.am b/lib/bind9/Makefile.am
--- a/lib/bind9/Makefile.am
+++ b/lib/bind9/Makefile.am
@@ -4,12 +4,10 @@ lib_LTLIBRARIES = libbind9.la
 
 libbind9_ladir = $(includedir)/bind9
 libbind9_la_HEADERS =			\
-	include/bind9/check.h		\
 	include/bind9/getaddresses.h
 
 libbind9_la_SOURCES =		\
 	$(libbind9_la_HEADERS)	\
-	check.c			\
 	getaddresses.c
 
 libbind9_la_CPPFLAGS =		\
@@ -17,7 +15,6 @@ libbind9_la_CPPFLAGS =		\
 	$(LIBISC_CFLAGS)	\
 	$(LIBDNS_CFLAGS)	\
 	$(LIBISCCFG_CFLAGS)	\
-	$(LIBNS_CFLAGS)		\
 	$(LIBBIND9_CFLAGS)	\
 	$(OPENSSL_CFLAGS)
 
@@ -30,7 +27,3 @@ libbind9_la_LIBADD =		\
 libbind9_la_LDFLAGS =		\
 	$(AM_LDFLAGS)		\
 	-release "$(PACKAGE_VERSION)"
-
-if HAVE_DNSTAP
-libbind9_la_CPPFLAGS += $(DNSTAP_CFLAGS)
-endif
diff --git a/lib/dns/Makefile.am b/lib/dns/Makefile.am
--- a/lib/dns/Makefile.am
+++ b/lib/dns/Makefile.am
@@ -23,7 +23,6 @@ gen$(BUILD_EXEEXT): gen.c
 	$(CC_FOR_BUILD) -g -I. $(srcdir)/gen.c -o $@
 
 EXTRA_DIST =		\
-	dnstap.proto	\
 	gen.c		\
 	rdata/*
 
@@ -47,61 +46,40 @@ code.h: gen Makefile
 libdns_ladir = $(includedir)/dns
 libdns_la_HEADERS =			\
 	include/dns/acl.h		\
-	include/dns/adb.h		\
 	include/dns/badcache.h		\
 	include/dns/bit.h		\
 	include/dns/byaddr.h		\
 	include/dns/cache.h		\
 	include/dns/callbacks.h		\
-	include/dns/catz.h		\
 	include/dns/cert.h		\
-	include/dns/client.h		\
 	include/dns/clientinfo.h	\
 	include/dns/compress.h		\
 	include/dns/db.h		\
 	include/dns/dbiterator.h	\
 	include/dns/diff.h		\
 	include/dns/dispatch.h		\
-	include/dns/dlz.h		\
-	include/dns/dlz_dlopen.h	\
 	include/dns/dns64.h		\
-	include/dns/dnsrps.h		\
 	include/dns/dnssec.h		\
-	include/dns/dnstap.h		\
 	include/dns/ds.h		\
 	include/dns/dsdigest.h		\
 	include/dns/dsync.h		\
-	include/dns/dyndb.h		\
 	include/dns/ecs.h		\
 	include/dns/edns.h		\
 	include/dns/events.h		\
 	include/dns/fixedname.h		\
-	include/dns/forward.h		\
-	include/dns/geoip.h		\
 	include/dns/ipkeylist.h		\
 	include/dns/iptable.h		\
-	include/dns/journal.h		\
-	include/dns/kasp.h		\
 	include/dns/keydata.h		\
 	include/dns/keyflags.h		\
-	include/dns/keymgr.h		\
-	include/dns/keytable.h		\
 	include/dns/keyvalues.h		\
-	include/dns/librpz.h		\
 	include/dns/log.h		\
-	include/dns/lookup.h		\
 	include/dns/master.h		\
 	include/dns/masterdump.h	\
 	include/dns/message.h		\
 	include/dns/name.h		\
 	include/dns/ncache.h		\
-	include/dns/nsec.h		\
-	include/dns/nsec3.h		\
-	include/dns/nta.h		\
 	include/dns/opcode.h		\
 	include/dns/order.h		\
-	include/dns/peer.h		\
-	include/dns/private.h		\
 	include/dns/rbt.h		\
 	include/dns/rcode.h		\
 	include/dns/rdata.h		\
@@ -112,59 +90,38 @@ libdns_la_HEADERS =			\
 	include/dns/rdataslab.h		\
 	include/dns/rdatatype.h		\
 	include/dns/request.h		\
-	include/dns/resolver.h		\
 	include/dns/result.h		\
-	include/dns/rootns.h		\
-	include/dns/rpz.h		\
 	include/dns/rriterator.h	\
-	include/dns/rrl.h		\
-	include/dns/sdb.h		\
-	include/dns/sdlz.h		\
 	include/dns/secalg.h		\
 	include/dns/secproto.h		\
 	include/dns/soa.h		\
-	include/dns/ssu.h		\
-	include/dns/stats.h		\
 	include/dns/time.h		\
 	include/dns/tkey.h		\
 	include/dns/transport.h		\
 	include/dns/tsec.h		\
 	include/dns/tsig.h		\
 	include/dns/ttl.h		\
-	include/dns/types.h		\
-	include/dns/update.h		\
-	include/dns/validator.h		\
-	include/dns/view.h		\
-	include/dns/xfrin.h		\
-	include/dns/zone.h		\
-	include/dns/zonekey.h		\
-	include/dns/zoneverify.h	\
-	include/dns/zt.h
+	include/dns/types.h
 
 dstdir = $(includedir)/dst
 dst_HEADERS =				\
-	include/dst/dst.h		\
-	include/dst/gssapi.h
+	include/dst/dst.h
 
 libdns_la_SOURCES =			\
 	$(libdns_la_HEADERS)		\
 	$(dst_HEADERS)			\
 	acl.c				\
-	adb.c				\
 	badcache.c			\
 	byaddr.c			\
 	cache.c				\
 	callbacks.c			\
-	catz.c				\
 	clientinfo.c			\
 	compress.c			\
 	db.c				\
 	dbiterator.c			\
 	diff.c				\
 	dispatch.c			\
-	dlz.c				\
 	dns64.c				\
-	dnsrps.c			\
 	dnssec.c			\
 	ds.c				\
 	dst_api.c			\
@@ -172,30 +129,19 @@ libdns_la_SOURCES =			\
 	dst_openssl.h			\
 	dst_parse.c			\
 	dst_parse.h			\
-	dyndb.c				\
 	ecs.c				\
 	fixedname.c			\
-	forward.c			\
-	gssapictx.c			\
 	hmac_link.c			\
 	ipkeylist.c			\
 	iptable.c			\
-	journal.c			\
-	kasp.c				\
 	key.c				\
 	keydata.c			\
-	keymgr.c			\
-	keytable.c			\
 	log.c				\
-	lookup.c			\
 	master.c			\
 	masterdump.c			\
 	message.c			\
 	name.c				\
 	ncache.c			\
-	nsec.c				\
-	nsec3.c				\
-	nta.c				\
 	openssl_link.c			\
 	openssl_shim.c			\
 	openssl_shim.h			\
@@ -204,8 +150,6 @@ libdns_la_SOURCES =			\
 	openssleddsa_link.c		\
 	opensslrsa_link.c		\
 	order.c				\
-	peer.c				\
-	private.c			\
 	rbt.c				\
 	rbtdb.h				\
 	rbtdb.c				\
@@ -216,47 +160,19 @@ libdns_la_SOURCES =			\
 	rdatasetiter.c			\
 	rdataslab.c			\
 	request.c			\
-	resolver.c			\
 	result.c			\
-	rootns.c			\
-	rpz.c				\
-	rrl.c				\
 	rriterator.c			\
-	sdb.c				\
-	sdlz.c				\
 	soa.c				\
-	ssu.c				\
-	ssu_external.c			\
-	stats.c				\
 	time.c				\
 	transport.c			\
 	tkey.c				\
 	tsec.c				\
 	tsig.c				\
 	ttl.c				\
-	update.c			\
-	validator.c			\
-	view.c				\
-	xfrin.c				\
-	zone.c				\
-	zoneverify.c			\
-	zonekey.c			\
-	zt.c				\
-	client.c			\
 	rdatalist_p.h			\
 	tsig_p.h			\
 	zone_p.h
 
-if HAVE_GSSAPI
-libdns_la_SOURCES +=			\
-	gssapi_link.c
-endif
-
-if HAVE_GEOIP2
-libdns_la_SOURCES += \
-	geoip2.c
-endif
-
 libdns_la_CPPFLAGS =		\
 	$(AM_CPPFLAGS)		\
 	$(LIBDNS_CFLAGS)	\
@@ -272,55 +188,3 @@ libdns_la_LIBADD =		\
 	$(LIBISC_LIBS)		\
 	$(LIBUV_LIBS)		\
 	$(OPENSSL_LIBS)
-
-if HAVE_JSON_C
-libdns_la_CPPFLAGS +=		\
-	$(JSON_C_CFLAGS)
-
-libdns_la_LIBADD +=		\
-	$(JSON_C_LIBS)
-endif HAVE_JSON_C
-
-if HAVE_LIBXML2
-libdns_la_CPPFLAGS +=		\
-	$(LIBXML2_CFLAGS)
-
-libdns_la_LIBADD +=		\
-	$(LIBXML2_LIBS)
-endif HAVE_LIBXML2
-
-if HAVE_GSSAPI
-libdns_la_CPPFLAGS +=		\
-	$(GSSAPI_CFLAGS)	\
-	$(KRB5_CFLAGS)
-libdns_la_LIBADD +=		\
-	$(GSSAPI_LIBS)		\
-	$(KRB5_LIBS)
-endif
-
-if HAVE_GEOIP2
-libdns_la_CPPFLAGS +=		\
-	$(MAXMINDDB_CFLAGS)
-libdns_la_LIBADD +=		\
-	$(MAXMINDDB_LIBS)
-endif
-
-if HAVE_DNSTAP
-nodist_libdns_la_SOURCES +=	\
-	dnstap.pb-c.h		\
-	dnstap.pb-c.c
-
-libdns_la_SOURCES +=		\
-	dnstap.c
-
-dnstap.pb-c.h dnstap.pb-c.c: dnstap.proto
-	$(PROTOC_C) --proto_path=$(srcdir) --c_out=. dnstap.proto
-
-libdns_la_CPPFLAGS += $(DNSTAP_CFLAGS)
-libdns_la_LIBADD += $(DNSTAP_LIBS)
-endif
-
-if HAVE_LMDB
-libdns_la_CPPFLAGS += $(LMDB_CFLAGS)
-libdns_la_LIBADD += $(LMDB_LIBS)
-endif
diff --git a/lib/dns/acl.c b/lib/dns/acl.c
--- a/lib/dns/acl.c
+++ b/lib/dns/acl.c
@@ -370,14 +370,6 @@ dns_acl_merge(dns_acl_t *dest, dns_acl_t *source, bool pos) {
 				     &dest->elements[nelem + i].keyname);
 		}
 
-#if defined(HAVE_GEOIP2)
-		/* Duplicate GeoIP data */
-		if (source->elements[i].type == dns_aclelementtype_geoip) {
-			dest->elements[nelem + i].geoip_elem =
-				source->elements[i].geoip_elem;
-		}
-#endif /* if defined(HAVE_GEOIP2) */
-
 		/* reverse sense of positives if this is a negative acl */
 		if (!pos && !source->elements[i].negative) {
 			dest->elements[nelem + i].negative = true;
@@ -468,13 +460,6 @@ dns_aclelement_match(const isc_netaddr_t *reqaddr, const dns_name_t *reqsigner,
 		RWUNLOCK(&env->rwlock, isc_rwlocktype_read);
 		break;
 
-#if defined(HAVE_GEOIP2)
-	case dns_aclelementtype_geoip:
-		if (env == NULL || env->geoip == NULL) {
-			return false;
-		}
-		return dns_geoip_match(reqaddr, env->geoip, &e->geoip_elem);
-#endif /* if defined(HAVE_GEOIP2) */
 	default:
 		UNREACHABLE();
 	}
@@ -664,9 +649,6 @@ dns_acl_isinsecure(const dns_acl_t *a) {
 			}
 			continue;
 
-#if defined(HAVE_GEOIP2)
-		case dns_aclelementtype_geoip:
-#endif /* if defined(HAVE_GEOIP2) */
 		case dns_aclelementtype_localnets:
 			return true;
 
@@ -720,9 +702,6 @@ dns_aclenv_create(isc_mem_t *mctx, dns_aclenv_t **envp) {
 		goto cleanup_localhost;
 	}
 	env->match_mapped = false;
-#if defined(HAVE_GEOIP2)
-	env->geoip = NULL;
-#endif /* if defined(HAVE_GEOIP2) */
 
 	env->magic = DNS_ACLENV_MAGIC;
 
@@ -763,9 +742,6 @@ dns_aclenv_copy(dns_aclenv_t *t, dns_aclenv_t *s) {
 	dns_acl_attach(s->localnets, &t->localnets);
 
 	t->match_mapped = s->match_mapped;
-#if defined(HAVE_GEOIP2)
-	t->geoip = s->geoip;
-#endif /* if defined(HAVE_GEOIP2) */
 
 	RWUNLOCK(&s->rwlock, isc_rwlocktype_read);
 	RWUNLOCK(&t->rwlock, isc_rwlocktype_write);
diff --git a/lib/dns/byaddr.c b/lib/dns/byaddr.c
--- a/lib/dns/byaddr.c
+++ b/lib/dns/byaddr.c
@@ -15,23 +15,14 @@
 
 #include <stdbool.h>
 
-#include <isc/mem.h>
+#include <isc/buffer.h>
 #include <isc/netaddr.h>
 #include <isc/print.h>
 #include <isc/result.h>
 #include <isc/string.h> /* Required for HP/UX (and others?) */
-#include <isc/task.h>
-#include <isc/util.h>
 
 #include <dns/byaddr.h>
-#include <dns/db.h>
-#include <dns/events.h>
-#include <dns/lookup.h>
-#include <dns/rdata.h>
-#include <dns/rdataset.h>
-#include <dns/rdatastruct.h>
-#include <dns/resolver.h>
-#include <dns/view.h>
+#include <dns/name.h>
 
 /*
  * XXXRTH  We could use a static event...
@@ -88,195 +79,3 @@ dns_byaddr_createptrname(const isc_netaddr_t *address, unsigned int options,
 	isc_buffer_add(&buffer, len);
 	return dns_name_fromtext(name, &buffer, dns_rootname, 0, NULL);
 }
-
-struct dns_byaddr {
-	/* Unlocked. */
-	unsigned int magic;
-	isc_mem_t *mctx;
-	isc_mutex_t lock;
-	dns_fixedname_t name;
-	/* Locked by lock. */
-	unsigned int options;
-	dns_lookup_t *lookup;
-	isc_task_t *task;
-	dns_byaddrevent_t *event;
-	bool canceled;
-};
-
-#define BYADDR_MAGIC	ISC_MAGIC('B', 'y', 'A', 'd')
-#define VALID_BYADDR(b) ISC_MAGIC_VALID(b, BYADDR_MAGIC)
-
-#define MAX_RESTARTS 16
-
-static isc_result_t
-copy_ptr_targets(dns_byaddr_t *byaddr, dns_rdataset_t *rdataset) {
-	isc_result_t result;
-	dns_name_t *name;
-	dns_rdata_t rdata = DNS_RDATA_INIT;
-
-	/*
-	 * The caller must be holding the byaddr's lock.
-	 */
-
-	result = dns_rdataset_first(rdataset);
-	while (result == ISC_R_SUCCESS) {
-		dns_rdata_ptr_t ptr;
-		dns_rdataset_current(rdataset, &rdata);
-		result = dns_rdata_tostruct(&rdata, &ptr, NULL);
-		if (result != ISC_R_SUCCESS) {
-			return result;
-		}
-		name = isc_mem_get(byaddr->mctx, sizeof(*name));
-		dns_name_init(name, NULL);
-		dns_name_dup(&ptr.ptr, byaddr->mctx, name);
-		dns_rdata_freestruct(&ptr);
-		ISC_LIST_APPEND(byaddr->event->names, name, link);
-		dns_rdata_reset(&rdata);
-		result = dns_rdataset_next(rdataset);
-	}
-	if (result == ISC_R_NOMORE) {
-		result = ISC_R_SUCCESS;
-	}
-
-	return result;
-}
-
-static void
-lookup_done(isc_task_t *task, isc_event_t *event) {
-	dns_byaddr_t *byaddr = event->ev_arg;
-	dns_lookupevent_t *levent;
-	isc_result_t result;
-
-	REQUIRE(event->ev_type == DNS_EVENT_LOOKUPDONE);
-	REQUIRE(VALID_BYADDR(byaddr));
-	REQUIRE(byaddr->task == task);
-
-	UNUSED(task);
-
-	levent = (dns_lookupevent_t *)event;
-
-	if (levent->result == ISC_R_SUCCESS) {
-		result = copy_ptr_targets(byaddr, levent->rdataset);
-		byaddr->event->result = result;
-	} else {
-		byaddr->event->result = levent->result;
-	}
-	isc_event_free(&event);
-	isc_task_sendanddetach(&byaddr->task, (isc_event_t **)&byaddr->event);
-}
-
-static void
-bevent_destroy(isc_event_t *event) {
-	dns_byaddrevent_t *bevent;
-	dns_name_t *name, *next_name;
-	isc_mem_t *mctx;
-
-	REQUIRE(event->ev_type == DNS_EVENT_BYADDRDONE);
-	mctx = event->ev_destroy_arg;
-	bevent = (dns_byaddrevent_t *)event;
-
-	for (name = ISC_LIST_HEAD(bevent->names); name != NULL;
-	     name = next_name)
-	{
-		next_name = ISC_LIST_NEXT(name, link);
-		ISC_LIST_UNLINK(bevent->names, name, link);
-		dns_name_free(name, mctx);
-		isc_mem_put(mctx, name, sizeof(*name));
-	}
-	isc_mem_put(mctx, event, event->ev_size);
-}
-
-isc_result_t
-dns_byaddr_create(isc_mem_t *mctx, const isc_netaddr_t *address,
-		  dns_view_t *view, unsigned int options, isc_task_t *task,
-		  isc_taskaction_t action, void *arg, dns_byaddr_t **byaddrp) {
-	isc_result_t result;
-	dns_byaddr_t *byaddr;
-	isc_event_t *ievent;
-
-	byaddr = isc_mem_get(mctx, sizeof(*byaddr));
-	byaddr->mctx = NULL;
-	isc_mem_attach(mctx, &byaddr->mctx);
-	byaddr->options = options;
-
-	byaddr->event = isc_mem_get(mctx, sizeof(*byaddr->event));
-	ISC_EVENT_INIT(byaddr->event, sizeof(*byaddr->event), 0, NULL,
-		       DNS_EVENT_BYADDRDONE, action, arg, byaddr,
-		       bevent_destroy, mctx);
-	byaddr->event->result = ISC_R_FAILURE;
-	ISC_LIST_INIT(byaddr->event->names);
-
-	byaddr->task = NULL;
-	isc_task_attach(task, &byaddr->task);
-
-	isc_mutex_init(&byaddr->lock);
-
-	dns_fixedname_init(&byaddr->name);
-
-	result = dns_byaddr_createptrname(address, options,
-					  dns_fixedname_name(&byaddr->name));
-	if (result != ISC_R_SUCCESS) {
-		goto cleanup_lock;
-	}
-
-	byaddr->lookup = NULL;
-	result = dns_lookup_create(mctx, dns_fixedname_name(&byaddr->name),
-				   dns_rdatatype_ptr, view, 0, task,
-				   lookup_done, byaddr, &byaddr->lookup);
-	if (result != ISC_R_SUCCESS) {
-		goto cleanup_lock;
-	}
-
-	byaddr->canceled = false;
-	byaddr->magic = BYADDR_MAGIC;
-
-	*byaddrp = byaddr;
-
-	return ISC_R_SUCCESS;
-
-cleanup_lock:
-	isc_mutex_destroy(&byaddr->lock);
-
-	ievent = (isc_event_t *)byaddr->event;
-	isc_event_free(&ievent);
-	byaddr->event = NULL;
-
-	isc_task_detach(&byaddr->task);
-
-	isc_mem_putanddetach(&mctx, byaddr, sizeof(*byaddr));
-
-	return result;
-}
-
-void
-dns_byaddr_cancel(dns_byaddr_t *byaddr) {
-	REQUIRE(VALID_BYADDR(byaddr));
-
-	LOCK(&byaddr->lock);
-
-	if (!byaddr->canceled) {
-		byaddr->canceled = true;
-		if (byaddr->lookup != NULL) {
-			dns_lookup_cancel(byaddr->lookup);
-		}
-	}
-
-	UNLOCK(&byaddr->lock);
-}
-
-void
-dns_byaddr_destroy(dns_byaddr_t **byaddrp) {
-	dns_byaddr_t *byaddr;
-
-	REQUIRE(byaddrp != NULL);
-	byaddr = *byaddrp;
-	*byaddrp = NULL;
-	REQUIRE(VALID_BYADDR(byaddr));
-	REQUIRE(byaddr->event == NULL);
-	REQUIRE(byaddr->task == NULL);
-	dns_lookup_destroy(&byaddr->lookup);
-
-	isc_mutex_destroy(&byaddr->lock);
-	byaddr->magic = 0;
-	isc_mem_putanddetach(&byaddr->mctx, byaddr, sizeof(*byaddr));
-}
diff --git a/lib/dns/cache.c b/lib/dns/cache.c
--- a/lib/dns/cache.c
+++ b/lib/dns/cache.c
@@ -20,7 +20,6 @@
 #include <isc/print.h>
 #include <isc/refcount.h>
 #include <isc/result.h>
-#include <isc/stats.h>
 #include <isc/string.h>
 #include <isc/task.h>
 #include <isc/time.h>
@@ -36,16 +35,6 @@
 #include <dns/rdata.h>
 #include <dns/rdataset.h>
 #include <dns/rdatasetiter.h>
-#include <dns/stats.h>
-
-#ifdef HAVE_JSON_C
-#include <json_object.h>
-#endif /* HAVE_JSON_C */
-
-#ifdef HAVE_LIBXML2
-#include <libxml/xmlwriter.h>
-#define ISC_XMLCHAR (const xmlChar *)
-#endif /* HAVE_LIBXML2 */
 
 #include "rbtdb.h"
 
@@ -145,7 +134,6 @@ struct dns_cache {
 	size_t size;
 	dns_ttl_t serve_stale_ttl;
 	dns_ttl_t serve_stale_refresh;
-	isc_stats_t *stats;
 	uint32_t maxrrperset;
 	uint32_t maxtypepername;
 };
@@ -314,10 +302,6 @@ cache_free(dns_cache_t *cache) {
 		isc_mem_free(cache->mctx, cache->name);
 	}
 
-	if (cache->stats != NULL) {
-		isc_stats_detach(&cache->stats);
-	}
-
 	if (cache->taskmgr != NULL) {
 		isc_taskmgr_detach(&cache->taskmgr);
 	}
@@ -369,12 +353,6 @@ dns_cache_create(isc_mem_t *mctx, isc_taskmgr_t *taskmgr,
 	isc_refcount_init(&cache->references, 1);
 	isc_refcount_init(&cache->live_tasks, 1);
 
-	result = isc_stats_create(mctx, &cache->stats,
-				  dns_cachestatscounter_max);
-	if (result != ISC_R_SUCCESS) {
-		goto cleanup;
-	}
-
 	/*
 	 * For databases of type "rbt" we pass hmctx to dns_db_create()
 	 * via cache->db_argv, followed by the rest of the arguments in
@@ -422,11 +400,6 @@ dns_cache_create(isc_mem_t *mctx, isc_taskmgr_t *taskmgr,
 		goto cleanup;
 	}
 
-	result = dns_db_setcachestats(cache->db, cache->stats);
-	if (result != ISC_R_SUCCESS) {
-		goto cleanup;
-	}
-
 	*cachep = cache;
 	return ISC_R_SUCCESS;
 
@@ -1042,7 +1015,6 @@ dns_cache_flush(dns_cache_t *cache) {
 	updatewater(cache);
 	olddb = cache->db;
 	cache->db = db;
-	dns_db_setcachestats(cache->db, cache->stats);
 	UNLOCK(&cache->cleaner.lock);
 	UNLOCK(&cache->lock);
 
@@ -1212,37 +1184,6 @@ cleanup_db:
 	return result;
 }
 
-isc_stats_t *
-dns_cache_getstats(dns_cache_t *cache) {
-	REQUIRE(VALID_CACHE(cache));
-	return cache->stats;
-}
-
-void
-dns_cache_updatestats(dns_cache_t *cache, isc_result_t result) {
-	REQUIRE(VALID_CACHE(cache));
-	if (cache->stats == NULL) {
-		return;
-	}
-
-	switch (result) {
-	case ISC_R_SUCCESS:
-	case DNS_R_NCACHENXDOMAIN:
-	case DNS_R_NCACHENXRRSET:
-	case DNS_R_CNAME:
-	case DNS_R_DNAME:
-	case DNS_R_GLUE:
-	case DNS_R_ZONECUT:
-	case DNS_R_COVERINGNSEC:
-		isc_stats_increment(cache->stats,
-				    dns_cachestatscounter_queryhits);
-		break;
-	default:
-		isc_stats_increment(cache->stats,
-				    dns_cachestatscounter_querymisses);
-	}
-}
-
 void
 dns_cache_setmaxrrperset(dns_cache_t *cache, uint32_t value) {
 	REQUIRE(VALID_CACHE(cache));
@@ -1269,245 +1210,9 @@ dns_cache_setmaxtypepername(dns_cache_t *cache, uint32_t value) {
  * called from both places.
  */
 typedef struct cache_dumparg {
-	isc_statsformat_t type;
 	void *arg;		 /* type dependent argument */
 	int ncounters;		 /* for general statistics */
 	int *counterindices;	 /* for general statistics */
 	uint64_t *countervalues; /* for general statistics */
 	isc_result_t result;
 } cache_dumparg_t;
-
-static void
-getcounter(isc_statscounter_t counter, uint64_t val, void *arg) {
-	cache_dumparg_t *dumparg = arg;
-
-	REQUIRE(counter < dumparg->ncounters);
-	dumparg->countervalues[counter] = val;
-}
-
-static void
-getcounters(isc_stats_t *stats, isc_statsformat_t type, int ncounters,
-	    int *indices, uint64_t *values) {
-	cache_dumparg_t dumparg;
-
-	memset(values, 0, sizeof(values[0]) * ncounters);
-
-	dumparg.type = type;
-	dumparg.ncounters = ncounters;
-	dumparg.counterindices = indices;
-	dumparg.countervalues = values;
-
-	isc_stats_dump(stats, getcounter, &dumparg, ISC_STATSDUMP_VERBOSE);
-}
-
-void
-dns_cache_dumpstats(dns_cache_t *cache, FILE *fp) {
-	int indices[dns_cachestatscounter_max];
-	uint64_t values[dns_cachestatscounter_max];
-
-	REQUIRE(VALID_CACHE(cache));
-
-	getcounters(cache->stats, isc_statsformat_file,
-		    dns_cachestatscounter_max, indices, values);
-
-	fprintf(fp, "%20" PRIu64 " %s\n", values[dns_cachestatscounter_hits],
-		"cache hits");
-	fprintf(fp, "%20" PRIu64 " %s\n", values[dns_cachestatscounter_misses],
-		"cache misses");
-	fprintf(fp, "%20" PRIu64 " %s\n",
-		values[dns_cachestatscounter_queryhits],
-		"cache hits (from query)");
-	fprintf(fp, "%20" PRIu64 " %s\n",
-		values[dns_cachestatscounter_querymisses],
-		"cache misses (from query)");
-	fprintf(fp, "%20" PRIu64 " %s\n",
-		values[dns_cachestatscounter_deletelru],
-		"cache records deleted due to memory exhaustion");
-	fprintf(fp, "%20" PRIu64 " %s\n",
-		values[dns_cachestatscounter_deletettl],
-		"cache records deleted due to TTL expiration");
-	fprintf(fp, "%20" PRIu64 " %s\n",
-		values[dns_cachestatscounter_coveringnsec],
-		"covering nsec returned");
-	fprintf(fp, "%20u %s\n", dns_db_nodecount(cache->db, dns_dbtree_main),
-		"cache database nodes");
-	fprintf(fp, "%20u %s\n", dns_db_nodecount(cache->db, dns_dbtree_nsec),
-		"cache NSEC auxiliary database nodes");
-	fprintf(fp, "%20" PRIu64 " %s\n", (uint64_t)dns_db_hashsize(cache->db),
-		"cache database hash buckets");
-
-	fprintf(fp, "%20" PRIu64 " %s\n", (uint64_t)isc_mem_total(cache->tmctx),
-		"cache tree memory total");
-	fprintf(fp, "%20" PRIu64 " %s\n", (uint64_t)isc_mem_inuse(cache->tmctx),
-		"cache tree memory in use");
-	fprintf(fp, "%20" PRIu64 " %s\n",
-		(uint64_t)isc_mem_maxinuse(cache->tmctx),
-		"cache tree highest memory in use");
-
-	fprintf(fp, "%20" PRIu64 " %s\n", (uint64_t)isc_mem_total(cache->hmctx),
-		"cache heap memory total");
-	fprintf(fp, "%20" PRIu64 " %s\n", (uint64_t)isc_mem_inuse(cache->hmctx),
-		"cache heap memory in use");
-	fprintf(fp, "%20" PRIu64 " %s\n",
-		(uint64_t)isc_mem_maxinuse(cache->hmctx),
-		"cache heap highest memory in use");
-}
-
-#ifdef HAVE_LIBXML2
-#define TRY0(a)                     \
-	do {                        \
-		xmlrc = (a);        \
-		if (xmlrc < 0)      \
-			goto error; \
-	} while (0)
-static int
-renderstat(const char *name, uint64_t value, xmlTextWriterPtr writer) {
-	int xmlrc;
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "counter"));
-	TRY0(xmlTextWriterWriteAttribute(writer, ISC_XMLCHAR "name",
-					 ISC_XMLCHAR name));
-	TRY0(xmlTextWriterWriteFormatString(writer, "%" PRIu64 "", value));
-	TRY0(xmlTextWriterEndElement(writer)); /* counter */
-
-error:
-	return xmlrc;
-}
-
-int
-dns_cache_renderxml(dns_cache_t *cache, void *writer0) {
-	int indices[dns_cachestatscounter_max];
-	uint64_t values[dns_cachestatscounter_max];
-	int xmlrc;
-	xmlTextWriterPtr writer = (xmlTextWriterPtr)writer0;
-
-	REQUIRE(VALID_CACHE(cache));
-
-	getcounters(cache->stats, isc_statsformat_file,
-		    dns_cachestatscounter_max, indices, values);
-	TRY0(renderstat("CacheHits", values[dns_cachestatscounter_hits],
-			writer));
-	TRY0(renderstat("CacheMisses", values[dns_cachestatscounter_misses],
-			writer));
-	TRY0(renderstat("QueryHits", values[dns_cachestatscounter_queryhits],
-			writer));
-	TRY0(renderstat("QueryMisses",
-			values[dns_cachestatscounter_querymisses], writer));
-	TRY0(renderstat("DeleteLRU", values[dns_cachestatscounter_deletelru],
-			writer));
-	TRY0(renderstat("DeleteTTL", values[dns_cachestatscounter_deletettl],
-			writer));
-	TRY0(renderstat("CoveringNSEC",
-			values[dns_cachestatscounter_coveringnsec], writer));
-
-	TRY0(renderstat("CacheNodes",
-			dns_db_nodecount(cache->db, dns_dbtree_main), writer));
-	TRY0(renderstat("CacheNSECNodes",
-			dns_db_nodecount(cache->db, dns_dbtree_nsec), writer));
-	TRY0(renderstat("CacheBuckets", dns_db_hashsize(cache->db), writer));
-
-	TRY0(renderstat("TreeMemTotal", isc_mem_total(cache->tmctx), writer));
-	TRY0(renderstat("TreeMemInUse", isc_mem_inuse(cache->tmctx), writer));
-	TRY0(renderstat("TreeMemMax", isc_mem_maxinuse(cache->tmctx), writer));
-
-	TRY0(renderstat("HeapMemTotal", isc_mem_total(cache->hmctx), writer));
-	TRY0(renderstat("HeapMemInUse", isc_mem_inuse(cache->hmctx), writer));
-	TRY0(renderstat("HeapMemMax", isc_mem_maxinuse(cache->hmctx), writer));
-error:
-	return xmlrc;
-}
-#endif /* ifdef HAVE_LIBXML2 */
-
-#ifdef HAVE_JSON_C
-#define CHECKMEM(m)                              \
-	do {                                     \
-		if (m == NULL) {                 \
-			result = ISC_R_NOMEMORY; \
-			goto error;              \
-		}                                \
-	} while (0)
-
-isc_result_t
-dns_cache_renderjson(dns_cache_t *cache, void *cstats0) {
-	isc_result_t result = ISC_R_SUCCESS;
-	int indices[dns_cachestatscounter_max];
-	uint64_t values[dns_cachestatscounter_max];
-	json_object *obj;
-	json_object *cstats = (json_object *)cstats0;
-
-	REQUIRE(VALID_CACHE(cache));
-
-	getcounters(cache->stats, isc_statsformat_file,
-		    dns_cachestatscounter_max, indices, values);
-
-	obj = json_object_new_int64(values[dns_cachestatscounter_hits]);
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "CacheHits", obj);
-
-	obj = json_object_new_int64(values[dns_cachestatscounter_misses]);
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "CacheMisses", obj);
-
-	obj = json_object_new_int64(values[dns_cachestatscounter_queryhits]);
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "QueryHits", obj);
-
-	obj = json_object_new_int64(values[dns_cachestatscounter_querymisses]);
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "QueryMisses", obj);
-
-	obj = json_object_new_int64(values[dns_cachestatscounter_deletelru]);
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "DeleteLRU", obj);
-
-	obj = json_object_new_int64(values[dns_cachestatscounter_deletettl]);
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "DeleteTTL", obj);
-
-	obj = json_object_new_int64(values[dns_cachestatscounter_coveringnsec]);
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "CoveringNSEC", obj);
-
-	obj = json_object_new_int64(
-		dns_db_nodecount(cache->db, dns_dbtree_main));
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "CacheNodes", obj);
-
-	obj = json_object_new_int64(
-		dns_db_nodecount(cache->db, dns_dbtree_nsec));
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "CacheNSECNodes", obj);
-
-	obj = json_object_new_int64(dns_db_hashsize(cache->db));
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "CacheBuckets", obj);
-
-	obj = json_object_new_int64(isc_mem_total(cache->tmctx));
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "TreeMemTotal", obj);
-
-	obj = json_object_new_int64(isc_mem_inuse(cache->tmctx));
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "TreeMemInUse", obj);
-
-	obj = json_object_new_int64(isc_mem_maxinuse(cache->tmctx));
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "TreeMemMax", obj);
-
-	obj = json_object_new_int64(isc_mem_total(cache->hmctx));
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "HeapMemTotal", obj);
-
-	obj = json_object_new_int64(isc_mem_inuse(cache->hmctx));
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "HeapMemInUse", obj);
-
-	obj = json_object_new_int64(isc_mem_maxinuse(cache->hmctx));
-	CHECKMEM(obj);
-	json_object_object_add(cstats, "HeapMemMax", obj);
-
-	result = ISC_R_SUCCESS;
-error:
-	return result;
-}
-#endif /* ifdef HAVE_JSON_C */
diff --git a/lib/dns/callbacks.c b/lib/dns/callbacks.c
--- a/lib/dns/callbacks.c
+++ b/lib/dns/callbacks.c
@@ -81,8 +81,6 @@ dns_rdatacallbacks_initcommon(dns_rdatacallbacks_t *callbacks) {
 
 	callbacks->magic = DNS_CALLBACK_MAGIC;
 	callbacks->add = NULL;
-	callbacks->rawdata = NULL;
-	callbacks->zone = NULL;
 	callbacks->add_private = NULL;
 	callbacks->error_private = NULL;
 	callbacks->warn_private = NULL;
diff --git a/lib/dns/db.c b/lib/dns/db.c
--- a/lib/dns/db.c
+++ b/lib/dns/db.c
@@ -900,45 +900,6 @@ dns_db_getoriginnode(dns_db_t *db, dns_dbnode_t **nodep) {
 	return ISC_R_NOTFOUND;
 }
 
-dns_stats_t *
-dns_db_getrrsetstats(dns_db_t *db) {
-	REQUIRE(DNS_DB_VALID(db));
-
-	if (db->methods->getrrsetstats != NULL) {
-		return (db->methods->getrrsetstats)(db);
-	}
-
-	return NULL;
-}
-
-isc_result_t
-dns_db_setcachestats(dns_db_t *db, isc_stats_t *stats) {
-	REQUIRE(DNS_DB_VALID(db));
-
-	if (db->methods->setcachestats != NULL) {
-		return (db->methods->setcachestats)(db, stats);
-	}
-
-	return ISC_R_NOTIMPLEMENTED;
-}
-
-isc_result_t
-dns_db_getnsec3parameters(dns_db_t *db, dns_dbversion_t *version,
-			  dns_hash_t *hash, uint8_t *flags,
-			  uint16_t *iterations, unsigned char *salt,
-			  size_t *salt_length) {
-	REQUIRE(DNS_DB_VALID(db));
-	REQUIRE(dns_db_iszone(db));
-
-	if (db->methods->getnsec3parameters != NULL) {
-		return (db->methods->getnsec3parameters)(db, version, hash,
-							 flags, iterations,
-							 salt, salt_length);
-	}
-
-	return ISC_R_NOTFOUND;
-}
-
 isc_result_t
 dns_db_getsize(dns_db_t *db, dns_dbversion_t *version, uint64_t *records,
 	       uint64_t *bytes) {
@@ -1111,18 +1072,6 @@ dns_db_getservestalerefresh(dns_db_t *db, uint32_t *interval) {
 	return ISC_R_NOTIMPLEMENTED;
 }
 
-isc_result_t
-dns_db_setgluecachestats(dns_db_t *db, isc_stats_t *stats) {
-	REQUIRE(dns_db_iszone(db));
-	REQUIRE(stats != NULL);
-
-	if (db->methods->setgluecachestats != NULL) {
-		return (db->methods->setgluecachestats)(db, stats);
-	}
-
-	return ISC_R_NOTIMPLEMENTED;
-}
-
 void
 dns_db_setmaxrrperset(dns_db_t *db, uint32_t value) {
 	REQUIRE(DNS_DB_VALID(db));
diff --git a/lib/dns/dispatch.c b/lib/dns/dispatch.c
--- a/lib/dns/dispatch.c
+++ b/lib/dns/dispatch.c
@@ -27,7 +27,7 @@
 #include <isc/portset.h>
 #include <isc/print.h>
 #include <isc/random.h>
-#include <isc/stats.h>
+#include <isc/sockaddr.h>
 #include <isc/string.h>
 #include <isc/time.h>
 #include <isc/util.h>
@@ -36,7 +36,6 @@
 #include <dns/dispatch.h>
 #include <dns/log.h>
 #include <dns/message.h>
-#include <dns/stats.h>
 #include <dns/types.h>
 
 typedef ISC_LIST(dns_dispentry_t) dns_displist_t;
@@ -55,7 +54,6 @@ struct dns_dispatchmgr {
 	isc_refcount_t references;
 	isc_mem_t *mctx;
 	dns_acl_t *blackhole;
-	isc_stats_t *stats;
 	isc_nm_t *nm;
 
 	/* Locked by "lock". */
@@ -270,20 +268,6 @@ mgr_log(dns_dispatchmgr_t *mgr, int level, const char *fmt, ...) {
 		      msgbuf);
 }
 
-static void
-inc_stats(dns_dispatchmgr_t *mgr, isc_statscounter_t counter) {
-	if (mgr->stats != NULL) {
-		isc_stats_increment(mgr->stats, counter);
-	}
-}
-
-static void
-dec_stats(dns_dispatchmgr_t *mgr, isc_statscounter_t counter) {
-	if (mgr->stats != NULL) {
-		isc_stats_decrement(mgr->stats, counter);
-	}
-}
-
 static void
 dispatch_log(dns_dispatch_t *disp, int level, const char *fmt, ...)
 	ISC_FORMAT_PRINTF(3, 4);
@@ -596,7 +580,6 @@ udp_recv(isc_nmhandle_t *handle, isc_result_t eresult, isc_region_t *region,
 	 */
 	if (resp->id != id || !isc_sockaddr_equal(&peer, &resp->peer)) {
 		dispentry_log(resp, LVL(90), "response doesn't match");
-		inc_stats(disp->mgr, dns_resstatscounter_mismatch);
 		goto next;
 	}
 
@@ -1055,10 +1038,6 @@ dispatchmgr_destroy(dns_dispatchmgr_t *mgr) {
 		dns_acl_detach(&mgr->blackhole);
 	}
 
-	if (mgr->stats != NULL) {
-		isc_stats_detach(&mgr->stats);
-	}
-
 	if (mgr->v4ports != NULL) {
 		isc_mem_put(mgr->mctx, mgr->v4ports,
 			    mgr->nv4ports * sizeof(in_port_t));
@@ -1073,15 +1052,6 @@ dispatchmgr_destroy(dns_dispatchmgr_t *mgr) {
 	isc_mem_putanddetach(&mgr->mctx, mgr, sizeof(dns_dispatchmgr_t));
 }
 
-void
-dns_dispatchmgr_setstats(dns_dispatchmgr_t *mgr, isc_stats_t *stats) {
-	REQUIRE(VALID_DISPATCHMGR(mgr));
-	REQUIRE(ISC_LIST_EMPTY(mgr->list));
-	REQUIRE(mgr->stats == NULL);
-
-	isc_stats_attach(stats, &mgr->stats);
-}
-
 static void
 qid_allocate(dns_dispatchmgr_t *mgr, dns_qid_t **qidp) {
 	dns_qid_t *qid = NULL;
@@ -1484,7 +1454,6 @@ dns_dispatch_add(dns_dispatch_t *disp, unsigned int options,
 		if (result != ISC_R_SUCCESS) {
 			isc_mem_put(disp->mgr->mctx, resp, sizeof(*resp));
 			UNLOCK(&disp->lock);
-			inc_stats(disp->mgr, dns_resstatscounter_dispsockfail);
 			return result;
 		}
 	}
@@ -1534,10 +1503,6 @@ dns_dispatch_add(dns_dispatch_t *disp, unsigned int options,
 
 	disp->requests++;
 
-	inc_stats(disp->mgr, (disp->socktype == isc_socktype_udp)
-				     ? dns_resstatscounter_disprequdp
-				     : dns_resstatscounter_dispreqtcp);
-
 	UNLOCK(&disp->lock);
 
 	*idp = id;
@@ -1631,8 +1596,6 @@ udp_dispentry_cancel(dns_dispentry_t *resp, isc_result_t result) {
 		UNREACHABLE();
 	}
 
-	dec_stats(disp->mgr, dns_resstatscounter_disprequdp);
-
 	LOCK(&qid->lock);
 	ISC_LIST_UNLINK(qid->qid_table[resp->bucket], resp, link);
 	UNLOCK(&qid->lock);
@@ -1731,8 +1694,6 @@ tcp_dispentry_cancel(dns_dispentry_t *resp, isc_result_t result) {
 		UNREACHABLE();
 	}
 
-	dec_stats(disp->mgr, dns_resstatscounter_dispreqtcp);
-
 	LOCK(&qid->lock);
 	ISC_LIST_UNLINK(qid->qid_table[resp->bucket], resp, link);
 	UNLOCK(&qid->lock);
diff --git a/lib/dns/dns64.c b/lib/dns/dns64.c
--- a/lib/dns/dns64.c
+++ b/lib/dns/dns64.c
@@ -21,309 +21,10 @@
 #include <isc/string.h>
 #include <isc/util.h>
 
-#include <dns/acl.h>
 #include <dns/dns64.h>
 #include <dns/rdata.h>
 #include <dns/rdataset.h>
 
-struct dns_dns64 {
-	unsigned char bits[16]; /*
-				 * Prefix + suffix bits.
-				 */
-	dns_acl_t *clients;	/*
-				 * Which clients get mapped
-				 * addresses.
-				 */
-	dns_acl_t *mapped;	/*
-				 * IPv4 addresses to be mapped.
-				 */
-	dns_acl_t *excluded;	/*
-				 * IPv6 addresses that are
-				 * treated as not existing.
-				 */
-	unsigned int prefixlen; /*
-				 * Start of mapped address.
-				 */
-	unsigned int flags;
-	isc_mem_t *mctx;
-	ISC_LINK(dns_dns64_t) link;
-};
-
-isc_result_t
-dns_dns64_create(isc_mem_t *mctx, const isc_netaddr_t *prefix,
-		 unsigned int prefixlen, const isc_netaddr_t *suffix,
-		 dns_acl_t *clients, dns_acl_t *mapped, dns_acl_t *excluded,
-		 unsigned int flags, dns_dns64_t **dns64p) {
-	dns_dns64_t *dns64;
-	unsigned int nbytes = 16;
-
-	REQUIRE(prefix != NULL && prefix->family == AF_INET6);
-	/* Legal prefix lengths from rfc6052.txt. */
-	REQUIRE(prefixlen == 32 || prefixlen == 40 || prefixlen == 48 ||
-		prefixlen == 56 || prefixlen == 64 || prefixlen == 96);
-	REQUIRE(isc_netaddr_prefixok(prefix, prefixlen) == ISC_R_SUCCESS);
-	REQUIRE(dns64p != NULL && *dns64p == NULL);
-
-	if (suffix != NULL) {
-		static const unsigned char zeros[16];
-		REQUIRE(prefix->family == AF_INET6);
-		nbytes = prefixlen / 8 + 4;
-		/* Bits 64-71 are zeros. rfc6052.txt */
-		if (prefixlen >= 32 && prefixlen <= 64) {
-			nbytes++;
-		}
-		REQUIRE(memcmp(suffix->type.in6.s6_addr, zeros, nbytes) == 0);
-	}
-
-	dns64 = isc_mem_get(mctx, sizeof(dns_dns64_t));
-	memset(dns64->bits, 0, sizeof(dns64->bits));
-	memmove(dns64->bits, prefix->type.in6.s6_addr, prefixlen / 8);
-	if (suffix != NULL) {
-		memmove(dns64->bits + nbytes, suffix->type.in6.s6_addr + nbytes,
-			16 - nbytes);
-	}
-	dns64->clients = NULL;
-	if (clients != NULL) {
-		dns_acl_attach(clients, &dns64->clients);
-	}
-	dns64->mapped = NULL;
-	if (mapped != NULL) {
-		dns_acl_attach(mapped, &dns64->mapped);
-	}
-	dns64->excluded = NULL;
-	if (excluded != NULL) {
-		dns_acl_attach(excluded, &dns64->excluded);
-	}
-	dns64->prefixlen = prefixlen;
-	dns64->flags = flags;
-	ISC_LINK_INIT(dns64, link);
-	dns64->mctx = NULL;
-	isc_mem_attach(mctx, &dns64->mctx);
-	*dns64p = dns64;
-	return ISC_R_SUCCESS;
-}
-
-void
-dns_dns64_destroy(dns_dns64_t **dns64p) {
-	dns_dns64_t *dns64;
-
-	REQUIRE(dns64p != NULL && *dns64p != NULL);
-
-	dns64 = *dns64p;
-	*dns64p = NULL;
-
-	REQUIRE(!ISC_LINK_LINKED(dns64, link));
-
-	if (dns64->clients != NULL) {
-		dns_acl_detach(&dns64->clients);
-	}
-	if (dns64->mapped != NULL) {
-		dns_acl_detach(&dns64->mapped);
-	}
-	if (dns64->excluded != NULL) {
-		dns_acl_detach(&dns64->excluded);
-	}
-	isc_mem_putanddetach(&dns64->mctx, dns64, sizeof(*dns64));
-}
-
-isc_result_t
-dns_dns64_aaaafroma(const dns_dns64_t *dns64, const isc_netaddr_t *reqaddr,
-		    const dns_name_t *reqsigner, dns_aclenv_t *env,
-		    unsigned int flags, unsigned char *a, unsigned char *aaaa) {
-	unsigned int nbytes, i;
-	isc_result_t result;
-	int match;
-
-	if ((dns64->flags & DNS_DNS64_RECURSIVE_ONLY) != 0 &&
-	    (flags & DNS_DNS64_RECURSIVE) == 0)
-	{
-		return DNS_R_DISALLOWED;
-	}
-
-	if ((dns64->flags & DNS_DNS64_BREAK_DNSSEC) == 0 &&
-	    (flags & DNS_DNS64_DNSSEC) != 0)
-	{
-		return DNS_R_DISALLOWED;
-	}
-
-	if (dns64->clients != NULL) {
-		result = dns_acl_match(reqaddr, reqsigner, dns64->clients, env,
-				       &match, NULL);
-		if (result != ISC_R_SUCCESS) {
-			return result;
-		}
-		if (match <= 0) {
-			return DNS_R_DISALLOWED;
-		}
-	}
-
-	if (dns64->mapped != NULL) {
-		struct in_addr ina;
-		isc_netaddr_t netaddr;
-
-		memmove(&ina.s_addr, a, 4);
-		isc_netaddr_fromin(&netaddr, &ina);
-		result = dns_acl_match(&netaddr, NULL, dns64->mapped, env,
-				       &match, NULL);
-		if (result != ISC_R_SUCCESS) {
-			return result;
-		}
-		if (match <= 0) {
-			return DNS_R_DISALLOWED;
-		}
-	}
-
-	nbytes = dns64->prefixlen / 8;
-	INSIST(nbytes <= 12);
-	/* Copy prefix. */
-	memmove(aaaa, dns64->bits, nbytes);
-	/* Bits 64-71 are zeros. rfc6052.txt */
-	if (nbytes == 8) {
-		aaaa[nbytes++] = 0;
-	}
-	/* Copy mapped address. */
-	for (i = 0; i < 4U; i++) {
-		aaaa[nbytes++] = a[i];
-		/* Bits 64-71 are zeros. rfc6052.txt */
-		if (nbytes == 8) {
-			aaaa[nbytes++] = 0;
-		}
-	}
-	/* Copy suffix. */
-	memmove(aaaa + nbytes, dns64->bits + nbytes, 16 - nbytes);
-	return ISC_R_SUCCESS;
-}
-
-dns_dns64_t *
-dns_dns64_next(dns_dns64_t *dns64) {
-	dns64 = ISC_LIST_NEXT(dns64, link);
-	return dns64;
-}
-
-void
-dns_dns64_append(dns_dns64list_t *list, dns_dns64_t *dns64) {
-	ISC_LIST_APPEND(*list, dns64, link);
-}
-
-void
-dns_dns64_unlink(dns_dns64list_t *list, dns_dns64_t *dns64) {
-	ISC_LIST_UNLINK(*list, dns64, link);
-}
-
-bool
-dns_dns64_aaaaok(const dns_dns64_t *dns64, const isc_netaddr_t *reqaddr,
-		 const dns_name_t *reqsigner, dns_aclenv_t *env,
-		 unsigned int flags, dns_rdataset_t *rdataset, bool *aaaaok,
-		 size_t aaaaoklen) {
-	struct in6_addr in6;
-	isc_netaddr_t netaddr;
-	isc_result_t result;
-	int match;
-	bool answer = false;
-	bool found = false;
-	unsigned int i, ok;
-
-	REQUIRE(rdataset != NULL);
-	REQUIRE(rdataset->type == dns_rdatatype_aaaa);
-	REQUIRE(rdataset->rdclass == dns_rdataclass_in);
-	if (aaaaok != NULL) {
-		REQUIRE(aaaaoklen == dns_rdataset_count(rdataset));
-	}
-
-	for (; dns64 != NULL; dns64 = ISC_LIST_NEXT(dns64, link)) {
-		if ((dns64->flags & DNS_DNS64_RECURSIVE_ONLY) != 0 &&
-		    (flags & DNS_DNS64_RECURSIVE) == 0)
-		{
-			continue;
-		}
-
-		if ((dns64->flags & DNS_DNS64_BREAK_DNSSEC) == 0 &&
-		    (flags & DNS_DNS64_DNSSEC) != 0)
-		{
-			continue;
-		}
-		/*
-		 * Work out if this dns64 structure applies to this client.
-		 */
-		if (dns64->clients != NULL) {
-			result = dns_acl_match(reqaddr, reqsigner,
-					       dns64->clients, env, &match,
-					       NULL);
-			if (result != ISC_R_SUCCESS) {
-				continue;
-			}
-			if (match <= 0) {
-				continue;
-			}
-		}
-
-		if (!found && aaaaok != NULL) {
-			for (i = 0; i < aaaaoklen; i++) {
-				aaaaok[i] = false;
-			}
-		}
-		found = true;
-
-		/*
-		 * If we are not excluding any addresses then any AAAA
-		 * will do.
-		 */
-		if (dns64->excluded == NULL) {
-			answer = true;
-			if (aaaaok == NULL) {
-				goto done;
-			}
-			for (i = 0; i < aaaaoklen; i++) {
-				aaaaok[i] = true;
-			}
-			goto done;
-		}
-
-		i = 0;
-		ok = 0;
-		for (result = dns_rdataset_first(rdataset);
-		     result == ISC_R_SUCCESS;
-		     result = dns_rdataset_next(rdataset))
-		{
-			dns_rdata_t rdata = DNS_RDATA_INIT;
-			if (aaaaok == NULL || !aaaaok[i]) {
-				dns_rdataset_current(rdataset, &rdata);
-				memmove(&in6.s6_addr, rdata.data, 16);
-				isc_netaddr_fromin6(&netaddr, &in6);
-
-				result = dns_acl_match(&netaddr, NULL,
-						       dns64->excluded, env,
-						       &match, NULL);
-				if (result == ISC_R_SUCCESS && match <= 0) {
-					answer = true;
-					if (aaaaok == NULL) {
-						goto done;
-					}
-					aaaaok[i] = true;
-					ok++;
-				}
-			} else {
-				ok++;
-			}
-			i++;
-		}
-		/*
-		 * Are all addresses ok?
-		 */
-		if (aaaaok != NULL && ok == aaaaoklen) {
-			goto done;
-		}
-	}
-
-done:
-	if (!found && aaaaok != NULL) {
-		for (i = 0; i < aaaaoklen; i++) {
-			aaaaok[i] = true;
-		}
-	}
-	return found ? answer : true;
-}
-
 /*
  * Posible mapping of IPV4ONLY.ARPA A records into AAAA records
  * for valid RFC6052 prefixes.
diff --git a/lib/dns/dnssec.c b/lib/dns/dnssec.c
--- a/lib/dns/dnssec.c
+++ b/lib/dns/dnssec.c
@@ -31,7 +31,6 @@
 #include <dns/diff.h>
 #include <dns/dnssec.h>
 #include <dns/fixedname.h>
-#include <dns/kasp.h>
 #include <dns/keyvalues.h>
 #include <dns/log.h>
 #include <dns/message.h>
@@ -39,11 +38,8 @@
 #include <dns/rdatalist.h>
 #include <dns/rdataset.h>
 #include <dns/rdatastruct.h>
-#include <dns/stats.h>
 #include <dns/tsig.h> /* for DNS_TSIG_FUDGE */
 
-isc_stats_t *dns_dnssec_stats;
-
 #define is_response(msg) ((msg->flags & DNS_MESSAGEFLAG_QR) != 0)
 
 #define RETERR(x)                            \
@@ -73,13 +69,6 @@ digest_callback(void *arg, isc_region_t *data) {
 	return dst_context_adddata(ctx, data);
 }
 
-static void
-inc_stat(isc_statscounter_t counter) {
-	if (dns_dnssec_stats != NULL) {
-		isc_stats_increment(dns_dnssec_stats, counter);
-	}
-}
-
 /*
  * Make qsort happy.
  */
@@ -391,7 +380,6 @@ dns_dnssec_verify(const dns_name_t *name, dns_rdataset_t *set, dst_key_t *key,
 	}
 
 	if (isc_serial_lt(sig.timeexpire, sig.timesigned)) {
-		inc_stat(dns_dnssecstats_fail);
 		return DNS_R_SIGINVALID;
 	}
 
@@ -402,10 +390,8 @@ dns_dnssec_verify(const dns_name_t *name, dns_rdataset_t *set, dst_key_t *key,
 		 * Is SIG temporally valid?
 		 */
 		if (isc_serial_lt((uint32_t)now, sig.timesigned)) {
-			inc_stat(dns_dnssecstats_fail);
 			return DNS_R_SIGFUTURE;
 		} else if (isc_serial_lt(sig.timeexpire, (uint32_t)now)) {
-			inc_stat(dns_dnssecstats_fail);
 			return DNS_R_SIGEXPIRED;
 		}
 	}
@@ -419,19 +405,16 @@ dns_dnssec_verify(const dns_name_t *name, dns_rdataset_t *set, dst_key_t *key,
 	case dns_rdatatype_soa:
 	case dns_rdatatype_dnskey:
 		if (!dns_name_equal(name, &sig.signer)) {
-			inc_stat(dns_dnssecstats_fail);
 			return DNS_R_SIGINVALID;
 		}
 		break;
 	case dns_rdatatype_ds:
 		if (dns_name_equal(name, &sig.signer)) {
-			inc_stat(dns_dnssecstats_fail);
 			return DNS_R_SIGINVALID;
 		}
 		FALLTHROUGH;
 	default:
 		if (!dns_name_issubdomain(name, &sig.signer)) {
-			inc_stat(dns_dnssecstats_fail);
 			return DNS_R_SIGINVALID;
 		}
 		break;
@@ -542,9 +525,6 @@ again:
 			      "successfully validated after lower casing "
 			      "signer '%s'",
 			      namebuf);
-		inc_stat(dns_dnssecstats_downcase);
-	} else if (ret == ISC_R_SUCCESS) {
-		inc_stat(dns_dnssecstats_asis);
 	}
 
 cleanup_array:
@@ -562,10 +542,6 @@ cleanup_struct:
 		ret = DNS_R_SIGINVALID;
 	}
 
-	if (ret != ISC_R_SUCCESS) {
-		inc_stat(dns_dnssecstats_fail);
-	}
-
 	if (ret == ISC_R_SUCCESS && labels - sig.labels > 0) {
 		if (wild != NULL) {
 			RUNTIME_CHECK(dns_name_concatenate(
@@ -573,7 +549,6 @@ cleanup_struct:
 					      dns_fixedname_name(&fnewname),
 					      wild, NULL) == ISC_R_SUCCESS);
 		}
-		inc_stat(dns_dnssecstats_wildcard);
 		ret = DNS_R_FROMWILDCARD;
 	}
 	return ret;
diff --git a/lib/dns/dst_api.c b/lib/dns/dst_api.c
--- a/lib/dns/dst_api.c
+++ b/lib/dns/dst_api.c
@@ -142,9 +142,6 @@ static dst_func_t *dst_t_func[DST_MAX_ALGS];
 
 static bool dst_initialized = false;
 
-void
-gss_log(int level, const char *fmt, ...) ISC_FORMAT_PRINTF(2, 3);
-
 /*
  * Static functions.
  */
@@ -153,10 +150,6 @@ get_key_struct(const dns_name_t *name, unsigned int alg, unsigned int flags,
 	       unsigned int protocol, unsigned int bits,
 	       dns_rdataclass_t rdclass, dns_ttl_t ttl, isc_mem_t *mctx);
 static isc_result_t
-write_public_key(const dst_key_t *key, int type, const char *directory);
-static isc_result_t
-write_key_state(const dst_key_t *key, int type, const char *directory);
-static isc_result_t
 buildfilename(dns_name_t *name, dns_keytag_t id, unsigned int alg,
 	      unsigned int type, const char *directory, isc_buffer_t *out);
 static isc_result_t
@@ -224,10 +217,6 @@ dst_lib_init(isc_mem_t *mctx, const char *engine) {
 	RETERR(dst__openssleddsa_init(&dst_t_func[DST_ALG_ED448]));
 #endif /* ifdef HAVE_OPENSSL_ED448 */
 
-#if HAVE_GSSAPI
-	RETERR(dst__gssapi_init(&dst_t_func[DST_ALG_GSSAPI]));
-#endif /* HAVE_GSSAPI */
-
 	dst_initialized = true;
 	return ISC_R_SUCCESS;
 
@@ -426,43 +415,6 @@ dst_key_computesecret(const dst_key_t *pub, const dst_key_t *priv,
 	return pub->func->computesecret(pub, priv, secret);
 }
 
-isc_result_t
-dst_key_tofile(const dst_key_t *key, int type, const char *directory) {
-	isc_result_t ret = ISC_R_SUCCESS;
-
-	REQUIRE(dst_initialized);
-	REQUIRE(VALID_KEY(key));
-	REQUIRE((type &
-		 (DST_TYPE_PRIVATE | DST_TYPE_PUBLIC | DST_TYPE_STATE)) != 0);
-
-	CHECKALG(key->key_alg);
-
-	if (key->func->tofile == NULL) {
-		return DST_R_UNSUPPORTEDALG;
-	}
-
-	if ((type & DST_TYPE_PUBLIC) != 0) {
-		ret = write_public_key(key, type, directory);
-		if (ret != ISC_R_SUCCESS) {
-			return ret;
-		}
-	}
-
-	if ((type & DST_TYPE_STATE) != 0) {
-		ret = write_key_state(key, type, directory);
-		if (ret != ISC_R_SUCCESS) {
-			return ret;
-		}
-	}
-
-	if (((type & DST_TYPE_PRIVATE) != 0) &&
-	    (key->key_flags & DNS_KEYFLAG_TYPEMASK) != DNS_KEYTYPE_NOKEY)
-	{
-		return key->func->tofile(key, directory);
-	}
-	return ISC_R_SUCCESS;
-}
-
 void
 dst_key_setexternal(dst_key_t *key, bool value) {
 	REQUIRE(VALID_KEY(key));
@@ -866,108 +818,6 @@ out:
 	return result;
 }
 
-dns_gss_ctx_id_t
-dst_key_getgssctx(const dst_key_t *key) {
-	REQUIRE(key != NULL);
-
-	return key->keydata.gssctx;
-}
-
-isc_result_t
-dst_key_fromgssapi(const dns_name_t *name, dns_gss_ctx_id_t gssctx,
-		   isc_mem_t *mctx, dst_key_t **keyp, isc_region_t *intoken) {
-	dst_key_t *key;
-	isc_result_t result;
-
-	REQUIRE(gssctx != NULL);
-	REQUIRE(keyp != NULL && *keyp == NULL);
-
-	key = get_key_struct(name, DST_ALG_GSSAPI, 0, DNS_KEYPROTO_DNSSEC, 0,
-			     dns_rdataclass_in, 0, mctx);
-	if (key == NULL) {
-		return ISC_R_NOMEMORY;
-	}
-
-	if (intoken != NULL) {
-		/*
-		 * Keep the token for use by external ssu rules. They may need
-		 * to examine the PAC in the kerberos ticket.
-		 */
-		isc_buffer_allocate(key->mctx, &key->key_tkeytoken,
-				    intoken->length);
-		RETERR(isc_buffer_copyregion(key->key_tkeytoken, intoken));
-	}
-
-	key->keydata.gssctx = gssctx;
-	*keyp = key;
-	result = ISC_R_SUCCESS;
-out:
-	if (result != ISC_R_SUCCESS) {
-		dst_key_free(&key);
-	}
-	return result;
-}
-
-FILE *
-dst_key_open(char *tmpname, mode_t mode) {
-	/* Create public key file. */
-	int fd = mkstemp(tmpname);
-	if (fd == -1) {
-		return NULL;
-	}
-
-	if (fchmod(fd, mode & ~isc_os_umask()) != 0) {
-		goto error;
-	}
-
-	FILE *fp = fdopen(fd, "w");
-	if (fp == NULL) {
-		goto error;
-	}
-
-	return fp;
-error:
-	(void)close(fd);
-	(void)unlink(tmpname);
-	return NULL;
-}
-
-isc_result_t
-dst_key_close(char *tmpname, FILE *fp, char *filename) {
-	if ((fflush(fp) != 0) || (ferror(fp) != 0)) {
-		return dst_key_cleanup(tmpname, fp);
-	}
-
-	if (rename(tmpname, filename) != 0) {
-		return dst_key_cleanup(tmpname, fp);
-	}
-
-	if (fclose(fp) != 0) {
-		/*
-		 * This is in fact error, but we don't care at this point,
-		 * as the file has been already flushed to disk.
-		 */
-	}
-
-	return ISC_R_SUCCESS;
-}
-
-isc_result_t
-dst_key_cleanup(char *tmpname, FILE *fp) {
-	if (ftruncate(fileno(fp), 0) != 0) {
-		/*
-		 * ftruncate() result can't be ignored, but we don't care, as
-		 * any sensitive data are protected by the permissions, and
-		 * unlinked in the next step, this is just a good practice.
-		 */
-	}
-
-	(void)unlink(tmpname);
-	(void)fclose(fp);
-
-	return DST_R_WRITEERROR;
-}
-
 isc_result_t
 dst_key_buildinternal(const dns_name_t *name, unsigned int alg,
 		      unsigned int bits, unsigned int flags,
@@ -1494,9 +1344,6 @@ dst_key_sigsize(const dst_key_t *key, unsigned int *n) {
 	case DST_ALG_HMACSHA512:
 		*n = isc_md_type_get_size(ISC_MD_SHA512);
 		break;
-	case DST_ALG_GSSAPI:
-		*n = 128; /*%< XXX */
-		break;
 	case DST_ALG_DH:
 	default:
 		return DST_R_UNSUPPORTEDALG;
@@ -1981,321 +1828,6 @@ cleanup:
 	return ret;
 }
 
-static bool
-issymmetric(const dst_key_t *key) {
-	REQUIRE(dst_initialized);
-	REQUIRE(VALID_KEY(key));
-
-	/* XXXVIX this switch statement is too sparse to gen a jump table. */
-	switch (key->key_alg) {
-	case DST_ALG_RSASHA1:
-	case DST_ALG_NSEC3RSASHA1:
-	case DST_ALG_RSASHA256:
-	case DST_ALG_RSASHA512:
-	case DST_ALG_DH:
-	case DST_ALG_ECDSA256:
-	case DST_ALG_ECDSA384:
-	case DST_ALG_ED25519:
-	case DST_ALG_ED448:
-		return false;
-	case DST_ALG_HMACMD5:
-	case DST_ALG_HMACSHA1:
-	case DST_ALG_HMACSHA224:
-	case DST_ALG_HMACSHA256:
-	case DST_ALG_HMACSHA384:
-	case DST_ALG_HMACSHA512:
-	case DST_ALG_GSSAPI:
-		return true;
-	default:
-		return false;
-	}
-}
-
-/*%
- * Write key boolean metadata to a file pointer, preceded by 'tag'
- */
-static void
-printbool(const dst_key_t *key, int type, const char *tag, FILE *stream) {
-	isc_result_t result;
-	bool value = 0;
-
-	result = dst_key_getbool(key, type, &value);
-	if (result != ISC_R_SUCCESS) {
-		return;
-	}
-	fprintf(stream, "%s: %s\n", tag, value ? "yes" : "no");
-}
-
-/*%
- * Write key numeric metadata to a file pointer, preceded by 'tag'
- */
-static void
-printnum(const dst_key_t *key, int type, const char *tag, FILE *stream) {
-	isc_result_t result;
-	uint32_t value = 0;
-
-	result = dst_key_getnum(key, type, &value);
-	if (result != ISC_R_SUCCESS) {
-		return;
-	}
-	fprintf(stream, "%s: %u\n", tag, value);
-}
-
-/*%
- * Write key timing metadata to a file pointer, preceded by 'tag'
- */
-static void
-printtime(const dst_key_t *key, int type, const char *tag, FILE *stream) {
-	isc_result_t result;
-	char output[26]; /* Minimum buffer as per ctime_r() specification. */
-	isc_stdtime_t when;
-	char utc[sizeof("YYYYMMDDHHSSMM")];
-	isc_buffer_t b;
-	isc_region_t r;
-
-	result = dst_key_gettime(key, type, &when);
-	if (result == ISC_R_NOTFOUND) {
-		return;
-	}
-
-	isc_stdtime_tostring(when, output, sizeof(output));
-	isc_buffer_init(&b, utc, sizeof(utc));
-	result = dns_time32_totext(when, &b);
-	if (result != ISC_R_SUCCESS) {
-		goto error;
-	}
-
-	isc_buffer_usedregion(&b, &r);
-	fprintf(stream, "%s: %.*s (%s)\n", tag, (int)r.length, r.base, output);
-	return;
-
-error:
-	fprintf(stream, "%s: (set, unable to display)\n", tag);
-}
-
-/*%
- * Write key state metadata to a file pointer, preceded by 'tag'
- */
-static void
-printstate(const dst_key_t *key, int type, const char *tag, FILE *stream) {
-	isc_result_t result;
-	dst_key_state_t value = 0;
-
-	result = dst_key_getstate(key, type, &value);
-	if (result != ISC_R_SUCCESS) {
-		return;
-	}
-	fprintf(stream, "%s: %s\n", tag, keystates[value]);
-}
-
-/*%
- * Writes a key state to disk.
- */
-static isc_result_t
-write_key_state(const dst_key_t *key, int type, const char *directory) {
-	FILE *fp;
-	isc_buffer_t fileb;
-	isc_buffer_t tmpb;
-	char filename[NAME_MAX];
-	char tmpname[NAME_MAX];
-	isc_result_t result;
-
-	REQUIRE(VALID_KEY(key));
-
-	/*
-	 * Make the filename.
-	 */
-	isc_buffer_init(&fileb, filename, sizeof(filename));
-	result = dst_key_buildfilename(key, DST_TYPE_STATE, directory, &fileb);
-	if (result != ISC_R_SUCCESS) {
-		return result;
-	}
-
-	isc_buffer_init(&tmpb, tmpname, sizeof(tmpname));
-	result = dst_key_buildfilename(key, DST_TYPE_TEMPLATE, directory,
-				       &tmpb);
-	if (result != ISC_R_SUCCESS) {
-		return result;
-	}
-
-	mode_t mode = issymmetric(key) ? S_IRUSR | S_IWUSR
-				       : S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
-
-	/* Create temporary public key file. */
-	fp = dst_key_open(tmpname, mode);
-	if (fp == NULL) {
-		return DST_R_WRITEERROR;
-	}
-
-	/* Write key state */
-	if ((type & DST_TYPE_KEY) == 0) {
-		fprintf(fp, "; This is the state of key %d, for ", key->key_id);
-		result = dns_name_print(key->key_name, fp);
-		if (result != ISC_R_SUCCESS) {
-			return dst_key_cleanup(tmpname, fp);
-		}
-		fputc('\n', fp);
-
-		fprintf(fp, "Algorithm: %u\n", key->key_alg);
-		fprintf(fp, "Length: %u\n", key->key_size);
-
-		printnum(key, DST_NUM_LIFETIME, "Lifetime", fp);
-		printnum(key, DST_NUM_PREDECESSOR, "Predecessor", fp);
-		printnum(key, DST_NUM_SUCCESSOR, "Successor", fp);
-
-		printbool(key, DST_BOOL_KSK, "KSK", fp);
-		printbool(key, DST_BOOL_ZSK, "ZSK", fp);
-
-		printtime(key, DST_TIME_CREATED, "Generated", fp);
-		printtime(key, DST_TIME_PUBLISH, "Published", fp);
-		printtime(key, DST_TIME_ACTIVATE, "Active", fp);
-		printtime(key, DST_TIME_INACTIVE, "Retired", fp);
-		printtime(key, DST_TIME_REVOKE, "Revoked", fp);
-		printtime(key, DST_TIME_DELETE, "Removed", fp);
-		printtime(key, DST_TIME_DSPUBLISH, "DSPublish", fp);
-		printtime(key, DST_TIME_DSDELETE, "DSRemoved", fp);
-		printtime(key, DST_TIME_SYNCPUBLISH, "PublishCDS", fp);
-		printtime(key, DST_TIME_SYNCDELETE, "DeleteCDS", fp);
-
-		printnum(key, DST_NUM_DSPUBCOUNT, "DSPubCount", fp);
-		printnum(key, DST_NUM_DSDELCOUNT, "DSDelCount", fp);
-
-		printtime(key, DST_TIME_DNSKEY, "DNSKEYChange", fp);
-		printtime(key, DST_TIME_ZRRSIG, "ZRRSIGChange", fp);
-		printtime(key, DST_TIME_KRRSIG, "KRRSIGChange", fp);
-		printtime(key, DST_TIME_DS, "DSChange", fp);
-
-		printstate(key, DST_KEY_DNSKEY, "DNSKEYState", fp);
-		printstate(key, DST_KEY_ZRRSIG, "ZRRSIGState", fp);
-		printstate(key, DST_KEY_KRRSIG, "KRRSIGState", fp);
-		printstate(key, DST_KEY_DS, "DSState", fp);
-		printstate(key, DST_KEY_GOAL, "GoalState", fp);
-	}
-
-	return dst_key_close(tmpname, fp, filename);
-}
-
-/*%
- * Writes a public key to disk in DNS format.
- */
-static isc_result_t
-write_public_key(const dst_key_t *key, int type, const char *directory) {
-	FILE *fp;
-	isc_buffer_t keyb, tmpb, textb, fileb, classb;
-	isc_region_t r;
-	char tmpname[NAME_MAX];
-	char filename[NAME_MAX];
-	unsigned char key_array[DST_KEY_MAXSIZE];
-	char text_array[DST_KEY_MAXTEXTSIZE];
-	char class_array[10];
-	isc_result_t result;
-	dns_rdata_t rdata = DNS_RDATA_INIT;
-
-	REQUIRE(VALID_KEY(key));
-
-	isc_buffer_init(&keyb, key_array, sizeof(key_array));
-	isc_buffer_init(&textb, text_array, sizeof(text_array));
-	isc_buffer_init(&classb, class_array, sizeof(class_array));
-
-	result = dst_key_todns(key, &keyb);
-	if (result != ISC_R_SUCCESS) {
-		return result;
-	}
-
-	isc_buffer_usedregion(&keyb, &r);
-	dns_rdata_fromregion(&rdata, key->key_class, dns_rdatatype_dnskey, &r);
-
-	result = dns_rdata_totext(&rdata, (dns_name_t *)NULL, &textb);
-	if (result != ISC_R_SUCCESS) {
-		return DST_R_INVALIDPUBLICKEY;
-	}
-
-	result = dns_rdataclass_totext(key->key_class, &classb);
-	if (result != ISC_R_SUCCESS) {
-		return DST_R_INVALIDPUBLICKEY;
-	}
-
-	/*
-	 * Make the filename.
-	 */
-	isc_buffer_init(&fileb, filename, sizeof(filename));
-	result = dst_key_buildfilename(key, DST_TYPE_PUBLIC, directory, &fileb);
-	if (result != ISC_R_SUCCESS) {
-		return result;
-	}
-
-	isc_buffer_init(&tmpb, tmpname, sizeof(tmpname));
-	result = dst_key_buildfilename(key, DST_TYPE_TEMPLATE, directory,
-				       &tmpb);
-	if (result != ISC_R_SUCCESS) {
-		return result;
-	}
-
-	/* Create temporary public key file. */
-	mode_t mode = issymmetric(key) ? S_IRUSR | S_IWUSR
-				       : S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
-
-	fp = dst_key_open(tmpname, mode);
-	if (fp == NULL) {
-		return DST_R_WRITEERROR;
-	}
-
-	/* Write key information in comments */
-	if ((type & DST_TYPE_KEY) == 0) {
-		fprintf(fp, "; This is a %s%s-signing key, keyid %d, for ",
-			(key->key_flags & DNS_KEYFLAG_REVOKE) != 0 ? "revoked "
-								   : "",
-			(key->key_flags & DNS_KEYFLAG_KSK) != 0 ? "key"
-								: "zone",
-			key->key_id);
-		result = dns_name_print(key->key_name, fp);
-		if (result != ISC_R_SUCCESS) {
-			return dst_key_cleanup(tmpname, fp);
-		}
-		fputc('\n', fp);
-
-		printtime(key, DST_TIME_CREATED, "; Created", fp);
-		printtime(key, DST_TIME_PUBLISH, "; Publish", fp);
-		printtime(key, DST_TIME_ACTIVATE, "; Activate", fp);
-		printtime(key, DST_TIME_REVOKE, "; Revoke", fp);
-		printtime(key, DST_TIME_INACTIVE, "; Inactive", fp);
-		printtime(key, DST_TIME_DELETE, "; Delete", fp);
-		printtime(key, DST_TIME_SYNCPUBLISH, "; SyncPublish", fp);
-		printtime(key, DST_TIME_SYNCDELETE, "; SyncDelete", fp);
-	}
-
-	/* Now print the actual key */
-	result = dns_name_print(key->key_name, fp);
-	if (result != ISC_R_SUCCESS) {
-		return dst_key_cleanup(tmpname, fp);
-	}
-	fprintf(fp, " ");
-
-	if (key->key_ttl != 0) {
-		fprintf(fp, "%u ", key->key_ttl);
-	}
-
-	isc_buffer_usedregion(&classb, &r);
-	if ((unsigned)fwrite(r.base, 1, r.length, fp) != r.length) {
-		return dst_key_cleanup(tmpname, fp);
-	}
-
-	if ((type & DST_TYPE_KEY) != 0) {
-		fprintf(fp, " KEY ");
-	} else {
-		fprintf(fp, " DNSKEY ");
-	}
-
-	isc_buffer_usedregion(&textb, &r);
-	if ((unsigned)fwrite(r.base, 1, r.length, fp) != r.length) {
-		return dst_key_cleanup(tmpname, fp);
-	}
-
-	fputc('\n', fp);
-
-	return dst_key_close(tmpname, fp, filename);
-}
-
 static isc_result_t
 buildfilename(dns_name_t *name, dns_keytag_t id, unsigned int alg,
 	      unsigned int type, const char *directory, isc_buffer_t *out) {
diff --git a/lib/dns/dst_internal.h b/lib/dns/dst_internal.h
--- a/lib/dns/dst_internal.h
+++ b/lib/dns/dst_internal.h
@@ -96,7 +96,6 @@ struct dst_key {
 	char *label;		    /*%< engine label (HSM) */
 	union {
 		void *generic;
-		dns_gss_ctx_id_t gssctx;
 		DH *dh;
 		EVP_PKEY *pkey;
 		dst_hmac_key_t *hmac_key;
@@ -141,7 +140,6 @@ struct dst_context {
 	isc_logcategory_t *category;
 	union {
 		void *generic;
-		dst_gssapi_signverifyctx_t *gssctx;
 		isc_hmac_t *hmac_ctx;
 		EVP_MD_CTX *evp_md_ctx;
 	} ctxdata;
@@ -177,7 +175,6 @@ struct dst_func {
 	/* conversion functions */
 	isc_result_t (*todns)(const dst_key_t *key, isc_buffer_t *data);
 	isc_result_t (*fromdns)(dst_key_t *key, isc_buffer_t *data);
-	isc_result_t (*tofile)(const dst_key_t *key, const char *directory);
 	isc_result_t (*parse)(dst_key_t *key, isc_lex_t *lexer, dst_key_t *pub);
 
 	/* cleanup */
@@ -218,10 +215,6 @@ dst__opensslecdsa_init(struct dst_func **funcp);
 isc_result_t
 dst__openssleddsa_init(struct dst_func **funcp);
 #endif /* HAVE_OPENSSL_ED25519 || HAVE_OPENSSL_ED448 */
-#if HAVE_GSSAPI
-isc_result_t
-dst__gssapi_init(struct dst_func **funcp);
-#endif /* HAVE_GSSAPI*/
 
 /*%
  * Destructors
@@ -239,16 +232,6 @@ dst__mem_free(void *ptr);
 void *
 dst__mem_realloc(void *ptr, size_t size);
 
-/*%
- * Secure private file handling
- */
-FILE *
-dst_key_open(char *tmpname, mode_t mode);
-isc_result_t
-dst_key_close(char *tmpname, FILE *fp, char *filename);
-isc_result_t
-dst_key_cleanup(char *tmpname, FILE *fp);
-
 ISC_LANG_ENDDECLS
 
 /*! \file */
diff --git a/lib/dns/dst_parse.c b/lib/dns/dst_parse.c
--- a/lib/dns/dst_parse.c
+++ b/lib/dns/dst_parse.c
@@ -130,19 +130,6 @@ find_value(const char *s, const unsigned int alg) {
 	return -1;
 }
 
-static const char *
-find_tag(const int value) {
-	int i;
-
-	for (i = 0;; i++) {
-		if (map[i].tag == NULL) {
-			return NULL;
-		} else if (value == map[i].value) {
-			return map[i].tag;
-		}
-	}
-}
-
 static int
 find_metadata(const char *s, const char *tags[], int ntags) {
 	int i;
@@ -615,184 +602,4 @@ fail:
 	return ret;
 }
 
-isc_result_t
-dst__privstruct_writefile(const dst_key_t *key, const dst_private_t *priv,
-			  const char *directory) {
-	FILE *fp;
-	isc_result_t result;
-	char filename[NAME_MAX];
-	char tmpname[NAME_MAX];
-	char buffer[MAXFIELDSIZE * 2];
-	isc_stdtime_t when;
-	uint32_t value;
-	isc_buffer_t b;
-	isc_buffer_t fileb;
-	isc_buffer_t tmpb;
-	isc_region_t r;
-	int major, minor;
-	mode_t mode;
-	int i, ret;
-
-	REQUIRE(priv != NULL);
-
-	ret = check_data(priv, dst_key_alg(key), false, key->external);
-	if (ret < 0) {
-		return DST_R_INVALIDPRIVATEKEY;
-	} else if (ret != ISC_R_SUCCESS) {
-		return ret;
-	}
-
-	isc_buffer_init(&fileb, filename, sizeof(filename));
-	result = dst_key_buildfilename(key, DST_TYPE_PRIVATE, directory,
-				       &fileb);
-	if (result != ISC_R_SUCCESS) {
-		return result;
-	}
-
-	result = isc_file_mode(filename, &mode);
-	if (result == ISC_R_SUCCESS && mode != (S_IRUSR | S_IWUSR)) {
-		/* File exists; warn that we are changing its permissions */
-		int level;
-
-		level = ISC_LOG_WARNING;
-		isc_log_write(dns_lctx, DNS_LOGCATEGORY_GENERAL,
-			      DNS_LOGMODULE_DNSSEC, level,
-			      "Permissions on the file %s "
-			      "have changed from 0%o to 0600 as "
-			      "a result of this operation.",
-			      filename, (unsigned int)mode);
-	}
-
-	isc_buffer_init(&tmpb, tmpname, sizeof(tmpname));
-	result = dst_key_buildfilename(key, DST_TYPE_TEMPLATE, directory,
-				       &tmpb);
-	if (result != ISC_R_SUCCESS) {
-		return result;
-	}
-
-	fp = dst_key_open(tmpname, S_IRUSR | S_IWUSR);
-	if (fp == NULL) {
-		return DST_R_WRITEERROR;
-	}
-
-	dst_key_getprivateformat(key, &major, &minor);
-	if (major == 0 && minor == 0) {
-		major = DST_MAJOR_VERSION;
-		minor = DST_MINOR_VERSION;
-	}
-
-	/* XXXDCL return value should be checked for full filesystem */
-	fprintf(fp, "%s v%d.%d\n", PRIVATE_KEY_STR, major, minor);
-
-	fprintf(fp, "%s %u ", ALGORITHM_STR, dst_key_alg(key));
-
-	/* XXXVIX this switch statement is too sparse to gen a jump table. */
-	switch (dst_key_alg(key)) {
-	case DST_ALG_DH:
-		fprintf(fp, "(DH)\n");
-		break;
-	case DST_ALG_RSASHA1:
-		fprintf(fp, "(RSASHA1)\n");
-		break;
-	case DST_ALG_NSEC3RSASHA1:
-		fprintf(fp, "(NSEC3RSASHA1)\n");
-		break;
-	case DST_ALG_RSASHA256:
-		fprintf(fp, "(RSASHA256)\n");
-		break;
-	case DST_ALG_RSASHA512:
-		fprintf(fp, "(RSASHA512)\n");
-		break;
-	case DST_ALG_ECDSA256:
-		fprintf(fp, "(ECDSAP256SHA256)\n");
-		break;
-	case DST_ALG_ECDSA384:
-		fprintf(fp, "(ECDSAP384SHA384)\n");
-		break;
-	case DST_ALG_ED25519:
-		fprintf(fp, "(ED25519)\n");
-		break;
-	case DST_ALG_ED448:
-		fprintf(fp, "(ED448)\n");
-		break;
-	case DST_ALG_HMACMD5:
-		fprintf(fp, "(HMAC_MD5)\n");
-		break;
-	case DST_ALG_HMACSHA1:
-		fprintf(fp, "(HMAC_SHA1)\n");
-		break;
-	case DST_ALG_HMACSHA224:
-		fprintf(fp, "(HMAC_SHA224)\n");
-		break;
-	case DST_ALG_HMACSHA256:
-		fprintf(fp, "(HMAC_SHA256)\n");
-		break;
-	case DST_ALG_HMACSHA384:
-		fprintf(fp, "(HMAC_SHA384)\n");
-		break;
-	case DST_ALG_HMACSHA512:
-		fprintf(fp, "(HMAC_SHA512)\n");
-		break;
-	default:
-		fprintf(fp, "(?)\n");
-		break;
-	}
-
-	for (i = 0; i < priv->nelements; i++) {
-		const char *s;
-
-		s = find_tag(priv->elements[i].tag);
-
-		r.base = priv->elements[i].data;
-		r.length = priv->elements[i].length;
-		isc_buffer_init(&b, buffer, sizeof(buffer));
-		result = isc_base64_totext(&r, sizeof(buffer), "", &b);
-		if (result != ISC_R_SUCCESS) {
-			return dst_key_cleanup(tmpname, fp);
-		}
-		isc_buffer_usedregion(&b, &r);
-
-		fprintf(fp, "%s %.*s\n", s, (int)r.length, r.base);
-	}
-
-	if (key->external) {
-		fprintf(fp, "External:\n");
-	}
-
-	/* Add the metadata tags */
-	if (major > 1 || (major == 1 && minor >= 3)) {
-		for (i = 0; i < NUMERIC_NTAGS; i++) {
-			result = dst_key_getnum(key, i, &value);
-			if (result != ISC_R_SUCCESS) {
-				continue;
-			}
-			if (numerictags[i] != NULL) {
-				fprintf(fp, "%s %u\n", numerictags[i], value);
-			}
-		}
-		for (i = 0; i < TIMING_NTAGS; i++) {
-			result = dst_key_gettime(key, i, &when);
-			if (result != ISC_R_SUCCESS) {
-				continue;
-			}
-
-			isc_buffer_init(&b, buffer, sizeof(buffer));
-			result = dns_time32_totext(when, &b);
-			if (result != ISC_R_SUCCESS) {
-				return dst_key_cleanup(tmpname, fp);
-			}
-
-			isc_buffer_usedregion(&b, &r);
-
-			if (timetags[i] != NULL) {
-				fprintf(fp, "%s %.*s\n", timetags[i],
-					(int)r.length, r.base);
-			}
-		}
-	}
-
-	result = dst_key_close(tmpname, fp, filename);
-	return result;
-}
-
 /*! \file */
diff --git a/lib/dns/dst_parse.h b/lib/dns/dst_parse.h
--- a/lib/dns/dst_parse.h
+++ b/lib/dns/dst_parse.h
@@ -124,8 +124,4 @@ isc_result_t
 dst__privstruct_parse(dst_key_t *key, unsigned int alg, isc_lex_t *lex,
 		      isc_mem_t *mctx, dst_private_t *priv);
 
-isc_result_t
-dst__privstruct_writefile(const dst_key_t *key, const dst_private_t *priv,
-			  const char *directory);
-
 ISC_LANG_ENDDECLS
diff --git a/lib/dns/ecs.c b/lib/dns/ecs.c
--- a/lib/dns/ecs.c
+++ b/lib/dns/ecs.c
@@ -22,7 +22,6 @@
 #include <isc/util.h>
 
 #include <dns/ecs.h>
-#include <dns/nsec.h>
 #include <dns/rbt.h>
 #include <dns/rdata.h>
 #include <dns/rdatatype.h>
diff --git a/lib/dns/hmac_link.c b/lib/dns/hmac_link.c
--- a/lib/dns/hmac_link.c
+++ b/lib/dns/hmac_link.c
@@ -27,7 +27,7 @@
  * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <arpa/inet.h>
+#include <winsock2.h>
 #include <stdbool.h>
 
 #include <isc/buffer.h>
@@ -97,10 +97,6 @@
 						isc_buffer_t *data) {          \
 		return (hmac_fromdns(ISC_MD_##alg, key, data));                \
 	}                                                                      \
-	static isc_result_t hmac##alg##_tofile(const dst_key_t *key,           \
-					       const char *directory) {        \
-		return (hmac_tofile(ISC_MD_##alg, key, directory));            \
-	}                                                                      \
 	static isc_result_t hmac##alg##_parse(                                 \
 		dst_key_t *key, isc_lex_t *lexer, dst_key_t *pub) {            \
 		const char *file = isc_lex_getsourcename(lexer);               \
@@ -131,7 +127,6 @@
 		hmac##alg##_destroy,                                           \
 		hmac##alg##_todns,                                             \
 		hmac##alg##_fromdns,                                           \
-		hmac##alg##_tofile,                                            \
 		hmac##alg##_parse,                                             \
 		NULL, /*%< cleanup */                                          \
 		NULL, /*%< fromlabel */                                        \
@@ -368,77 +363,6 @@ hmac_fromdns(const isc_md_type_t *type, dst_key_t *key, isc_buffer_t *data) {
 	return ISC_R_SUCCESS;
 }
 
-static int
-hmac__get_tag_key(const isc_md_type_t *type) {
-	if (type == ISC_MD_MD5) {
-		return TAG_HMACMD5_KEY;
-	} else if (type == ISC_MD_SHA1) {
-		return TAG_HMACSHA1_KEY;
-	} else if (type == ISC_MD_SHA224) {
-		return TAG_HMACSHA224_KEY;
-	} else if (type == ISC_MD_SHA256) {
-		return TAG_HMACSHA256_KEY;
-	} else if (type == ISC_MD_SHA384) {
-		return TAG_HMACSHA384_KEY;
-	} else if (type == ISC_MD_SHA512) {
-		return TAG_HMACSHA512_KEY;
-	} else {
-		UNREACHABLE();
-	}
-}
-
-static int
-hmac__get_tag_bits(const isc_md_type_t *type) {
-	if (type == ISC_MD_MD5) {
-		return TAG_HMACMD5_BITS;
-	} else if (type == ISC_MD_SHA1) {
-		return TAG_HMACSHA1_BITS;
-	} else if (type == ISC_MD_SHA224) {
-		return TAG_HMACSHA224_BITS;
-	} else if (type == ISC_MD_SHA256) {
-		return TAG_HMACSHA256_BITS;
-	} else if (type == ISC_MD_SHA384) {
-		return TAG_HMACSHA384_BITS;
-	} else if (type == ISC_MD_SHA512) {
-		return TAG_HMACSHA512_BITS;
-	} else {
-		UNREACHABLE();
-	}
-}
-
-static isc_result_t
-hmac_tofile(const isc_md_type_t *type, const dst_key_t *key,
-	    const char *directory) {
-	dst_hmac_key_t *hkey;
-	dst_private_t priv;
-	int bytes = (key->key_size + 7) / 8;
-	uint16_t bits;
-
-	if (key->keydata.hmac_key == NULL) {
-		return DST_R_NULLKEY;
-	}
-
-	if (key->external) {
-		return DST_R_EXTERNALKEY;
-	}
-
-	hkey = key->keydata.hmac_key;
-
-	priv.elements[0].tag = hmac__get_tag_key(type);
-	priv.elements[0].length = bytes;
-	priv.elements[0].data = hkey->key;
-
-	bits = htons(key->key_bits);
-
-	priv.elements[1].tag = hmac__get_tag_bits(type);
-	priv.elements[1].length = sizeof(bits);
-	priv.elements[1].data = (uint8_t *)&bits;
-
-	priv.nelements = 2;
-
-	return dst__privstruct_writefile(key, &priv, directory);
-}
-
 static int
 hmac__to_dst_alg(const isc_md_type_t *type) {
 	if (type == ISC_MD_MD5) {
diff --git a/lib/dns/include/dns/acl.h b/lib/dns/include/dns/acl.h
--- a/lib/dns/include/dns/acl.h
+++ b/lib/dns/include/dns/acl.h
@@ -34,7 +34,6 @@
 #include <isc/refcount.h>
 #include <isc/rwlock.h>
 
-#include <dns/geoip.h>
 #include <dns/iptable.h>
 #include <dns/name.h>
 #include <dns/types.h>
@@ -49,9 +48,6 @@ typedef enum {
 	dns_aclelementtype_nestedacl,
 	dns_aclelementtype_localhost,
 	dns_aclelementtype_localnets,
-#if defined(HAVE_GEOIP2)
-	dns_aclelementtype_geoip,
-#endif /* HAVE_GEOIP2 */
 	dns_aclelementtype_any
 } dns_aclelementtype_t;
 
@@ -74,9 +70,6 @@ struct dns_aclelement {
 	dns_aclelementtype_t type;
 	bool		     negative;
 	dns_name_t	     keyname;
-#if defined(HAVE_GEOIP2)
-	dns_geoip_elem_t geoip_elem;
-#endif /* HAVE_GEOIP2 */
 	dns_acl_t *nestedacl;
 	int	   node_num;
 };
@@ -108,9 +101,6 @@ struct dns_aclenv {
 	dns_acl_t   *localnets;
 
 	bool match_mapped;
-#if defined(HAVE_GEOIP2)
-	dns_geoip_databases_t *geoip;
-#endif /* HAVE_GEOIP2 */
 };
 
 #define DNS_ACL_MAGIC	 ISC_MAGIC('D', 'a', 'c', 'l')
diff --git a/lib/dns/include/dns/byaddr.h b/lib/dns/include/dns/byaddr.h
--- a/lib/dns/include/dns/byaddr.h
+++ b/lib/dns/include/dns/byaddr.h
@@ -40,96 +40,12 @@
  *\li	Drafts:	TBS
  */
 
-#include <isc/event.h>
 #include <isc/lang.h>
 
 #include <dns/types.h>
 
 ISC_LANG_BEGINDECLS
 
-/*%
- * A 'dns_byaddrevent_t' is returned when a byaddr completes.
- * The sender field will be set to the byaddr that completed.  If 'result'
- * is ISC_R_SUCCESS, then 'names' will contain a list of names associated
- * with the address.  The recipient of the event must not change the list
- * and must not refer to any of the name data after the event is freed.
- */
-typedef struct dns_byaddrevent {
-	ISC_EVENT_COMMON(struct dns_byaddrevent);
-	isc_result_t   result;
-	dns_namelist_t names;
-} dns_byaddrevent_t;
-
-isc_result_t
-dns_byaddr_create(isc_mem_t *mctx, const isc_netaddr_t *address,
-		  dns_view_t *view, unsigned int options, isc_task_t *task,
-		  isc_taskaction_t action, void *arg, dns_byaddr_t **byaddrp);
-/*%<
- * Find the domain name of 'address'.
- *
- * Notes:
- *
- *\li	There is a reverse lookup format for IPv6 addresses, 'nibble'
- *
- *\li	The 'nibble' format for that address is
- *
- * \code
- *   1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa.
- * \endcode
- *
- * Requires:
- *
- *\li	'mctx' is a valid mctx.
- *
- *\li	'address' is a valid IPv4 or IPv6 address.
- *
- *\li	'view' is a valid view which has a resolver.
- *
- *\li	'task' is a valid task.
- *
- *\li	byaddrp != NULL && *byaddrp == NULL
- *
- * Returns:
- *
- *\li	#ISC_R_SUCCESS
- *\li	#ISC_R_NOMEMORY
- *
- *\li	Any resolver-related error (e.g. #ISC_R_SHUTTINGDOWN) may also be
- *	returned.
- */
-
-void
-dns_byaddr_cancel(dns_byaddr_t *byaddr);
-/*%<
- * Cancel 'byaddr'.
- *
- * Notes:
- *
- *\li	If 'byaddr' has not completed, post its #DNS_EVENT_BYADDRDONE
- *	event with a result code of #ISC_R_CANCELED.
- *
- * Requires:
- *
- *\li	'byaddr' is a valid byaddr.
- */
-
-void
-dns_byaddr_destroy(dns_byaddr_t **byaddrp);
-/*%<
- * Destroy 'byaddr'.
- *
- * Requires:
- *
- *\li	'*byaddrp' is a valid byaddr.
- *
- *\li	The caller has received the #DNS_EVENT_BYADDRDONE event (either because
- *	the byaddr completed or because dns_byaddr_cancel() was called).
- *
- * Ensures:
- *
- *\li	*byaddrp == NULL.
- */
-
 isc_result_t
 dns_byaddr_createptrname(const isc_netaddr_t *address, unsigned int options,
 			 dns_name_t *name);
diff --git a/lib/dns/include/dns/cache.h b/lib/dns/include/dns/cache.h
--- a/lib/dns/include/dns/cache.h
+++ b/lib/dns/include/dns/cache.h
@@ -45,7 +45,6 @@
 #include <stdbool.h>
 
 #include <isc/lang.h>
-#include <isc/stats.h>
 #include <isc/stdtime.h>
 
 #include <dns/types.h>
@@ -262,24 +261,6 @@ dns_cache_flushname(dns_cache_t *cache, const dns_name_t *name);
  *\li	other error returns.
  */
 
-isc_stats_t *
-dns_cache_getstats(dns_cache_t *cache);
-/*
- * Return a pointer to the stats collection object for 'cache'
- */
-
-void
-dns_cache_dumpstats(dns_cache_t *cache, FILE *fp);
-/*
- * Dump cache statistics and status in text to 'fp'
- */
-
-void
-dns_cache_updatestats(dns_cache_t *cache, isc_result_t result);
-/*
- * Update cache statistics based on result code in 'result'
- */
-
 void
 dns_cache_setmaxrrperset(dns_cache_t *cache, uint32_t value);
 /*%<
@@ -292,20 +273,4 @@ dns_cache_setmaxtypepername(dns_cache_t *cache, uint32_t value);
  * Set the maximum resource record types per owner name that can be cached.
  */
 
-#ifdef HAVE_LIBXML2
-int
-dns_cache_renderxml(dns_cache_t *cache, void *writer0);
-/*
- * Render cache statistics and status in XML for 'writer'.
- */
-#endif /* HAVE_LIBXML2 */
-
-#ifdef HAVE_JSON_C
-isc_result_t
-dns_cache_renderjson(dns_cache_t *cache, void *cstats0);
-/*
- * Render cache statistics and status in JSON
- */
-#endif /* HAVE_JSON_C */
-
 ISC_LANG_ENDDECLS
diff --git a/lib/dns/include/dns/callbacks.h b/lib/dns/include/dns/callbacks.h
--- a/lib/dns/include/dns/callbacks.h
+++ b/lib/dns/include/dns/callbacks.h
@@ -41,13 +41,6 @@ struct dns_rdatacallbacks {
 	 */
 	dns_addrdatasetfunc_t add;
 
-	/*%
-	 * dns_master_load*() call this when loading a raw zonefile,
-	 * to pass back information obtained from the file header
-	 */
-	dns_rawdatafunc_t rawdata;
-	dns_zone_t	 *zone;
-
 	/*%
 	 * dns_load_master / dns_rdata_fromtext call this to issue a error.
 	 */
diff --git a/lib/dns/include/dns/db.h b/lib/dns/include/dns/db.h
--- a/lib/dns/include/dns/db.h
+++ b/lib/dns/include/dns/db.h
@@ -53,7 +53,6 @@
 #include <isc/deprecated.h>
 #include <isc/lang.h>
 #include <isc/magic.h>
-#include <isc/stats.h>
 #include <isc/stdtime.h>
 
 #include <dns/clientinfo.h>
@@ -143,12 +142,6 @@ typedef struct dns_dbmethods {
 	isc_result_t (*getoriginnode)(dns_db_t *db, dns_dbnode_t **nodep);
 	void (*transfernode)(dns_db_t *db, dns_dbnode_t **sourcep,
 			     dns_dbnode_t **targetp);
-	isc_result_t (*getnsec3parameters)(dns_db_t	   *db,
-					   dns_dbversion_t *version,
-					   dns_hash_t *hash, uint8_t *flags,
-					   uint16_t	 *iterations,
-					   unsigned char *salt,
-					   size_t	 *salt_len);
 	isc_result_t (*findnsec3node)(dns_db_t *db, const dns_name_t *name,
 				      bool create, dns_dbnode_t **nodep);
 	isc_result_t (*setsigningtime)(dns_db_t *db, dns_rdataset_t *rdataset,
@@ -158,7 +151,6 @@ typedef struct dns_dbmethods {
 	void (*resigned)(dns_db_t *db, dns_rdataset_t *rdataset,
 			 dns_dbversion_t *version);
 	bool (*isdnssec)(dns_db_t *db);
-	dns_stats_t *(*getrrsetstats)(dns_db_t *db);
 	void (*rpz_attach)(dns_db_t *db, void *rpzs, uint8_t rpz_num);
 	isc_result_t (*rpz_ready)(dns_db_t *db);
 	isc_result_t (*findnodeext)(dns_db_t *db, const dns_name_t *name,
@@ -174,7 +166,6 @@ typedef struct dns_dbmethods {
 				dns_clientinfo_t	*clientinfo,
 				dns_rdataset_t		*rdataset,
 				dns_rdataset_t		*sigrdataset);
-	isc_result_t (*setcachestats)(dns_db_t *db, isc_stats_t *stats);
 	size_t (*hashsize)(dns_db_t *db);
 	isc_result_t (*nodefullname)(dns_db_t *db, dns_dbnode_t *node,
 				     dns_name_t *name);
@@ -184,7 +175,6 @@ typedef struct dns_dbmethods {
 	isc_result_t (*getservestalettl)(dns_db_t *db, dns_ttl_t *ttl);
 	isc_result_t (*setservestalerefresh)(dns_db_t *db, uint32_t interval);
 	isc_result_t (*getservestalerefresh)(dns_db_t *db, uint32_t *interval);
-	isc_result_t (*setgluecachestats)(dns_db_t *db, isc_stats_t *stats);
 	void (*setmaxrrperset)(dns_db_t *db, uint32_t value);
 	void (*setmaxtypepername)(dns_db_t *db, uint32_t value);
 } dns_dbmethods_t;
@@ -1488,23 +1478,6 @@ dns_db_getoriginnode(dns_db_t *db, dns_dbnode_t **nodep);
  * \li	#ISC_R_NOTFOUND - the DB implementation does not support this feature.
  */
 
-isc_result_t
-dns_db_getnsec3parameters(dns_db_t *db, dns_dbversion_t *version,
-			  dns_hash_t *hash, uint8_t *flags,
-			  uint16_t *iterations, unsigned char *salt,
-			  size_t *salt_length);
-/*%<
- * Get the NSEC3 parameters that are associated with this zone.
- *
- * Requires:
- * \li	'db' is a valid zone database.
- *
- * Returns:
- * \li	#ISC_R_SUCCESS
- * \li	#ISC_R_NOTFOUND - the DB implementation does not support this feature
- *			  or this zone does not have NSEC3 records.
- */
-
 isc_result_t
 dns_db_getsize(dns_db_t *db, dns_dbversion_t *version, uint64_t *records,
 	       uint64_t *xfrsize);
@@ -1610,36 +1583,6 @@ dns_db_resigned(dns_db_t *db, dns_rdataset_t *rdataset,
  * \li	'version' to be open for writing.
  */
 
-dns_stats_t *
-dns_db_getrrsetstats(dns_db_t *db);
-/*%<
- * Get statistics information counting RRsets stored in the DB, when available.
- * The statistics may not be available depending on the DB implementation.
- *
- * Requires:
- *
- * \li	'db' is a valid database (cache only).
- *
- * Returns:
- * \li	when available, a pointer to a statistics object created by
- *	dns_rdatasetstats_create(); otherwise NULL.
- */
-
-isc_result_t
-dns_db_setcachestats(dns_db_t *db, isc_stats_t *stats);
-/*%<
- * Set the location in which to collect cache statistics.
- * This option may not exist depending on the DB implementation.
- *
- * Requires:
- *
- * \li	'db' is a valid database (cache only).
- *
- * Returns:
- * \li	when available, a pointer to a statistics object created by
- *	dns_rdatasetstats_create(); otherwise NULL.
- */
-
 void
 dns_db_rpz_attach(dns_db_t *db, void *rpzs, uint8_t rpz_num) ISC_DEPRECATED;
 /*%<
@@ -1755,21 +1698,6 @@ dns_db_getservestalerefresh(dns_db_t *db, uint32_t *interval);
  * \li	#ISC_R_NOTIMPLEMENTED - Not supported by this DB implementation.
  */
 
-isc_result_t
-dns_db_setgluecachestats(dns_db_t *db, isc_stats_t *stats);
-/*%<
- * Set the location in which to collect glue cache statistics.
- * This option may not exist depending on the DB implementation.
- *
- * Requires:
- *
- * \li	'db' is a valid database (cache only).
- *
- * Returns:
- * \li	when available, a pointer to a statistics object created by
- *	dns_rdatasetstats_create(); otherwise NULL.
- */
-
 void
 dns_db_setmaxrrperset(dns_db_t *db, uint32_t value);
 /*%<
diff --git a/lib/dns/include/dns/dispatch.h b/lib/dns/include/dns/dispatch.h
--- a/lib/dns/include/dns/dispatch.h
+++ b/lib/dns/include/dns/dispatch.h
@@ -150,21 +150,6 @@ dns_dispatchmgr_setavailports(dns_dispatchmgr_t *mgr, isc_portset_t *v4portset,
  *\li	v6portset is NULL or a valid port set
  */
 
-void
-dns_dispatchmgr_setstats(dns_dispatchmgr_t *mgr, isc_stats_t *stats);
-/*%<
- * Sets statistics counter for the dispatchmgr.  This function is expected to
- * be called only on zone creation (when necessary).
- * Once installed, it cannot be removed or replaced.  Also, there is no
- * interface to get the installed stats from the zone; the caller must keep the
- * stats to reference (e.g. dump) it later.
- *
- * Requires:
- *\li	mgr is a valid dispatchmgr with no managed dispatch.
- *\li	stats is a valid statistics supporting resolver statistics counters
- *	(see dns/stats.h).
- */
-
 isc_result_t
 dns_dispatch_createudp(dns_dispatchmgr_t *mgr, const isc_sockaddr_t *localaddr,
 		       dns_dispatch_t **dispp);
diff --git a/lib/dns/include/dns/dns64.h b/lib/dns/include/dns/dns64.h
--- a/lib/dns/include/dns/dns64.h
+++ b/lib/dns/include/dns/dns64.h
@@ -21,153 +21,6 @@
 
 ISC_LANG_BEGINDECLS
 
-/*
- * dns_dns64_create() flags.
- */
-#define DNS_DNS64_RECURSIVE_ONLY          \
-	0x01 /* If set then this record   \
-	      * only applies to recursive \
-	      * queries.                  \
-	      */
-#define DNS_DNS64_BREAK_DNSSEC            \
-	0x02 /* If set then still perform \
-	      * DNSSEC synthesis even     \
-	      * though the result would   \
-	      * fail validation.          \
-	      */
-
-/*
- * dns_dns64_aaaaok() and dns_dns64_aaaafroma() flags.
- */
-#define DNS_DNS64_RECURSIVE 0x01 /* Recursive query. */
-#define DNS_DNS64_DNSSEC    0x02 /* DNSSEC sensitive query. */
-
-isc_result_t
-dns_dns64_create(isc_mem_t *mctx, const isc_netaddr_t *prefix,
-		 unsigned int prefixlen, const isc_netaddr_t *suffix,
-		 dns_acl_t *client, dns_acl_t *mapped, dns_acl_t *excluded,
-		 unsigned int flags, dns_dns64_t **dns64);
-/*
- * Create a dns64 record which is used to identify the set of clients
- * it applies to and how to perform the DNS64 synthesis.
- *
- * 'prefix' and 'prefixlen' defined the leading bits of the AAAA records
- * to be synthesised.  'suffix' defines the bits after the A records bits.
- * If suffix is NULL zeros will be used for these bits.  'client' defines
- * for which clients this record applies.  If 'client' is NULL then all
- * clients apply.  'mapped' defines which A records are candidated for
- * mapping.  If 'mapped' is NULL then all A records will be mapped.
- * 'excluded' defines which AAAA are to be treated as non-existent for the
- * purposed of determining whether to perform synthesis.  If 'excluded' is
- * NULL then no AAAA records prevent synthesis.
- *
- * If DNS_DNS64_RECURSIVE_ONLY is set then the record will only match if
- * DNS_DNS64_RECURSIVE is set when calling  dns_dns64_aaaaok() and
- * dns_dns64_aaaafroma().
- *
- * If DNS_DNS64_BREAK_DNSSEC is set then the record will still apply if
- * DNS_DNS64_DNSSEC is set when calling  dns_dns64_aaaaok() and
- * dns_dns64_aaaafroma() otherwise the record will be ignored.
- *
- * Requires:
- *      'mctx'          to be valid.
- *      'prefix'        to be valid and the address family to AF_INET6.
- *      'prefixlen'     to be one of 32, 40, 48, 56, 72 and 96.
- *                      the bits not covered by prefixlen in prefix to
- *                      be zero.
- *      'suffix'        to be NULL or the address family be set to AF_INET6
- *                      and the leading 'prefixlen' + 32 bits of the 'suffix'
- *                      to be zero.  If 'prefixlen' is 40, 48 or 56 then the
- *                      the leading 'prefixlen' + 40 bits of 'suffix' must be
- *                      zero.
- *	'client'	to be NULL or a valid acl.
- *	'mapped'	to be NULL or a valid acl.
- *	'excluded'	to be NULL or a valid acl.
- *
- * Returns:
- *	ISC_R_SUCCESS
- *	ISC_R_NOMEMORY
- */
-
-void
-dns_dns64_destroy(dns_dns64_t **dns64p);
-/*
- * Destroys a dns64 record.
- *
- * Requires the record to not be linked.
- */
-
-isc_result_t
-dns_dns64_aaaafroma(const dns_dns64_t *dns64, const isc_netaddr_t *reqaddr,
-		    const dns_name_t *reqsigner, dns_aclenv_t *env,
-		    unsigned int flags, unsigned char *a, unsigned char *aaaa);
-/*
- * dns_dns64_aaaafroma() determines whether to perform a DNS64 address
- * synthesis from 'a' based on 'dns64', 'reqaddr', 'reqsigner', 'env',
- * 'flags' and 'aaaa'.  If synthesis is performed then the result is
- * written to '*aaaa'.
- *
- * The synthesised address will be of the form:
- *
- *	 <prefix bits><a bits><suffix bits>
- *
- * If <a bits> straddle bits 64-71 of the AAAA record, then 8 zero bits will
- * be inserted at bits 64-71.
- *
- * Requires:
- *	'dns64'		to be valid.
- *	'reqaddr'	to be valid.
- *	'reqsigner'	to be NULL or valid.
- *	'env'		to be valid.
- *	'a'		to point to a IPv4 address in network order.
- *	'aaaa'		to point to a IPv6 address buffer in network order.
- *
- * Returns:
- *	ISC_R_SUCCESS		if synthesis was performed.
- *	DNS_R_DISALLOWED	if there is no match.
- */
-
-dns_dns64_t *
-dns_dns64_next(dns_dns64_t *dns64);
-/*
- * Return the next dns64 record in the list.
- */
-
-void
-dns_dns64_append(dns_dns64list_t *list, dns_dns64_t *dns64);
-/*
- * Append the dns64 record to the list.
- */
-
-void
-dns_dns64_unlink(dns_dns64list_t *list, dns_dns64_t *dns64);
-/*
- * Unlink the dns64 record from the list.
- */
-
-bool
-dns_dns64_aaaaok(const dns_dns64_t *dns64, const isc_netaddr_t *reqaddr,
-		 const dns_name_t *reqsigner, dns_aclenv_t *env,
-		 unsigned int flags, dns_rdataset_t *rdataset, bool *aaaaok,
-		 size_t aaaaoklen);
-/*
- * Determine if there are any non-excluded AAAA records in from the
- * matching dns64 records in the list starting at 'dns64'.  If there
- * is a non-excluded address return true.  If all addresses are
- * excluded in the matched records return false.   If no records
- * match then return true.
- *
- * If aaaaok is defined then dns_dns64_aaaaok() return a array of which
- * addresses in 'rdataset' were deemed to not be exclude by any matching
- * record.  If there are no matching records then all entries are set
- * to true.
- *
- * Requires
- * 	'rdataset'	to be valid and to be for type AAAA and class IN.
- *	'aaaaoklen'	must match the number of records in 'rdataset'
- *			if 'aaaaok' in non NULL.
- */
-
 isc_result_t
 dns_dns64_findprefix(dns_rdataset_t *rdataset, isc_netprefix_t *prefix,
 		     size_t *len);
diff --git a/lib/dns/include/dns/dnssec.h b/lib/dns/include/dns/dnssec.h
--- a/lib/dns/include/dns/dnssec.h
+++ b/lib/dns/include/dns/dnssec.h
@@ -18,7 +18,6 @@
 #include <stdbool.h>
 
 #include <isc/lang.h>
-#include <isc/stats.h>
 #include <isc/stdtime.h>
 
 #include <dns/diff.h>
@@ -28,8 +27,6 @@
 
 ISC_LANG_BEGINDECLS
 
-extern isc_stats_t *dns_dnssec_stats;
-
 /*%< Maximum number of keys supported in a zone. */
 #define DNS_MAXZONEKEYS 32
 
diff --git a/lib/dns/include/dns/message.h b/lib/dns/include/dns/message.h
--- a/lib/dns/include/dns/message.h
+++ b/lib/dns/include/dns/message.h
@@ -1322,47 +1322,6 @@ dns_message_signer(dns_message_t *msg, dns_name_t *signer);
  *				  but the signature has not been verified yet
  */
 
-isc_result_t
-dns_message_checksig(dns_message_t *msg, dns_view_t *view);
-/*%<
- * If this message was signed, verify the signature.
- *
- * Requires:
- *
- *\li	msg is a valid parsed message.
- *\li	view is a valid view or NULL
- *
- * Returns:
- *
- *\li	#ISC_R_SUCCESS		- the message was unsigned, or the message
- *				  was signed correctly.
- *
- *\li	#DNS_R_EXPECTEDTSIG	- A TSIG was expected, but not seen
- *\li	#DNS_R_UNEXPECTEDTSIG	- A TSIG was seen but not expected
- *\li	#DNS_R_TSIGVERIFYFAILURE - The TSIG failed to verify
- */
-
-isc_result_t
-dns_message_rechecksig(dns_message_t *msg, dns_view_t *view);
-/*%<
- * Reset the signature state and then if the message was signed,
- * verify the message.
- *
- * Requires:
- *
- *\li	msg is a valid parsed message.
- *\li	view is a valid view or NULL
- *
- * Returns:
- *
- *\li	#ISC_R_SUCCESS		- the message was unsigned, or the message
- *				  was signed correctly.
- *
- *\li	#DNS_R_EXPECTEDTSIG	- A TSIG was expected, but not seen
- *\li	#DNS_R_UNEXPECTEDTSIG	- A TSIG was seen but not expected
- *\li	#DNS_R_TSIGVERIFYFAILURE - The TSIG failed to verify
- */
-
 void
 dns_message_resetsig(dns_message_t *msg);
 /*%<
diff --git a/lib/dns/include/dns/tkey.h b/lib/dns/include/dns/tkey.h
--- a/lib/dns/include/dns/tkey.h
+++ b/lib/dns/include/dns/tkey.h
@@ -23,23 +23,19 @@
 #include <dns/types.h>
 
 #include <dst/dst.h>
-#include <dst/gssapi.h>
 
 ISC_LANG_BEGINDECLS
 
 /* Key agreement modes */
 #define DNS_TKEYMODE_SERVERASSIGNED   1
 #define DNS_TKEYMODE_DIFFIEHELLMAN    2
-#define DNS_TKEYMODE_GSSAPI	      3
 #define DNS_TKEYMODE_RESOLVERASSIGNED 4
 #define DNS_TKEYMODE_DELETE	      5
 
 struct dns_tkeyctx {
 	dst_key_t	 *dhkey;
 	dns_name_t	 *domain;
-	dns_gss_cred_id_t gsscred;
 	isc_mem_t	 *mctx;
-	char		 *gssapi_keytab;
 };
 
 isc_result_t
@@ -115,31 +111,6 @@ dns_tkey_builddhquery(dns_message_t *msg, dst_key_t *key,
  *\li		other		an error occurred while building the message
  */
 
-isc_result_t
-dns_tkey_buildgssquery(dns_message_t *msg, const dns_name_t *name,
-		       const dns_name_t *gname, isc_buffer_t *intoken,
-		       uint32_t lifetime, dns_gss_ctx_id_t *context, bool win2k,
-		       isc_mem_t *mctx, char **err_message);
-/*%<
- *	Builds a query containing a TKEY that will generate a GSSAPI context.
- *	The key is requested to have the specified lifetime (in seconds).
- *
- *	Requires:
- *\li		'msg'	  is a valid message
- *\li		'name'	  is a valid name
- *\li		'gname'	  is a valid name
- *\li		'context' is a pointer to a valid gss_ctx_id_t
- *			  (which may have the value GSS_C_NO_CONTEXT)
- *\li		'win2k'   when true says to turn on some hacks to work
- *			  with the non-standard GSS-TSIG of Windows 2000
- *
- *	Returns:
- *\li		ISC_R_SUCCESS	msg was successfully updated to include the
- *				query to be sent
- *\li		other		an error occurred while building the message
- *\li		*err_message	optional error message
- */
-
 isc_result_t
 dns_tkey_builddeletequery(dns_message_t *msg, dns_tsigkey_t *key);
 /*%<
@@ -179,15 +150,6 @@ dns_tkey_processdhresponse(dns_message_t *qmsg, dns_message_t *rmsg,
  *				component of the query or response
  */
 
-isc_result_t
-dns_tkey_processgssresponse(dns_message_t *qmsg, dns_message_t *rmsg,
-			    const dns_name_t *gname, dns_gss_ctx_id_t *context,
-			    isc_buffer_t *outtoken, dns_tsigkey_t **outkey,
-			    dns_tsig_keyring_t *ring, char **err_message);
-/*%<
- * XXX
- */
-
 isc_result_t
 dns_tkey_processdeleteresponse(dns_message_t *qmsg, dns_message_t *rmsg,
 			       dns_tsig_keyring_t *ring);
@@ -207,37 +169,4 @@ dns_tkey_processdeleteresponse(dns_message_t *qmsg, dns_message_t *rmsg,
  *				component of the query or response
  */
 
-isc_result_t
-dns_tkey_gssnegotiate(dns_message_t *qmsg, dns_message_t *rmsg,
-		      const dns_name_t *server, dns_gss_ctx_id_t *context,
-		      dns_tsigkey_t **outkey, dns_tsig_keyring_t *ring,
-		      bool win2k, char **err_message);
-
-/*
- *	Client side negotiation of GSS-TSIG.  Process the response
- *	to a TKEY, and establish a TSIG key if negotiation was successful.
- *	Build a response to the input TKEY message.  Can take multiple
- *	calls to successfully establish the context.
- *
- *	Requires:
- *		'qmsg'    is a valid message, the original TKEY request;
- *			     it will be filled with the new message to send
- *		'rmsg'    is a valid message, the incoming TKEY message
- *		'server'  is the server name
- *		'context' is the input context handle
- *		'outkey'  receives the established key, if non-NULL;
- *			      if non-NULL must point to NULL
- *		'ring'	  is the keyring in which to establish the key,
- *			      or NULL
- *		'win2k'   when true says to turn on some hacks to work
- *			      with the non-standard GSS-TSIG of Windows 2000
- *
- *	Returns:
- *		ISC_R_SUCCESS	context was successfully established
- *		ISC_R_NOTFOUND  couldn't find a needed part of the query
- *					or response
- *		DNS_R_CONTINUE  additional context negotiation is required;
- *					send the new qmsg to the server
- */
-
 ISC_LANG_ENDDECLS
diff --git a/lib/dns/include/dns/tsig.h b/lib/dns/include/dns/tsig.h
--- a/lib/dns/include/dns/tsig.h
+++ b/lib/dns/include/dns/tsig.h
@@ -33,10 +33,6 @@
  */
 extern const dns_name_t *dns_tsig_hmacmd5_name;
 #define DNS_TSIG_HMACMD5_NAME dns_tsig_hmacmd5_name
-extern const dns_name_t *dns_tsig_gssapi_name;
-#define DNS_TSIG_GSSAPI_NAME dns_tsig_gssapi_name
-extern const dns_name_t *dns_tsig_gssapims_name;
-#define DNS_TSIG_GSSAPIMS_NAME dns_tsig_gssapims_name
 extern const dns_name_t *dns_tsig_hmacsha1_name;
 #define DNS_TSIG_HMACSHA1_NAME dns_tsig_hmacsha1_name
 extern const dns_name_t *dns_tsig_hmacsha224_name;
diff --git a/lib/dns/include/dns/types.h b/lib/dns/include/dns/types.h
--- a/lib/dns/include/dns/types.h
+++ b/lib/dns/include/dns/types.h
@@ -31,21 +31,8 @@
 typedef struct dns_acl	       dns_acl_t;
 typedef struct dns_aclelement  dns_aclelement_t;
 typedef struct dns_aclenv      dns_aclenv_t;
-typedef struct dns_adb	       dns_adb_t;
-typedef struct dns_adbaddrinfo dns_adbaddrinfo_t;
-typedef ISC_LIST(dns_adbaddrinfo_t) dns_adbaddrinfolist_t;
-typedef struct dns_adbentry dns_adbentry_t;
-typedef struct dns_adbfind  dns_adbfind_t;
-typedef ISC_LIST(dns_adbfind_t) dns_adbfindlist_t;
 typedef struct dns_badcache	       dns_badcache_t;
 typedef struct dns_byaddr	       dns_byaddr_t;
-typedef struct dns_catz_zonemodmethods dns_catz_zonemodmethods_t;
-typedef struct dns_catz_entry_options  dns_catz_options_t;
-typedef struct dns_catz_entry	       dns_catz_entry_t;
-typedef struct dns_catz_coo	       dns_catz_coo_t;
-typedef struct dns_catz_zone	       dns_catz_zone_t;
-typedef struct dns_catz_changed	       dns_catz_changed_t;
-typedef struct dns_catz_zones	       dns_catz_zones_t;
 typedef struct dns_client	       dns_client_t;
 typedef void			       dns_clientrestrans_t;
 typedef void			       dns_clientreqtrans_t;
@@ -60,11 +47,7 @@ typedef void			       dns_dbload_t;
 typedef void			       dns_dbnode_t;
 typedef struct dns_dbonupdatelistener  dns_dbonupdatelistener_t;
 typedef void			       dns_dbversion_t;
-typedef struct dns_dlzimplementation   dns_dlzimplementation_t;
-typedef struct dns_dlzdb	       dns_dlzdb_t;
-typedef ISC_LIST(dns_dlzdb_t) dns_dlzdblist_t;
 typedef struct dns_dyndbctx	      dns_dyndbctx_t;
-typedef struct dns_sdlzimplementation dns_sdlzimplementation_t;
 typedef struct dns_decompress	      dns_decompress_t;
 typedef struct dns_dispatch	      dns_dispatch_t;
 typedef struct dns_dispatchlist	      dns_dispatchlist_t;
@@ -86,21 +69,11 @@ typedef struct dns_ecs		   dns_ecs_t;
 typedef struct dns_ednsopt	   dns_ednsopt_t;
 typedef struct dns_fetch	   dns_fetch_t;
 typedef struct dns_fixedname	   dns_fixedname_t;
-typedef struct dns_forwarders	   dns_forwarders_t;
-typedef struct dns_forwarder	   dns_forwarder_t;
-typedef struct dns_fwdtable	   dns_fwdtable_t;
-typedef struct dns_geoip_databases dns_geoip_databases_t;
 typedef struct dns_iptable	   dns_iptable_t;
 typedef uint32_t		   dns_iterations_t;
-typedef struct dns_kasp		   dns_kasp_t;
-typedef ISC_LIST(dns_kasp_t) dns_kasplist_t;
-typedef struct dns_kasp_key dns_kasp_key_t;
-typedef ISC_LIST(dns_kasp_key_t) dns_kasp_keylist_t;
-typedef struct dns_kasp_nsec3param dns_kasp_nsec3param_t;
 typedef uint16_t		   dns_keyflags_t;
 typedef struct dns_keynode	   dns_keynode_t;
 typedef ISC_LIST(dns_keynode_t) dns_keynodelist_t;
-typedef struct dns_keytable	   dns_keytable_t;
 typedef uint16_t		   dns_keytag_t;
 typedef struct dns_loadctx	   dns_loadctx_t;
 typedef struct dns_loadmgr	   dns_loadmgr_t;
@@ -112,8 +85,6 @@ typedef isc_region_t		   dns_label_t;
 typedef struct dns_lookup	   dns_lookup_t;
 typedef struct dns_name		   dns_name_t;
 typedef ISC_LIST(dns_name_t) dns_namelist_t;
-typedef struct dns_nta		  dns_nta_t;
-typedef struct dns_ntatable	  dns_ntatable_t;
 typedef uint16_t		  dns_opcode_t;
 typedef unsigned char		  dns_offsets_t[128];
 typedef struct dns_order	  dns_order_t;
@@ -131,34 +102,18 @@ typedef struct dns_rdatasetiter	     dns_rdatasetiter_t;
 typedef uint16_t		     dns_rdatatype_t;
 typedef struct dns_request	     dns_request_t;
 typedef struct dns_requestmgr	     dns_requestmgr_t;
-typedef struct dns_resolver	     dns_resolver_t;
-typedef struct dns_sdbimplementation dns_sdbimplementation_t;
 typedef uint8_t			     dns_secalg_t;
 typedef uint8_t			     dns_secproto_t;
 typedef struct dns_signature	     dns_signature_t;
 typedef struct dns_sortlist_arg	     dns_sortlist_arg_t;
-typedef struct dns_ssurule	     dns_ssurule_t;
-typedef struct dns_ssutable	     dns_ssutable_t;
-typedef struct dns_stats	     dns_stats_t;
-typedef uint32_t		     dns_rdatastatstype_t;
 typedef struct dns_tkeyctx	     dns_tkeyctx_t;
 typedef uint16_t		     dns_trust_t;
 typedef struct dns_tsec		     dns_tsec_t;
 typedef struct dns_tsig_keyring	     dns_tsig_keyring_t;
 typedef struct dns_tsigkey	     dns_tsigkey_t;
 typedef uint32_t		     dns_ttl_t;
-typedef struct dns_update_state	     dns_update_state_t;
-typedef struct dns_validator	     dns_validator_t;
-typedef struct dns_view		     dns_view_t;
-typedef ISC_LIST(dns_view_t) dns_viewlist_t;
-typedef struct dns_zone dns_zone_t;
-typedef ISC_LIST(dns_zone_t) dns_zonelist_t;
-typedef struct dns_zonemgr   dns_zonemgr_t;
-typedef struct dns_zt	     dns_zt_t;
 typedef struct dns_ipkeylist dns_ipkeylist_t;
 
-typedef struct dst_gssapi_signverifyctx dst_gssapi_signverifyctx_t;
-
 typedef enum { dns_hash_sha1 = 1 } dns_hash_t;
 
 typedef enum {
@@ -397,8 +352,6 @@ typedef void (*dns_dumpdonefunc_t)(void *, isc_result_t);
 
 typedef void (*dns_loaddonefunc_t)(void *, isc_result_t);
 
-typedef void (*dns_rawdatafunc_t)(dns_zone_t *, dns_masterrawheader_t *);
-
 typedef isc_result_t (*dns_addrdatasetfunc_t)(void *, const dns_name_t *,
 					      dns_rdataset_t *);
 
@@ -408,24 +361,8 @@ typedef isc_result_t (*dns_additionaldatafunc_t)(void *, const dns_name_t *,
 
 typedef isc_result_t (*dns_digestfunc_t)(void *, isc_region_t *);
 
-typedef void (*dns_xfrindone_t)(dns_zone_t *, isc_result_t);
-
 typedef void (*dns_updatecallback_t)(void *, isc_result_t, dns_message_t *);
 
 typedef int (*dns_rdatasetorderfunc_t)(const dns_rdata_t *, const void *);
 
-typedef bool (*dns_checkmxfunc_t)(dns_zone_t *, const dns_name_t *,
-				  const dns_name_t *);
-
-typedef bool (*dns_checksrvfunc_t)(dns_zone_t *, const dns_name_t *,
-				   const dns_name_t *);
-
-typedef bool (*dns_checknsfunc_t)(dns_zone_t *, const dns_name_t *,
-				  const dns_name_t *, dns_rdataset_t *,
-				  dns_rdataset_t *);
-
-typedef bool (*dns_isselffunc_t)(dns_view_t *, dns_tsigkey_t *,
-				 const isc_sockaddr_t *, const isc_sockaddr_t *,
-				 dns_rdataclass_t, void *);
-
 typedef void (*dns_nseclog_t)(void *val, int, const char *, ...);
diff --git a/lib/dns/include/dst/dst.h b/lib/dns/include/dst/dst.h
--- a/lib/dns/include/dst/dst.h
+++ b/lib/dns/include/dst/dst.h
@@ -28,8 +28,6 @@
 #include <dns/secalg.h>
 #include <dns/types.h>
 
-#include <dst/gssapi.h>
-
 ISC_LANG_BEGINDECLS
 
 /***
@@ -103,7 +101,6 @@ typedef enum dst_algorithm {
 	 */
 	DST_ALG_HMACMD5 = 157,
 	DST_ALG_HMAC_FIRST = DST_ALG_HMACMD5,
-	DST_ALG_GSSAPI = 160,	  /* Internal use only. Exception. */
 	DST_ALG_HMACSHA1 = 161,	  /* XXXMPA */
 	DST_ALG_HMACSHA224 = 162, /* XXXMPA */
 	DST_ALG_HMACSHA256 = 163, /* XXXMPA */
@@ -464,23 +461,6 @@ dst_key_read_state(const char *filename, isc_mem_t *mctx, dst_key_t **keyp);
  * \li	any other result indicates failure
  */
 
-isc_result_t
-dst_key_tofile(const dst_key_t *key, int type, const char *directory);
-/*%<
- * Writes a key to permanent storage.  The key can either be a public or
- * private key.  Public keys are written in DNS format and private keys
- * are written as a set of base64 encoded values.  If directory is NULL,
- * the current directory is assumed.
- *
- * Requires:
- * \li	"key" is a valid key.
- * \li	"type" is DST_TYPE_PUBLIC, DST_TYPE_PRIVATE, or the bitwise union
- *
- * Returns:
- * \li	ISC_R_SUCCESS
- * \li	any other result indicates failure
- */
-
 isc_result_t
 dst_key_fromdns_ex(const dns_name_t *name, dns_rdataclass_t rdclass,
 		   isc_buffer_t *source, isc_mem_t *mctx, bool no_rdata,
@@ -582,40 +562,6 @@ dst_key_privatefrombuffer(dst_key_t *key, isc_buffer_t *buffer);
  *\li	If successful, key will contain a valid private key.
  */
 
-dns_gss_ctx_id_t
-dst_key_getgssctx(const dst_key_t *key);
-/*%<
- * Returns the opaque key data.
- * Be cautions when using this value unless you know what you are doing.
- *
- * Requires:
- *\li	"key" is not NULL.
- *
- * Returns:
- *\li	gssctx key data, possibly NULL.
- */
-
-isc_result_t
-dst_key_fromgssapi(const dns_name_t *name, dns_gss_ctx_id_t gssctx,
-		   isc_mem_t *mctx, dst_key_t **keyp, isc_region_t *intoken);
-/*%<
- * Converts a GSSAPI opaque context id into a DST key.
- *
- * Requires:
- *\li	"name" is a valid absolute dns name.
- *\li	"gssctx" is a GSSAPI context id.
- *\li	"mctx" is a valid memory context.
- *\li	"keyp" is not NULL and "*keyp" is NULL.
- *
- * Returns:
- *\li 	ISC_R_SUCCESS
- * \li	any other result indicates failure
- *
- * Ensures:
- *\li	If successful, *keyp will contain a valid key and be responsible for
- *	the context id.
- */
-
 #ifdef DST_KEY_INTERNAL
 isc_result_t
 dst_key_buildinternal(const dns_name_t *name, unsigned int alg,
diff --git a/lib/dns/master.c b/lib/dns/master.c
--- a/lib/dns/master.c
+++ b/lib/dns/master.c
@@ -2648,10 +2648,6 @@ load_raw(dns_loadctx_t *lctx) {
 		result = lctx->result;
 	}
 
-	if (result == ISC_R_SUCCESS && callbacks->rawdata != NULL) {
-		(*callbacks->rawdata)(callbacks->zone, &lctx->header);
-	}
-
 cleanup:
 	if (rdata != NULL) {
 		isc_mem_put(mctx, rdata, rdata_size * sizeof(*rdata));
diff --git a/lib/dns/message.c b/lib/dns/message.c
--- a/lib/dns/message.c
+++ b/lib/dns/message.c
@@ -31,7 +31,9 @@
 #include <isc/utf8.h>
 #include <isc/util.h>
 
+#include <dns/acl.h>
 #include <dns/dnssec.h>
+#include <dns/fixedname.h>
 #include <dns/keyvalues.h>
 #include <dns/log.h>
 #include <dns/masterdump.h>
@@ -45,7 +47,6 @@
 #include <dns/soa.h>
 #include <dns/tsig.h>
 #include <dns/ttl.h>
-#include <dns/view.h>
 
 #ifdef SKAN_MSG_DEBUG
 static void
@@ -3191,63 +3192,6 @@ dns_message_resetsig(dns_message_t *msg) {
 	}
 }
 
-isc_result_t
-dns_message_rechecksig(dns_message_t *msg, dns_view_t *view) {
-	dns_message_resetsig(msg);
-	return dns_message_checksig(msg, view);
-}
-
-#ifdef SKAN_MSG_DEBUG
-void
-dns_message_dumpsig(dns_message_t *msg, char *txt1) {
-	dns_rdata_t querytsigrdata = DNS_RDATA_INIT;
-	dns_rdata_any_tsig_t querytsig;
-	isc_result_t result;
-
-	if (msg->tsig != NULL) {
-		result = dns_rdataset_first(msg->tsig);
-		RUNTIME_CHECK(result == ISC_R_SUCCESS);
-		dns_rdataset_current(msg->tsig, &querytsigrdata);
-		result = dns_rdata_tostruct(&querytsigrdata, &querytsig, NULL);
-		RUNTIME_CHECK(result == ISC_R_SUCCESS);
-		hexdump(txt1, "TSIG", querytsig.signature, querytsig.siglen);
-	}
-
-	if (msg->querytsig != NULL) {
-		result = dns_rdataset_first(msg->querytsig);
-		RUNTIME_CHECK(result == ISC_R_SUCCESS);
-		dns_rdataset_current(msg->querytsig, &querytsigrdata);
-		result = dns_rdata_tostruct(&querytsigrdata, &querytsig, NULL);
-		RUNTIME_CHECK(result == ISC_R_SUCCESS);
-		hexdump(txt1, "QUERYTSIG", querytsig.signature,
-			querytsig.siglen);
-	}
-}
-#endif /* ifdef SKAN_MSG_DEBUG */
-
-isc_result_t
-dns_message_checksig(dns_message_t *msg, dns_view_t *view) {
-	isc_buffer_t msgb;
-
-	REQUIRE(DNS_MESSAGE_VALID(msg));
-
-	if (msg->tsigkey == NULL && msg->tsig == NULL) {
-		return ISC_R_SUCCESS;
-	}
-
-	INSIST(msg->saved.base != NULL);
-	isc_buffer_init(&msgb, msg->saved.base, msg->saved.length);
-	isc_buffer_add(&msgb, msg->saved.length);
-#ifdef SKAN_MSG_DEBUG
-	dns_message_dumpsig(msg, "dns_message_checksig#1");
-#endif /* ifdef SKAN_MSG_DEBUG */
-	if (view != NULL) {
-		return dns_view_checksig(view, &msgb, msg);
-	} else {
-		return dns_tsig_verify(&msgb, msg, NULL, NULL);
-	}
-}
-
 #define INDENT(sp)                                                           \
 	do {                                                                 \
 		unsigned int __i;                                            \
diff --git a/lib/dns/openssldh_link.c b/lib/dns/openssldh_link.c
--- a/lib/dns/openssldh_link.c
+++ b/lib/dns/openssldh_link.c
@@ -1001,101 +1001,6 @@ err:
 	return ret;
 }
 
-static isc_result_t
-openssldh_tofile(const dst_key_t *key, const char *directory) {
-#if OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000
-	DH *dh;
-	const BIGNUM *pub_key = NULL, *priv_key = NULL, *p = NULL, *g = NULL;
-#else
-	EVP_PKEY *pkey;
-	BIGNUM *pub_key = NULL, *priv_key = NULL, *p = NULL, *g = NULL;
-#endif /* OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000 */
-	dst_private_t priv;
-	unsigned char *bufs[4] = { NULL };
-	unsigned short i = 0;
-	isc_result_t result;
-
-	if (key->external) {
-		return DST_R_EXTERNALKEY;
-	}
-
-#if OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000
-	if (key->keydata.dh == NULL) {
-		return DST_R_NULLKEY;
-	}
-
-	dh = key->keydata.dh;
-	DH_get0_key(dh, &pub_key, &priv_key);
-	DH_get0_pqg(dh, &p, NULL, &g);
-#else
-	if (key->keydata.pkey == NULL) {
-		return DST_R_NULLKEY;
-	}
-
-	pkey = key->keydata.pkey;
-	EVP_PKEY_get_bn_param(pkey, OSSL_PKEY_PARAM_FFC_P, &p);
-	EVP_PKEY_get_bn_param(pkey, OSSL_PKEY_PARAM_FFC_G, &g);
-	EVP_PKEY_get_bn_param(pkey, OSSL_PKEY_PARAM_PUB_KEY, &pub_key);
-	EVP_PKEY_get_bn_param(pkey, OSSL_PKEY_PARAM_PRIV_KEY, &priv_key);
-#endif /* OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000 */
-
-	priv.elements[i].tag = TAG_DH_PRIME;
-	priv.elements[i].length = BN_num_bytes(p);
-	bufs[i] = isc_mem_get(key->mctx, priv.elements[i].length);
-	BN_bn2bin(p, bufs[i]);
-	priv.elements[i].data = bufs[i];
-	i++;
-
-	priv.elements[i].tag = TAG_DH_GENERATOR;
-	priv.elements[i].length = BN_num_bytes(g);
-	bufs[i] = isc_mem_get(key->mctx, priv.elements[i].length);
-	BN_bn2bin(g, bufs[i]);
-	priv.elements[i].data = bufs[i];
-	i++;
-
-	priv.elements[i].tag = TAG_DH_PRIVATE;
-	priv.elements[i].length = BN_num_bytes(priv_key);
-	bufs[i] = isc_mem_get(key->mctx, priv.elements[i].length);
-	BN_bn2bin(priv_key, bufs[i]);
-	priv.elements[i].data = bufs[i];
-	i++;
-
-	priv.elements[i].tag = TAG_DH_PUBLIC;
-	priv.elements[i].length = BN_num_bytes(pub_key);
-	bufs[i] = isc_mem_get(key->mctx, priv.elements[i].length);
-	BN_bn2bin(pub_key, bufs[i]);
-	priv.elements[i].data = bufs[i];
-	i++;
-
-	priv.nelements = i;
-	result = dst__privstruct_writefile(key, &priv, directory);
-
-	while (i--) {
-		if (bufs[i] != NULL) {
-			isc_mem_put(key->mctx, bufs[i],
-				    priv.elements[i].length);
-		}
-	}
-
-#if OPENSSL_VERSION_NUMBER >= 0x30000000L && OPENSSL_API_LEVEL >= 30000
-	if (p != NULL) {
-		BN_free(p);
-	}
-	if (g != NULL) {
-		BN_free(g);
-	}
-	if (pub_key != NULL) {
-		BN_free(pub_key);
-	}
-	if (priv_key != NULL) {
-		BN_clear_free(priv_key);
-	}
-#endif /* OPENSSL_VERSION_NUMBER >= 0x30000000L && OPENSSL_API_LEVEL >= 30000 \
-	*/
-
-	return result;
-}
-
 static isc_result_t
 openssldh_parse(dst_key_t *key, isc_lex_t *lexer, dst_key_t *pub) {
 	dst_private_t priv;
@@ -1291,7 +1196,6 @@ static dst_func_t openssldh_functions = {
 	openssldh_destroy,
 	openssldh_todns,
 	openssldh_fromdns,
-	openssldh_tofile,
 	openssldh_parse,
 	openssldh_cleanup,
 	NULL, /*%< fromlabel */
diff --git a/lib/dns/opensslecdsa_link.c b/lib/dns/opensslecdsa_link.c
--- a/lib/dns/opensslecdsa_link.c
+++ b/lib/dns/opensslecdsa_link.c
@@ -823,97 +823,6 @@ err:
 	return ret;
 }
 
-static isc_result_t
-opensslecdsa_tofile(const dst_key_t *key, const char *directory) {
-	isc_result_t ret;
-	EVP_PKEY *pkey;
-#if OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000
-	EC_KEY *eckey = NULL;
-	const BIGNUM *privkey = NULL;
-#else
-	int status;
-	BIGNUM *privkey = NULL;
-#endif /* OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000 */
-	dst_private_t priv;
-	unsigned char *buf = NULL;
-	unsigned short i;
-
-	if (key->keydata.pkey == NULL) {
-		DST_RET(DST_R_NULLKEY);
-	}
-
-	if (key->external) {
-		priv.nelements = 0;
-		DST_RET(dst__privstruct_writefile(key, &priv, directory));
-	}
-
-	pkey = key->keydata.pkey;
-#if OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000
-	eckey = EVP_PKEY_get1_EC_KEY(pkey);
-	if (eckey == NULL) {
-		DST_RET(dst__openssl_toresult2("EVP_PKEY_get1_EC_KEY",
-					       DST_R_OPENSSLFAILURE));
-	}
-	privkey = EC_KEY_get0_private_key(eckey);
-	if (privkey == NULL) {
-		DST_RET(dst__openssl_toresult2("EC_KEY_get0_private_key",
-					       DST_R_OPENSSLFAILURE));
-	}
-#else
-	status = EVP_PKEY_get_bn_param(pkey, OSSL_PKEY_PARAM_PRIV_KEY,
-				       &privkey);
-	if (status != 1 || privkey == NULL) {
-		DST_RET(dst__openssl_toresult2("EVP_PKEY_get_bn_param",
-					       DST_R_OPENSSLFAILURE));
-	}
-#endif /* OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000 */
-
-	buf = isc_mem_get(key->mctx, BN_num_bytes(privkey));
-
-	i = 0;
-
-	priv.elements[i].tag = TAG_ECDSA_PRIVATEKEY;
-	priv.elements[i].length = BN_num_bytes(privkey);
-	BN_bn2bin(privkey, buf);
-	priv.elements[i].data = buf;
-	i++;
-
-	if (key->engine != NULL) {
-		priv.elements[i].tag = TAG_ECDSA_ENGINE;
-		priv.elements[i].length = (unsigned short)strlen(key->engine) +
-					  1;
-		priv.elements[i].data = (unsigned char *)key->engine;
-		i++;
-	}
-
-	if (key->label != NULL) {
-		priv.elements[i].tag = TAG_ECDSA_LABEL;
-		priv.elements[i].length = (unsigned short)strlen(key->label) +
-					  1;
-		priv.elements[i].data = (unsigned char *)key->label;
-		i++;
-	}
-
-	priv.nelements = i;
-	ret = dst__privstruct_writefile(key, &priv, directory);
-
-err:
-	if (buf != NULL && privkey != NULL) {
-		isc_mem_put(key->mctx, buf, BN_num_bytes(privkey));
-	}
-#if OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000
-	if (eckey != NULL) {
-		EC_KEY_free(eckey);
-	}
-#else
-	if (privkey != NULL) {
-		BN_clear_free(privkey);
-	}
-#endif /* OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000 */
-
-	return ret;
-}
-
 #if OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000
 static isc_result_t
 ecdsa_check(EC_KEY *eckey, EC_KEY *pubeckey) {
@@ -1435,7 +1344,6 @@ static dst_func_t opensslecdsa_functions = {
 	opensslecdsa_destroy,
 	opensslecdsa_todns,
 	opensslecdsa_fromdns,
-	opensslecdsa_tofile,
 	opensslecdsa_parse,
 	NULL,			/*%< cleanup */
 	opensslecdsa_fromlabel, /*%< fromlabel */
diff --git a/lib/dns/openssleddsa_link.c b/lib/dns/openssleddsa_link.c
--- a/lib/dns/openssleddsa_link.c
+++ b/lib/dns/openssleddsa_link.c
@@ -437,70 +437,6 @@ openssleddsa_fromdns(dst_key_t *key, isc_buffer_t *data) {
 	return ISC_R_SUCCESS;
 }
 
-static isc_result_t
-openssleddsa_tofile(const dst_key_t *key, const char *directory) {
-	isc_result_t ret;
-	dst_private_t priv;
-	unsigned char *buf = NULL;
-	size_t len;
-	int i;
-
-	REQUIRE(key->key_alg == DST_ALG_ED25519 ||
-		key->key_alg == DST_ALG_ED448);
-
-	if (key->keydata.pkey == NULL) {
-		return DST_R_NULLKEY;
-	}
-
-	if (key->external) {
-		priv.nelements = 0;
-		return dst__privstruct_writefile(key, &priv, directory);
-	}
-
-	i = 0;
-
-	if (openssleddsa_isprivate(key)) {
-		if (key->key_alg == DST_ALG_ED25519) {
-			len = DNS_KEY_ED25519SIZE;
-		} else {
-			len = DNS_KEY_ED448SIZE;
-		}
-		buf = isc_mem_get(key->mctx, len);
-		if (EVP_PKEY_get_raw_private_key(key->keydata.pkey, buf,
-						 &len) != 1)
-		{
-			DST_RET(dst__openssl_toresult(ISC_R_FAILURE));
-		}
-		priv.elements[i].tag = TAG_EDDSA_PRIVATEKEY;
-		priv.elements[i].length = len;
-		priv.elements[i].data = buf;
-		i++;
-	}
-	if (key->engine != NULL) {
-		priv.elements[i].tag = TAG_EDDSA_ENGINE;
-		priv.elements[i].length = (unsigned short)strlen(key->engine) +
-					  1;
-		priv.elements[i].data = (unsigned char *)key->engine;
-		i++;
-	}
-	if (key->label != NULL) {
-		priv.elements[i].tag = TAG_EDDSA_LABEL;
-		priv.elements[i].length = (unsigned short)strlen(key->label) +
-					  1;
-		priv.elements[i].data = (unsigned char *)key->label;
-		i++;
-	}
-
-	priv.nelements = i;
-	ret = dst__privstruct_writefile(key, &priv, directory);
-
-err:
-	if (buf != NULL) {
-		isc_mem_put(key->mctx, buf, len);
-	}
-	return ret;
-}
-
 static isc_result_t
 eddsa_check(EVP_PKEY *pkey, EVP_PKEY *pubpkey) {
 	if (pubpkey == NULL) {
@@ -689,7 +625,6 @@ static dst_func_t openssleddsa_functions = {
 	openssleddsa_destroy,
 	openssleddsa_todns,
 	openssleddsa_fromdns,
-	openssleddsa_tofile,
 	openssleddsa_parse,
 	NULL, /*%< cleanup */
 	openssleddsa_fromlabel,
diff --git a/lib/dns/opensslrsa_link.c b/lib/dns/opensslrsa_link.c
--- a/lib/dns/opensslrsa_link.c
+++ b/lib/dns/opensslrsa_link.c
@@ -810,189 +810,6 @@ err:
 	return ret;
 }
 
-static isc_result_t
-opensslrsa_tofile(const dst_key_t *key, const char *directory) {
-	isc_result_t ret;
-	dst_private_t priv = { 0 };
-	unsigned char *bufs[8] = { NULL };
-	unsigned short i = 0;
-	EVP_PKEY *pkey;
-#if OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000
-	RSA *rsa = NULL;
-	const BIGNUM *n = NULL, *e = NULL, *d = NULL;
-	const BIGNUM *p = NULL, *q = NULL;
-	const BIGNUM *dmp1 = NULL, *dmq1 = NULL, *iqmp = NULL;
-#else
-	BIGNUM *n = NULL, *e = NULL, *d = NULL;
-	BIGNUM *p = NULL, *q = NULL;
-	BIGNUM *dmp1 = NULL, *dmq1 = NULL, *iqmp = NULL;
-#endif /* OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000 */
-
-	if (key->keydata.pkey == NULL) {
-		DST_RET(DST_R_NULLKEY);
-	}
-
-	if (key->external) {
-		return dst__privstruct_writefile(key, &priv, directory);
-	}
-
-	pkey = key->keydata.pkey;
-#if OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000
-	rsa = EVP_PKEY_get1_RSA(pkey);
-	if (rsa == NULL) {
-		DST_RET(dst__openssl_toresult(DST_R_OPENSSLFAILURE));
-	}
-	RSA_get0_key(rsa, &n, &e, &d);
-	RSA_get0_factors(rsa, &p, &q);
-	RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);
-#else
-	EVP_PKEY_get_bn_param(pkey, OSSL_PKEY_PARAM_RSA_N, &n);
-	EVP_PKEY_get_bn_param(pkey, OSSL_PKEY_PARAM_RSA_E, &e);
-	EVP_PKEY_get_bn_param(pkey, OSSL_PKEY_PARAM_RSA_D, &d);
-	EVP_PKEY_get_bn_param(pkey, OSSL_PKEY_PARAM_RSA_FACTOR1, &p);
-	EVP_PKEY_get_bn_param(pkey, OSSL_PKEY_PARAM_RSA_FACTOR2, &q);
-	EVP_PKEY_get_bn_param(pkey, OSSL_PKEY_PARAM_RSA_EXPONENT1, &dmp1);
-	EVP_PKEY_get_bn_param(pkey, OSSL_PKEY_PARAM_RSA_EXPONENT2, &dmq1);
-	EVP_PKEY_get_bn_param(pkey, OSSL_PKEY_PARAM_RSA_COEFFICIENT1, &iqmp);
-	ERR_clear_error();
-#endif /* OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000 */
-
-	if (n == NULL || e == NULL) {
-		DST_RET(dst__openssl_toresult(DST_R_OPENSSLFAILURE));
-	}
-
-	priv.elements[i].tag = TAG_RSA_MODULUS;
-	priv.elements[i].length = BN_num_bytes(n);
-	bufs[i] = isc_mem_get(key->mctx, priv.elements[i].length);
-	BN_bn2bin(n, bufs[i]);
-	priv.elements[i].data = bufs[i];
-	i++;
-
-	priv.elements[i].tag = TAG_RSA_PUBLICEXPONENT;
-	priv.elements[i].length = BN_num_bytes(e);
-	bufs[i] = isc_mem_get(key->mctx, priv.elements[i].length);
-	BN_bn2bin(e, bufs[i]);
-	priv.elements[i].data = bufs[i];
-	i++;
-
-	if (d != NULL) {
-		priv.elements[i].tag = TAG_RSA_PRIVATEEXPONENT;
-		priv.elements[i].length = BN_num_bytes(d);
-		INSIST(i < ARRAY_SIZE(bufs));
-		bufs[i] = isc_mem_get(key->mctx, priv.elements[i].length);
-		BN_bn2bin(d, bufs[i]);
-		priv.elements[i].data = bufs[i];
-		i++;
-	}
-
-	if (p != NULL) {
-		priv.elements[i].tag = TAG_RSA_PRIME1;
-		priv.elements[i].length = BN_num_bytes(p);
-		INSIST(i < ARRAY_SIZE(bufs));
-		bufs[i] = isc_mem_get(key->mctx, priv.elements[i].length);
-		BN_bn2bin(p, bufs[i]);
-		priv.elements[i].data = bufs[i];
-		i++;
-	}
-
-	if (q != NULL) {
-		priv.elements[i].tag = TAG_RSA_PRIME2;
-		priv.elements[i].length = BN_num_bytes(q);
-		INSIST(i < ARRAY_SIZE(bufs));
-		bufs[i] = isc_mem_get(key->mctx, priv.elements[i].length);
-		BN_bn2bin(q, bufs[i]);
-		priv.elements[i].data = bufs[i];
-		i++;
-	}
-
-	if (dmp1 != NULL) {
-		priv.elements[i].tag = TAG_RSA_EXPONENT1;
-		priv.elements[i].length = BN_num_bytes(dmp1);
-		INSIST(i < ARRAY_SIZE(bufs));
-		bufs[i] = isc_mem_get(key->mctx, priv.elements[i].length);
-		BN_bn2bin(dmp1, bufs[i]);
-		priv.elements[i].data = bufs[i];
-		i++;
-	}
-
-	if (dmq1 != NULL) {
-		priv.elements[i].tag = TAG_RSA_EXPONENT2;
-		priv.elements[i].length = BN_num_bytes(dmq1);
-		INSIST(i < ARRAY_SIZE(bufs));
-		bufs[i] = isc_mem_get(key->mctx, priv.elements[i].length);
-		BN_bn2bin(dmq1, bufs[i]);
-		priv.elements[i].data = bufs[i];
-		i++;
-	}
-
-	if (iqmp != NULL) {
-		priv.elements[i].tag = TAG_RSA_COEFFICIENT;
-		priv.elements[i].length = BN_num_bytes(iqmp);
-		INSIST(i < ARRAY_SIZE(bufs));
-		bufs[i] = isc_mem_get(key->mctx, priv.elements[i].length);
-		BN_bn2bin(iqmp, bufs[i]);
-		priv.elements[i].data = bufs[i];
-		i++;
-	}
-
-	if (key->engine != NULL) {
-		priv.elements[i].tag = TAG_RSA_ENGINE;
-		priv.elements[i].length = (unsigned short)strlen(key->engine) +
-					  1;
-		priv.elements[i].data = (unsigned char *)key->engine;
-		i++;
-	}
-
-	if (key->label != NULL) {
-		priv.elements[i].tag = TAG_RSA_LABEL;
-		priv.elements[i].length = (unsigned short)strlen(key->label) +
-					  1;
-		priv.elements[i].data = (unsigned char *)key->label;
-		i++;
-	}
-
-	priv.nelements = i;
-	ret = dst__privstruct_writefile(key, &priv, directory);
-
-err:
-	for (i = 0; i < ARRAY_SIZE(bufs); i++) {
-		if (bufs[i] != NULL) {
-			isc_mem_put(key->mctx, bufs[i],
-				    priv.elements[i].length);
-		}
-	}
-#if OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000
-	RSA_free(rsa);
-#else
-	if (n != NULL) {
-		BN_free(n);
-	}
-	if (e != NULL) {
-		BN_free(e);
-	}
-	if (d != NULL) {
-		BN_clear_free(d);
-	}
-	if (p != NULL) {
-		BN_clear_free(p);
-	}
-	if (q != NULL) {
-		BN_clear_free(q);
-	}
-	if (dmp1 != NULL) {
-		BN_clear_free(dmp1);
-	}
-	if (dmq1 != NULL) {
-		BN_clear_free(dmq1);
-	}
-	if (iqmp != NULL) {
-		BN_clear_free(iqmp);
-	}
-#endif /* OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000 */
-
-	return ret;
-}
-
 #if OPENSSL_VERSION_NUMBER < 0x30000000L || OPENSSL_API_LEVEL < 30000
 static isc_result_t
 rsa_check(RSA *rsa, RSA *pub) {
@@ -1559,7 +1376,6 @@ static dst_func_t opensslrsa_functions = {
 	opensslrsa_destroy,
 	opensslrsa_todns,
 	opensslrsa_fromdns,
-	opensslrsa_tofile,
 	opensslrsa_parse,
 	NULL, /*%< cleanup */
 	opensslrsa_fromlabel,
diff --git a/lib/dns/rbtdb.c b/lib/dns/rbtdb.c
--- a/lib/dns/rbtdb.c
+++ b/lib/dns/rbtdb.c
@@ -16,7 +16,6 @@
 #include <ctype.h>
 #include <inttypes.h>
 #include <stdbool.h>
-#include <sys/mman.h>
 
 #include <isc/atomic.h>
 #include <isc/crc64.h>
@@ -47,19 +46,13 @@
 #include <dns/fixedname.h>
 #include <dns/log.h>
 #include <dns/masterdump.h>
-#include <dns/nsec.h>
-#include <dns/nsec3.h>
 #include <dns/rbt.h>
 #include <dns/rdata.h>
 #include <dns/rdataset.h>
 #include <dns/rdatasetiter.h>
 #include <dns/rdataslab.h>
 #include <dns/rdatastruct.h>
-#include <dns/stats.h>
 #include <dns/time.h>
-#include <dns/view.h>
-#include <dns/zone.h>
-#include <dns/zonekey.h>
 
 #include "rbtdb.h"
 
@@ -255,7 +248,7 @@ typedef ISC_LIST(dns_rbtnode_t) rbtnodelist_t;
 #define NONEXISTENT(header)                            \
 	((atomic_load_acquire(&(header)->attributes) & \
 	  RDATASET_ATTR_NONEXISTENT) != 0)
-#define IGNORE(header)                                 \
+#define ISC_IGNORE(header)                                 \
 	((atomic_load_acquire(&(header)->attributes) & \
 	  RDATASET_ATTR_IGNORE) != 0)
 #define RETAIN(header)                                 \
@@ -420,12 +413,6 @@ typedef struct rbtdb_version {
 	ISC_LINK(struct rbtdb_version) link;
 	dns_db_secure_t secure;
 	bool havensec3;
-	/* NSEC3 parameters */
-	dns_hash_t hash;
-	uint8_t flags;
-	uint16_t iterations;
-	uint8_t salt_length;
-	unsigned char salt[DNS_NSEC3_SALTSIZE];
 
 	/*
 	 * records and xfrsize are covered by rwlock.
@@ -454,9 +441,6 @@ struct dns_rbtdb {
 	rbtdb_nodelock_t *node_locks;
 	dns_rbtnode_t *origin_node;
 	dns_rbtnode_t *nsec3_origin_node;
-	dns_stats_t *rrsetstats;     /* cache DB only */
-	isc_stats_t *cachestats;     /* cache DB only */
-	isc_stats_t *gluecachestats; /* zone DB only */
 	/* Locked by lock. */
 	unsigned int active;
 	isc_refcount_t references;
@@ -735,8 +719,6 @@ free_rbtdb(dns_rbtdb_t *rbtdb, bool log, isc_event_t *event);
 static void
 overmem(dns_db_t *db, bool over);
 static void
-setnsec3parameters(dns_db_t *db, rbtdb_version_t *version);
-static void
 setownercase(rdatasetheader_t *header, const dns_name_t *name);
 
 /*%
@@ -810,83 +792,6 @@ free_rbtdb_callback(isc_task_t *task, isc_event_t *event) {
 	free_rbtdb(rbtdb, true, event);
 }
 
-static void
-update_cachestats(dns_rbtdb_t *rbtdb, isc_result_t result) {
-	INSIST(IS_CACHE(rbtdb));
-
-	if (rbtdb->cachestats == NULL) {
-		return;
-	}
-
-	switch (result) {
-	case DNS_R_COVERINGNSEC:
-		isc_stats_increment(rbtdb->cachestats,
-				    dns_cachestatscounter_coveringnsec);
-		FALLTHROUGH;
-	case ISC_R_SUCCESS:
-	case DNS_R_CNAME:
-	case DNS_R_DNAME:
-	case DNS_R_DELEGATION:
-	case DNS_R_NCACHENXDOMAIN:
-	case DNS_R_NCACHENXRRSET:
-		isc_stats_increment(rbtdb->cachestats,
-				    dns_cachestatscounter_hits);
-		break;
-	default:
-		isc_stats_increment(rbtdb->cachestats,
-				    dns_cachestatscounter_misses);
-	}
-}
-
-static bool
-do_stats(rdatasetheader_t *header) {
-	return EXISTS(header) && STATCOUNT(header);
-}
-
-static void
-update_rrsetstats(dns_rbtdb_t *rbtdb, const rbtdb_rdatatype_t htype,
-		  const uint_least16_t hattributes, const bool increment) {
-	dns_rdatastatstype_t statattributes = 0;
-	dns_rdatastatstype_t base = 0;
-	dns_rdatastatstype_t type;
-	rdatasetheader_t *header = &(rdatasetheader_t){
-		.type = htype,
-		.attributes = hattributes,
-	};
-
-	if (!do_stats(header)) {
-		return;
-	}
-
-	/* At the moment we count statistics only for cache DB */
-	INSIST(IS_CACHE(rbtdb));
-
-	if (NEGATIVE(header)) {
-		if (NXDOMAIN(header)) {
-			statattributes = DNS_RDATASTATSTYPE_ATTR_NXDOMAIN;
-		} else {
-			statattributes = DNS_RDATASTATSTYPE_ATTR_NXRRSET;
-			base = RBTDB_RDATATYPE_EXT(header->type);
-		}
-	} else {
-		base = RBTDB_RDATATYPE_BASE(header->type);
-	}
-
-	if (STALE(header)) {
-		statattributes |= DNS_RDATASTATSTYPE_ATTR_STALE;
-	}
-	if (ANCIENT(header)) {
-		statattributes |= DNS_RDATASTATSTYPE_ATTR_ANCIENT;
-	}
-
-	type = DNS_RDATASTATSTYPE_VALUE(base, statattributes);
-	if (increment) {
-		dns_rdatasetstats_increment(rbtdb->rrsetstats, type);
-	} else {
-		dns_rdatasetstats_decrement(rbtdb->rrsetstats, type);
-	}
-}
-
 static void
 set_ttl(dns_rbtdb_t *rbtdb, rdatasetheader_t *header, dns_ttl_t newttl) {
 	int idx;
@@ -1196,16 +1101,6 @@ free_rbtdb(dns_rbtdb_t *rbtdb, bool log, isc_event_t *event) {
 			    rbtdb->node_lock_count * sizeof(isc_heap_t *));
 	}
 
-	if (rbtdb->rrsetstats != NULL) {
-		dns_stats_detach(&rbtdb->rrsetstats);
-	}
-	if (rbtdb->cachestats != NULL) {
-		isc_stats_detach(&rbtdb->cachestats);
-	}
-	if (rbtdb->gluecachestats != NULL) {
-		isc_stats_detach(&rbtdb->gluecachestats);
-	}
-
 	isc_mem_put(rbtdb->common.mctx, rbtdb->node_locks,
 		    rbtdb->node_lock_count * sizeof(rbtdb_nodelock_t));
 	isc_rwlock_destroy(&rbtdb->tree_lock);
@@ -1360,20 +1255,6 @@ newversion(dns_db_t *db, dns_dbversion_t **versionp) {
 	version->commit_ok = true;
 	version->secure = rbtdb->current_version->secure;
 	version->havensec3 = rbtdb->current_version->havensec3;
-	if (version->havensec3) {
-		version->flags = rbtdb->current_version->flags;
-		version->iterations = rbtdb->current_version->iterations;
-		version->hash = rbtdb->current_version->hash;
-		version->salt_length = rbtdb->current_version->salt_length;
-		memmove(version->salt, rbtdb->current_version->salt,
-			version->salt_length);
-	} else {
-		version->flags = 0;
-		version->iterations = 0;
-		version->hash = 0;
-		version->salt_length = 0;
-		memset(version->salt, 0, sizeof(version->salt));
-	}
 	isc_rwlock_init(&version->rwlock, 0, 0);
 	RWLOCK(&rbtdb->current_version->rwlock, isc_rwlocktype_read);
 	version->records = rbtdb->current_version->records;
@@ -1501,9 +1382,6 @@ free_rdataset(dns_rbtdb_t *rbtdb, isc_mem_t *mctx, rdatasetheader_t *rdataset) {
 	unsigned int size;
 	int idx;
 
-	update_rrsetstats(rbtdb, rdataset->type,
-			  atomic_load_acquire(&rdataset->attributes), false);
-
 	idx = rdataset->node->locknum;
 	if (ISC_LINK_LINKED(rdataset, link)) {
 		INSIST(IS_CACHE(rbtdb));
@@ -1571,6 +1449,8 @@ mark_header_ancient(dns_rbtdb_t *rbtdb, rdatasetheader_t *header) {
 	uint_least16_t attributes = atomic_load_acquire(&header->attributes);
 	uint_least16_t newattributes = 0;
 
+	UNUSED(rbtdb);
+
 	/*
 	 * If we are already ancient there is nothing to do.
 	 */
@@ -1582,17 +1462,7 @@ mark_header_ancient(dns_rbtdb_t *rbtdb, rdatasetheader_t *header) {
 	} while (!atomic_compare_exchange_weak_acq_rel(
 		&header->attributes, &attributes, newattributes));
 
-	/*
-	 * Decrement the stats counter for the appropriate RRtype.
-	 * If the STALE attribute is set, this will decrement the
-	 * stale type counter, otherwise it decrements the active
-	 * stats type counter.
-	 */
-	update_rrsetstats(rbtdb, header->type, attributes, false);
 	header->node->dirty = 1;
-
-	/* Increment the stats counter for the ancient RRtype. */
-	update_rrsetstats(rbtdb, header->type, newattributes, true);
 }
 
 static void
@@ -1600,6 +1470,8 @@ mark_header_stale(dns_rbtdb_t *rbtdb, rdatasetheader_t *header) {
 	uint_least16_t attributes = atomic_load_acquire(&header->attributes);
 	uint_least16_t newattributes = 0;
 
+	UNUSED(rbtdb);
+
 	INSIST((attributes & RDATASET_ATTR_ZEROTTL) == 0);
 
 	/*
@@ -1612,16 +1484,6 @@ mark_header_stale(dns_rbtdb_t *rbtdb, rdatasetheader_t *header) {
 		newattributes = attributes | RDATASET_ATTR_STALE;
 	} while (!atomic_compare_exchange_weak_acq_rel(
 		&header->attributes, &attributes, newattributes));
-
-	/* Decrement the stats counter for the appropriate RRtype.
-	 * If the ANCIENT attribute is set (although it is very
-	 * unlikely that an RRset goes from ANCIENT to STALE), this
-	 * will decrement the ancient stale type counter, otherwise it
-	 * decrements the active stats type counter.
-	 */
-
-	update_rrsetstats(rbtdb, header->type, attributes, false);
-	update_rrsetstats(rbtdb, header->type, newattributes, true);
 }
 
 static void
@@ -1698,7 +1560,7 @@ clean_zone_node(dns_rbtdb_t *rbtdb, dns_rbtnode_t *node,
 			down_next = dcurrent->down;
 			INSIST(dcurrent->serial <= dparent->serial);
 			if (dcurrent->serial == dparent->serial ||
-			    IGNORE(dcurrent))
+			    ISC_IGNORE(dcurrent))
 			{
 				if (down_next != NULL) {
 					down_next->next = dparent;
@@ -1714,7 +1576,7 @@ clean_zone_node(dns_rbtdb_t *rbtdb, dns_rbtnode_t *node,
 		 * We've now eliminated all IGNORE datasets with the possible
 		 * exception of current, which we now check.
 		 */
-		if (IGNORE(current)) {
+		if (ISC_IGNORE(current)) {
 			down_next = current->down;
 			if (down_next == NULL) {
 				if (top_prev != NULL) {
@@ -2336,7 +2198,6 @@ static void
 iszonesecure(dns_db_t *db, rbtdb_version_t *version, dns_dbnode_t *origin) {
 	dns_rdataset_t keyset;
 	dns_rdataset_t nsecset, signsecset;
-	bool haszonekey = false;
 	bool hasnsec = false;
 	isc_result_t result;
 
@@ -2350,19 +2211,13 @@ iszonesecure(dns_db_t *db, rbtdb_version_t *version, dns_dbnode_t *origin) {
 		while (result == ISC_R_SUCCESS) {
 			dns_rdata_t keyrdata = DNS_RDATA_INIT;
 			dns_rdataset_current(&keyset, &keyrdata);
-			if (dns_zonekey_iszonekey(&keyrdata)) {
-				haszonekey = true;
-				break;
-			}
 			result = dns_rdataset_next(&keyset);
 		}
 		dns_rdataset_disassociate(&keyset);
 	}
-	if (!haszonekey) {
-		version->secure = dns_db_insecure;
-		version->havensec3 = false;
-		return;
-	}
+	version->secure = dns_db_insecure;
+	version->havensec3 = false;
+	return;
 
 	dns_rdataset_init(&nsecset);
 	dns_rdataset_init(&signsecset);
@@ -2376,8 +2231,6 @@ iszonesecure(dns_db_t *db, rbtdb_version_t *version, dns_dbnode_t *origin) {
 		dns_rdataset_disassociate(&nsecset);
 	}
 
-	setnsec3parameters(db, version);
-
 	/*
 	 * Do we have a valid NSEC/NSEC3 chain?
 	 */
@@ -2388,98 +2241,6 @@ iszonesecure(dns_db_t *db, rbtdb_version_t *version, dns_dbnode_t *origin) {
 	}
 }
 
-/*%<
- * Walk the origin node looking for NSEC3PARAM records.
- * Cache the nsec3 parameters.
- */
-static void
-setnsec3parameters(dns_db_t *db, rbtdb_version_t *version) {
-	dns_rbtnode_t *node;
-	dns_rdata_nsec3param_t nsec3param;
-	dns_rdata_t rdata = DNS_RDATA_INIT;
-	isc_region_t region;
-	isc_result_t result;
-	rdatasetheader_t *header, *header_next;
-	unsigned char *raw; /* RDATASLAB */
-	unsigned int count, length;
-	dns_rbtdb_t *rbtdb = (dns_rbtdb_t *)db;
-
-	RWLOCK(&rbtdb->tree_lock, isc_rwlocktype_read);
-	version->havensec3 = false;
-	node = rbtdb->origin_node;
-	NODE_LOCK(&(rbtdb->node_locks[node->locknum].lock),
-		  isc_rwlocktype_read);
-	for (header = node->data; header != NULL; header = header_next) {
-		header_next = header->next;
-		do {
-			if (header->serial <= version->serial &&
-			    !IGNORE(header))
-			{
-				if (NONEXISTENT(header)) {
-					header = NULL;
-				}
-				break;
-			} else {
-				header = header->down;
-			}
-		} while (header != NULL);
-
-		if (header != NULL &&
-		    (header->type == dns_rdatatype_nsec3param))
-		{
-			/*
-			 * Find A NSEC3PARAM with a supported algorithm.
-			 */
-			raw = (unsigned char *)header + sizeof(*header);
-			count = raw[0] * 256 + raw[1]; /* count */
-			raw += DNS_RDATASET_COUNT + DNS_RDATASET_LENGTH;
-			while (count-- > 0U) {
-				length = raw[0] * 256 + raw[1];
-				raw += DNS_RDATASET_ORDER + DNS_RDATASET_LENGTH;
-				region.base = raw;
-				region.length = length;
-				raw += length;
-				dns_rdata_fromregion(
-					&rdata, rbtdb->common.rdclass,
-					dns_rdatatype_nsec3param, &region);
-				result = dns_rdata_tostruct(&rdata, &nsec3param,
-							    NULL);
-				INSIST(result == ISC_R_SUCCESS);
-				dns_rdata_reset(&rdata);
-
-				if (nsec3param.hash != DNS_NSEC3_UNKNOWNALG &&
-				    !dns_nsec3_supportedhash(nsec3param.hash))
-				{
-					continue;
-				}
-
-				if (nsec3param.flags != 0) {
-					continue;
-				}
-
-				memmove(version->salt, nsec3param.salt,
-					nsec3param.salt_length);
-				version->hash = nsec3param.hash;
-				version->salt_length = nsec3param.salt_length;
-				version->iterations = nsec3param.iterations;
-				version->flags = nsec3param.flags;
-				version->havensec3 = true;
-				/*
-				 * Look for a better algorithm than the
-				 * unknown test algorithm.
-				 */
-				if (nsec3param.hash != DNS_NSEC3_UNKNOWNALG) {
-					goto unlock;
-				}
-			}
-		}
-	}
-unlock:
-	NODE_UNLOCK(&(rbtdb->node_locks[node->locknum].lock),
-		    isc_rwlocktype_read);
-	RWUNLOCK(&rbtdb->tree_lock, isc_rwlocktype_read);
-}
-
 static void
 cleanup_dead_nodes_callback(isc_task_t *task, isc_event_t *event) {
 	dns_rbtdb_t *rbtdb = event->ev_arg;
@@ -2702,7 +2463,7 @@ closeversion(dns_db_t *db, dns_dbversion_t **versionp, bool commit) {
 
 		lock = &rbtdb->node_locks[header->node->locknum].lock;
 		NODE_LOCK(lock, isc_rwlocktype_write);
-		if (rollback && !IGNORE(header)) {
+		if (rollback && !ISC_IGNORE(header)) {
 			resign_insert(rbtdb, header->node->locknum, header);
 		}
 		dns__rbtnode_release(rbtdb, header->node, least_serial,
@@ -2988,7 +2749,7 @@ zone_zonecut_callback(dns_rbtnode_t *node, dns_name_t *name, void *arg) {
 		{
 			do {
 				if (header->serial <= search->serial &&
-				    !IGNORE(header))
+				    !ISC_IGNORE(header))
 				{
 					/*
 					 * Is this a "this rdataset doesn't
@@ -3375,7 +3136,7 @@ activeempty(rbtdb_search_t *search, dns_rbtnodechain_t *chain,
 		for (header = node->data; header != NULL; header = header->next)
 		{
 			if (header->serial <= search->serial &&
-			    !IGNORE(header) && EXISTS(header))
+			    !ISC_IGNORE(header) && EXISTS(header))
 			{
 				break;
 			}
@@ -3444,7 +3205,7 @@ activeemptynode(rbtdb_search_t *search, const dns_name_t *qname,
 		for (header = node->data; header != NULL; header = header->next)
 		{
 			if (header->serial <= search->serial &&
-			    !IGNORE(header) && EXISTS(header))
+			    !ISC_IGNORE(header) && EXISTS(header))
 			{
 				break;
 			}
@@ -3475,7 +3236,7 @@ activeemptynode(rbtdb_search_t *search, const dns_name_t *qname,
 		for (header = node->data; header != NULL; header = header->next)
 		{
 			if (header->serial <= search->serial &&
-			    !IGNORE(header) && EXISTS(header))
+			    !ISC_IGNORE(header) && EXISTS(header))
 			{
 				break;
 			}
@@ -3564,7 +3325,7 @@ find_wildcard(rbtdb_search_t *search, dns_rbtnode_t **nodep,
 		for (header = node->data; header != NULL; header = header->next)
 		{
 			if (header->serial <= search->serial &&
-			    !IGNORE(header) && EXISTS(header) &&
+			    !ISC_IGNORE(header) && EXISTS(header) &&
 			    !ANCIENT(header))
 			{
 				break;
@@ -3626,7 +3387,7 @@ find_wildcard(rbtdb_search_t *search, dns_rbtnode_t **nodep,
 				     header = header->next)
 				{
 					if (header->serial <= search->serial &&
-					    !IGNORE(header) && EXISTS(header) &&
+					    !ISC_IGNORE(header) && EXISTS(header) &&
 					    !ANCIENT(header))
 					{
 						break;
@@ -3706,15 +3467,7 @@ matchparams(rdatasetheader_t *header, rbtdb_search_t *search) {
 		raw += rdlen;
 		result = dns_rdata_tostruct(&rdata, &nsec3, NULL);
 		INSIST(result == ISC_R_SUCCESS);
-		if (nsec3.hash == search->rbtversion->hash &&
-		    nsec3.iterations == search->rbtversion->iterations &&
-		    nsec3.salt_length == search->rbtversion->salt_length &&
-		    memcmp(nsec3.salt, search->rbtversion->salt,
-			   nsec3.salt_length) == 0)
-		{
-			return true;
-		}
-		dns_rdata_reset(&rdata);
+		return true;
 	}
 	return false;
 }
@@ -3894,7 +3647,7 @@ again:
 			 */
 			do {
 				if (header->serial <= search->serial &&
-				    !IGNORE(header))
+				    !ISC_IGNORE(header))
 				{
 					/*
 					 * Is this a "this rdataset doesn't
@@ -4223,7 +3976,7 @@ found:
 		 * Look for an active, extant rdataset.
 		 */
 		do {
-			if (header->serial <= search.serial && !IGNORE(header))
+			if (header->serial <= search.serial && !ISC_IGNORE(header))
 			{
 				/*
 				 * Is this a "this rdataset doesn't
@@ -5447,7 +5200,6 @@ tree_exit:
 
 	dns_rbtnodechain_reset(&search.chain);
 
-	update_cachestats(search.rbtdb, result);
 	return result;
 }
 
@@ -5926,7 +5678,7 @@ zone_findrdataset(dns_db_t *db, dns_dbnode_t *node, dns_dbversion_t *version,
 	for (header = rbtnode->data; header != NULL; header = header_next) {
 		header_next = header->next;
 		do {
-			if (header->serial <= serial && !IGNORE(header)) {
+			if (header->serial <= serial && !ISC_IGNORE(header)) {
 				/*
 				 * Is this a "this rdataset doesn't
 				 * exist" record?
@@ -6080,8 +5832,6 @@ cache_findrdataset(dns_db_t *db, dns_dbnode_t *node, dns_dbversion_t *version,
 		}
 	}
 
-	update_cachestats(rbtdb, result);
-
 	return result;
 }
 
@@ -6152,7 +5902,7 @@ cname_and_other_data(dns_rbtnode_t *node, rbtdb_serial_t serial) {
 			 * Look for an active extant CNAME.
 			 */
 			do {
-				if (header->serial <= serial && !IGNORE(header))
+				if (header->serial <= serial && !ISC_IGNORE(header))
 				{
 					/*
 					 * Is this a "this rdataset doesn't
@@ -6187,7 +5937,7 @@ cname_and_other_data(dns_rbtnode_t *node, rbtdb_serial_t serial) {
 				 */
 				do {
 					if (header->serial <= serial &&
-					    !IGNORE(header))
+					    !ISC_IGNORE(header))
 					{
 						/*
 						 * Is this a "this rdataset
@@ -6481,7 +6231,7 @@ find_header:
 	 * data.  We skip over them.
 	 */
 	header = topheader;
-	while (header != NULL && IGNORE(header)) {
+	while (header != NULL && ISC_IGNORE(header)) {
 		header = header->down;
 	}
 	if (header != NULL) {
@@ -7214,13 +6964,6 @@ addrdataset(dns_db_t *db, dns_dbnode_t *node, dns_dbversion_t *version,
 	NODE_LOCK(&rbtdb->node_locks[rbtnode->locknum].lock,
 		  isc_rwlocktype_write);
 
-	if (rbtdb->rrsetstats != NULL) {
-		RDATASET_ATTR_SET(newheader, RDATASET_ATTR_STATCOUNT);
-		update_rrsetstats(rbtdb, newheader->type,
-				  atomic_load_acquire(&newheader->attributes),
-				  true);
-	}
-
 	if (IS_CACHE(rbtdb)) {
 		if (tree_locked) {
 			cleanup_dead_nodes(rbtdb, rbtnode->locknum);
@@ -7360,7 +7103,7 @@ subtractrdataset(dns_db_t *db, dns_dbnode_t *node, dns_dbversion_t *version,
 	 * data.  We skip over them.
 	 */
 	header = topheader;
-	while (header != NULL && IGNORE(header)) {
+	while (header != NULL && ISC_IGNORE(header)) {
 		header = header->down;
 	}
 	if (header != NULL && EXISTS(header)) {
@@ -7974,49 +7717,6 @@ getoriginnode(dns_db_t *db, dns_dbnode_t **nodep) {
 	return result;
 }
 
-static isc_result_t
-getnsec3parameters(dns_db_t *db, dns_dbversion_t *version, dns_hash_t *hash,
-		   uint8_t *flags, uint16_t *iterations, unsigned char *salt,
-		   size_t *salt_length) {
-	dns_rbtdb_t *rbtdb;
-	isc_result_t result = ISC_R_NOTFOUND;
-	rbtdb_version_t *rbtversion = version;
-
-	rbtdb = (dns_rbtdb_t *)db;
-
-	REQUIRE(VALID_RBTDB(rbtdb));
-	INSIST(rbtversion == NULL || rbtversion->rbtdb == rbtdb);
-
-	RBTDB_LOCK(&rbtdb->lock, isc_rwlocktype_read);
-	if (rbtversion == NULL) {
-		rbtversion = rbtdb->current_version;
-	}
-
-	if (rbtversion->havensec3) {
-		if (hash != NULL) {
-			*hash = rbtversion->hash;
-		}
-		if (salt != NULL && salt_length != NULL) {
-			REQUIRE(*salt_length >= rbtversion->salt_length);
-			memmove(salt, rbtversion->salt,
-				rbtversion->salt_length);
-		}
-		if (salt_length != NULL) {
-			*salt_length = rbtversion->salt_length;
-		}
-		if (iterations != NULL) {
-			*iterations = rbtversion->iterations;
-		}
-		if (flags != NULL) {
-			*flags = rbtversion->flags;
-		}
-		result = ISC_R_SUCCESS;
-	}
-	RBTDB_UNLOCK(&rbtdb->lock, isc_rwlocktype_read);
-
-	return result;
-}
-
 static isc_result_t
 getsize(dns_db_t *db, dns_dbversion_t *version, uint64_t *records,
 	uint64_t *xfrsize) {
@@ -8211,30 +7911,6 @@ resigned(dns_db_t *db, dns_rdataset_t *rdataset, dns_dbversion_t *version) {
 	RWUNLOCK(&rbtdb->tree_lock, isc_rwlocktype_write);
 }
 
-static isc_result_t
-setcachestats(dns_db_t *db, isc_stats_t *stats) {
-	dns_rbtdb_t *rbtdb = (dns_rbtdb_t *)db;
-
-	REQUIRE(VALID_RBTDB(rbtdb));
-	REQUIRE(IS_CACHE(rbtdb)); /* current restriction */
-	REQUIRE(stats != NULL);
-
-	isc_stats_attach(stats, &rbtdb->cachestats);
-	return ISC_R_SUCCESS;
-}
-
-static isc_result_t
-setgluecachestats(dns_db_t *db, isc_stats_t *stats) {
-	dns_rbtdb_t *rbtdb = (dns_rbtdb_t *)db;
-
-	REQUIRE(VALID_RBTDB(rbtdb));
-	REQUIRE(!IS_CACHE(rbtdb) && !IS_STUB(rbtdb));
-	REQUIRE(stats != NULL);
-
-	isc_stats_attach(stats, &rbtdb->gluecachestats);
-	return ISC_R_SUCCESS;
-}
-
 static void
 setmaxrrperset(dns_db_t *db, uint32_t maxrrperset) {
 	dns_rbtdb_t *rbtdb = (dns_rbtdb_t *)db;
@@ -8253,16 +7929,6 @@ setmaxtypepername(dns_db_t *db, uint32_t maxtypepername) {
 	rbtdb->maxtypepername = maxtypepername;
 }
 
-static dns_stats_t *
-getrrsetstats(dns_db_t *db) {
-	dns_rbtdb_t *rbtdb = (dns_rbtdb_t *)db;
-
-	REQUIRE(VALID_RBTDB(rbtdb));
-	REQUIRE(IS_CACHE(rbtdb)); /* current restriction */
-
-	return rbtdb->rrsetstats;
-}
-
 static isc_result_t
 nodefullname(dns_db_t *db, dns_dbnode_t *node, dns_name_t *name) {
 	dns_rbtdb_t *rbtdb = (dns_rbtdb_t *)db;
@@ -8355,18 +8021,15 @@ static dns_dbmethods_t zone_methods = { attach,
 					settask,
 					getoriginnode,
 					NULL, /* transfernode */
-					getnsec3parameters,
 					findnsec3node,
 					setsigningtime,
 					getsigningtime,
 					resigned,
 					isdnssec,
-					NULL, /* getrrsetstats */
 					NULL, /* rpz_attach */
 					NULL, /* rpz_ready */
 					NULL, /* findnodeext */
 					NULL, /* findext */
-					NULL, /* setcachestats */
 					hashsize,
 					nodefullname,
 					getsize,
@@ -8374,7 +8037,6 @@ static dns_dbmethods_t zone_methods = { attach,
 					NULL, /* getservestalettl */
 					NULL, /* setservestalerefresh */
 					NULL, /* getservestalerefresh */
-					setgluecachestats,
 					setmaxrrperset,
 					setmaxtypepername };
 
@@ -8407,18 +8069,15 @@ static dns_dbmethods_t cache_methods = { attach,
 					 settask,
 					 getoriginnode,
 					 NULL, /* transfernode */
-					 NULL, /* getnsec3parameters */
 					 NULL, /* findnsec3node */
 					 NULL, /* setsigningtime */
 					 NULL, /* getsigningtime */
 					 NULL, /* resigned */
 					 isdnssec,
-					 getrrsetstats,
 					 NULL, /* rpz_attach */
 					 NULL, /* rpz_ready */
 					 NULL, /* findnodeext */
 					 NULL, /* findext */
-					 setcachestats,
 					 hashsize,
 					 nodefullname,
 					 NULL, /* getsize */
@@ -8426,7 +8085,6 @@ static dns_dbmethods_t cache_methods = { attach,
 					 getservestalettl,
 					 setservestalerefresh,
 					 getservestalerefresh,
-					 NULL,
 					 setmaxrrperset,
 					 setmaxtypepername };
 
@@ -8494,25 +8152,6 @@ dns_rbtdb_create(isc_mem_t *mctx, const dns_name_t *origin, dns_dbtype_t type,
 	rbtdb->node_locks = isc_mem_get(mctx, rbtdb->node_lock_count *
 						      sizeof(rbtdb_nodelock_t));
 
-	rbtdb->cachestats = NULL;
-	rbtdb->gluecachestats = NULL;
-
-	rbtdb->rrsetstats = NULL;
-	if (IS_CACHE(rbtdb)) {
-		result = dns_rdatasetstats_create(mctx, &rbtdb->rrsetstats);
-		if (result != ISC_R_SUCCESS) {
-			goto cleanup_node_locks;
-		}
-		rbtdb->rdatasets = isc_mem_get(
-			mctx,
-			rbtdb->node_lock_count * sizeof(rdatasetheaderlist_t));
-		for (i = 0; i < (int)rbtdb->node_lock_count; i++) {
-			ISC_LIST_INIT(rbtdb->rdatasets[i]);
-		}
-	} else {
-		rbtdb->rdatasets = NULL;
-	}
-
 	/*
 	 * Create the heaps.
 	 */
@@ -8655,12 +8294,6 @@ dns_rbtdb_create(isc_mem_t *mctx, const dns_name_t *origin, dns_dbtype_t type,
 	rbtdb->current_version->rbtdb = rbtdb;
 	rbtdb->current_version->secure = dns_db_insecure;
 	rbtdb->current_version->havensec3 = false;
-	rbtdb->current_version->flags = 0;
-	rbtdb->current_version->iterations = 0;
-	rbtdb->current_version->hash = 0;
-	rbtdb->current_version->salt_length = 0;
-	memset(rbtdb->current_version->salt, 0,
-	       sizeof(rbtdb->current_version->salt));
 	isc_rwlock_init(&rbtdb->current_version->rwlock, 0, 0);
 	rbtdb->current_version->records = 0;
 	rbtdb->current_version->xfrsize = 0;
@@ -8679,7 +8312,6 @@ dns_rbtdb_create(isc_mem_t *mctx, const dns_name_t *origin, dns_dbtype_t type,
 
 	return ISC_R_SUCCESS;
 
-cleanup_node_locks:
 	isc_mem_put(mctx, rbtdb->node_locks,
 		    rbtdb->node_lock_count * sizeof(rbtdb_nodelock_t));
 
@@ -9036,7 +8668,7 @@ rdatasetiter_first(dns_rdatasetiter_t *iterator) {
 					break;
 				}
 				header = header->down;
-			} else if (header->serial <= serial && !IGNORE(header))
+			} else if (header->serial <= serial && !ISC_IGNORE(header))
 			{
 				if (!iterator_active(rbtdb, rbtiterator,
 						     header))
@@ -9121,7 +8753,7 @@ rdatasetiter_next(dns_rdatasetiter_t *iterator) {
 					break;
 				}
 				header = header->down;
-			} else if (header->serial <= serial && !IGNORE(header))
+			} else if (header->serial <= serial && !ISC_IGNORE(header))
 			{
 				if (!iterator_active(rbtdb, rbtiterator,
 						     header))
@@ -10218,18 +9850,7 @@ restart:
 	 * present in the zone.
 	 */
 	if (ge == (void *)-1) {
-		if (!restarted && (rbtdb->gluecachestats != NULL)) {
-			isc_stats_increment(
-				rbtdb->gluecachestats,
-				dns_gluecachestatscounter_hits_absent);
-		}
 		goto no_glue;
-	} else {
-		if (!restarted && (rbtdb->gluecachestats != NULL)) {
-			isc_stats_increment(
-				rbtdb->gluecachestats,
-				dns_gluecachestatscounter_hits_present);
-		}
 	}
 
 	for (; ge != NULL; ge = ge->next) {
@@ -10376,18 +9997,8 @@ no_glue:
 		 * No glue was found. Cache it so.
 		 */
 		cur->glue_list = (void *)-1;
-		if (rbtdb->gluecachestats != NULL) {
-			isc_stats_increment(
-				rbtdb->gluecachestats,
-				dns_gluecachestatscounter_inserts_absent);
-		}
 	} else {
 		cur->glue_list = ctx.glue_list;
-		if (rbtdb->gluecachestats != NULL) {
-			isc_stats_increment(
-				rbtdb->gluecachestats,
-				dns_gluecachestatscounter_inserts_present);
-		}
 	}
 
 	cur->next = rbtversion->glue_table[idx];
@@ -10570,6 +10181,8 @@ expire_header(dns_rbtdb_t *rbtdb, rdatasetheader_t *header, bool tree_locked,
 	set_ttl(rbtdb, header, 0);
 	mark_header_ancient(rbtdb, header);
 
+	UNUSED(reason);
+
 	/*
 	 * Caller must hold the node (write) lock.
 	 */
@@ -10586,23 +10199,6 @@ expire_header(dns_rbtdb_t *rbtdb, rdatasetheader_t *header, bool tree_locked,
 				     tree_locked ? isc_rwlocktype_write
 						 : isc_rwlocktype_none,
 				     false);
-
-		if (rbtdb->cachestats == NULL) {
-			return;
-		}
-
-		switch (reason) {
-		case expire_ttl:
-			isc_stats_increment(rbtdb->cachestats,
-					    dns_cachestatscounter_deletettl);
-			break;
-		case expire_lru:
-			isc_stats_increment(rbtdb->cachestats,
-					    dns_cachestatscounter_deletelru);
-			break;
-		default:
-			break;
-		}
 	}
 }
 
diff --git a/lib/dns/rdata/generic/naptr_35.c b/lib/dns/rdata/generic/naptr_35.c
--- a/lib/dns/rdata/generic/naptr_35.c
+++ b/lib/dns/rdata/generic/naptr_35.c
@@ -18,15 +18,12 @@
 
 #define RRTYPE_NAPTR_ATTRIBUTES (0)
 
-#include <isc/regex.h>
-
 /*
  * Check the wire format of the Regexp field.
  * Don't allow embedded NUL's.
  */
 static isc_result_t
 txt_valid_regex(const unsigned char *txt) {
-	unsigned int nsub = 0;
 	char regex[256];
 	char *cp;
 	bool flags = false;
@@ -34,7 +31,6 @@ txt_valid_regex(const unsigned char *txt) {
 	unsigned char c;
 	unsigned char delim;
 	unsigned int len;
-	int n;
 
 	len = *txt++;
 	if (len == 0U) {
@@ -106,51 +102,6 @@ txt_valid_regex(const unsigned char *txt) {
 				switch (c) {
 				case '0':
 					return DNS_R_SYNTAX;
-				case '1':
-					if (nsub < 1) {
-						nsub = 1;
-					}
-					break;
-				case '2':
-					if (nsub < 2) {
-						nsub = 2;
-					}
-					break;
-				case '3':
-					if (nsub < 3) {
-						nsub = 3;
-					}
-					break;
-				case '4':
-					if (nsub < 4) {
-						nsub = 4;
-					}
-					break;
-				case '5':
-					if (nsub < 5) {
-						nsub = 5;
-					}
-					break;
-				case '6':
-					if (nsub < 6) {
-						nsub = 6;
-					}
-					break;
-				case '7':
-					if (nsub < 7) {
-						nsub = 7;
-					}
-					break;
-				case '8':
-					if (nsub < 8) {
-						nsub = 8;
-					}
-					break;
-				case '9':
-					if (nsub < 9) {
-						nsub = 9;
-					}
-					break;
 				}
 			}
 			if (!replace) {
@@ -162,10 +113,6 @@ txt_valid_regex(const unsigned char *txt) {
 		return DNS_R_SYNTAX;
 	}
 	*cp = '\0';
-	n = isc_regex_validate(regex);
-	if (n < 0 || nsub > (unsigned int)n) {
-		return DNS_R_SYNTAX;
-	}
 	return ISC_R_SUCCESS;
 }
 
diff --git a/lib/dns/rdatalist.c b/lib/dns/rdatalist.c
--- a/lib/dns/rdatalist.c
+++ b/lib/dns/rdatalist.c
@@ -19,7 +19,6 @@
 #include <isc/util.h>
 
 #include <dns/name.h>
-#include <dns/nsec3.h>
 #include <dns/rdata.h>
 #include <dns/rdatalist.h>
 #include <dns/rdataset.h>
diff --git a/lib/dns/tkey.c b/lib/dns/tkey.c
--- a/lib/dns/tkey.c
+++ b/lib/dns/tkey.c
@@ -16,12 +16,6 @@
 #include <inttypes.h>
 #include <stdbool.h>
 
-#if HAVE_GSSAPI_GSSAPI_H
-#include <gssapi/gssapi.h>
-#elif HAVE_GSSAPI_H
-#include <gssapi.h>
-#endif
-
 #include <isc/buffer.h>
 #include <isc/md.h>
 #include <isc/mem.h>
@@ -47,7 +41,6 @@
 #include <dns/tsig.h>
 
 #include <dst/dst.h>
-#include <dst/gssapi.h>
 
 #include "dst_internal.h"
 
@@ -74,40 +67,6 @@ tkey_log(const char *fmt, ...) {
 	va_end(ap);
 }
 
-static void
-dumpmessage(dns_message_t *msg) {
-	isc_buffer_t outbuf;
-	unsigned char *output;
-	int len = TEMP_BUFFER_SZ;
-	isc_result_t result;
-
-	for (;;) {
-		output = isc_mem_get(msg->mctx, len);
-
-		isc_buffer_init(&outbuf, output, len);
-		result = dns_message_totext(msg, &dns_master_style_debug, 0,
-					    &outbuf);
-		if (result == ISC_R_NOSPACE) {
-			isc_mem_put(msg->mctx, output, len);
-			len *= 2;
-			continue;
-		}
-
-		if (result == ISC_R_SUCCESS) {
-			tkey_log("%.*s", (int)isc_buffer_usedlength(&outbuf),
-				 (char *)isc_buffer_base(&outbuf));
-		} else {
-			tkey_log("Warning: dns_message_totext: %s",
-				 isc_result_totext(result));
-		}
-		break;
-	}
-
-	if (output != NULL) {
-		isc_mem_put(msg->mctx, output, len);
-	}
-}
-
 isc_result_t
 dns_tkeyctx_create(isc_mem_t *mctx, dns_tkeyctx_t **tctxp) {
 	dns_tkeyctx_t *tctx;
@@ -120,8 +79,6 @@ dns_tkeyctx_create(isc_mem_t *mctx, dns_tkeyctx_t **tctxp) {
 	isc_mem_attach(mctx, &tctx->mctx);
 	tctx->dhkey = NULL;
 	tctx->domain = NULL;
-	tctx->gsscred = NULL;
-	tctx->gssapi_keytab = NULL;
 
 	*tctxp = tctx;
 	return ISC_R_SUCCESS;
@@ -147,12 +104,6 @@ dns_tkeyctx_destroy(dns_tkeyctx_t **tctxp) {
 		}
 		isc_mem_put(mctx, tctx->domain, sizeof(dns_name_t));
 	}
-	if (tctx->gssapi_keytab != NULL) {
-		isc_mem_free(mctx, tctx->gssapi_keytab);
-	}
-	if (tctx->gsscred != NULL) {
-		dst_gssapi_releasecred(&tctx->gsscred);
-	}
 	isc_mem_putanddetach(&mctx, tctx, sizeof(dns_tkeyctx_t));
 }
 
@@ -500,164 +451,6 @@ failure:
 	return result;
 }
 
-static isc_result_t
-process_gsstkey(dns_message_t *msg, dns_name_t *name, dns_rdata_tkey_t *tkeyin,
-		dns_tkeyctx_t *tctx, dns_rdata_tkey_t *tkeyout,
-		dns_tsig_keyring_t *ring) {
-	isc_result_t result = ISC_R_SUCCESS;
-	dst_key_t *dstkey = NULL;
-	dns_tsigkey_t *tsigkey = NULL;
-	dns_fixedname_t fixed;
-	dns_name_t *principal;
-	isc_stdtime_t now;
-	isc_region_t intoken;
-	isc_buffer_t *outtoken = NULL;
-	dns_gss_ctx_id_t gss_ctx = NULL;
-
-	/*
-	 * You have to define either a gss credential (principal) to
-	 * accept with tkey-gssapi-credential, or you have to
-	 * configure a specific keytab (with tkey-gssapi-keytab) in
-	 * order to use gsstkey.
-	 */
-	if (tctx->gsscred == NULL && tctx->gssapi_keytab == NULL) {
-		tkey_log("process_gsstkey(): no tkey-gssapi-credential "
-			 "or tkey-gssapi-keytab configured");
-		return DNS_R_REFUSED;
-	}
-
-	if (!dns_name_equal(&tkeyin->algorithm, DNS_TSIG_GSSAPI_NAME) &&
-	    !dns_name_equal(&tkeyin->algorithm, DNS_TSIG_GSSAPIMS_NAME))
-	{
-		tkeyout->error = dns_tsigerror_badalg;
-		tkey_log("process_gsstkey(): dns_tsigerror_badalg"); /* XXXSRA
-								      */
-		return ISC_R_SUCCESS;
-	}
-
-	/*
-	 * XXXDCL need to check for key expiry per 4.1.1
-	 * XXXDCL need a way to check fully established, perhaps w/key_flags
-	 */
-
-	intoken.base = tkeyin->key;
-	intoken.length = tkeyin->keylen;
-
-	result = dns_tsigkey_find(&tsigkey, name, &tkeyin->algorithm, ring);
-	if (result == ISC_R_SUCCESS) {
-		gss_ctx = dst_key_getgssctx(tsigkey->key);
-	}
-
-	principal = dns_fixedname_initname(&fixed);
-
-	/*
-	 * Note that tctx->gsscred may be NULL if tctx->gssapi_keytab is set
-	 */
-	result = dst_gssapi_acceptctx(tctx->gsscred, tctx->gssapi_keytab,
-				      &intoken, &outtoken, &gss_ctx, principal,
-				      tctx->mctx);
-	if (result == DNS_R_INVALIDTKEY) {
-		if (tsigkey != NULL) {
-			dns_tsigkey_detach(&tsigkey);
-		}
-		tkeyout->error = dns_tsigerror_badkey;
-		tkey_log("process_gsstkey(): dns_tsigerror_badkey"); /* XXXSRA
-								      */
-		return ISC_R_SUCCESS;
-	}
-	if (result != DNS_R_CONTINUE && result != ISC_R_SUCCESS) {
-		goto failure;
-	}
-	/*
-	 * XXXDCL Section 4.1.3: Limit GSS_S_CONTINUE_NEEDED to 10 times.
-	 */
-
-	isc_stdtime_get(&now);
-
-	if (dns_name_countlabels(principal) == 0U) {
-		if (tsigkey != NULL) {
-			dns_tsigkey_detach(&tsigkey);
-		}
-	} else if (tsigkey == NULL) {
-#if HAVE_GSSAPI
-		OM_uint32 gret, minor, lifetime;
-#endif /* HAVE_GSSAPI */
-		uint32_t expire;
-
-		RETERR(dst_key_fromgssapi(name, gss_ctx, ring->mctx, &dstkey,
-					  &intoken));
-		/*
-		 * Limit keys to 1 hour or the context's lifetime whichever
-		 * is smaller.
-		 */
-		expire = now + 3600;
-#if HAVE_GSSAPI
-		gret = gss_context_time(&minor, gss_ctx, &lifetime);
-		if (gret == GSS_S_COMPLETE && now + lifetime < expire) {
-			expire = now + lifetime;
-		}
-#endif /* HAVE_GSSAPI */
-		RETERR(dns_tsigkey_createfromkey(
-			name, &tkeyin->algorithm, dstkey, true, principal, now,
-			expire, ring->mctx, ring, &tsigkey));
-		dst_key_free(&dstkey);
-		tkeyout->inception = now;
-		tkeyout->expire = expire;
-	} else {
-		tkeyout->inception = tsigkey->inception;
-		tkeyout->expire = tsigkey->expire;
-	}
-
-	if (outtoken) {
-		tkeyout->key = isc_mem_get(tkeyout->mctx,
-					   isc_buffer_usedlength(outtoken));
-		tkeyout->keylen = isc_buffer_usedlength(outtoken);
-		memmove(tkeyout->key, isc_buffer_base(outtoken),
-			isc_buffer_usedlength(outtoken));
-		isc_buffer_free(&outtoken);
-	} else {
-		tkeyout->key = isc_mem_get(tkeyout->mctx, tkeyin->keylen);
-		tkeyout->keylen = tkeyin->keylen;
-		memmove(tkeyout->key, tkeyin->key, tkeyin->keylen);
-	}
-
-	tkeyout->error = dns_rcode_noerror;
-
-	tkey_log("process_gsstkey(): dns_tsigerror_noerror"); /* XXXSRA */
-
-	/*
-	 * We found a TKEY to respond with.  If the request is not TSIG signed,
-	 * we need to make sure the response is signed (see RFC 3645, Section
-	 * 2.2).
-	 */
-	if (tsigkey != NULL) {
-		if (msg->tsigkey == NULL && msg->sig0key == NULL) {
-			dns_message_settsigkey(msg, tsigkey);
-		}
-		dns_tsigkey_detach(&tsigkey);
-	}
-
-	return ISC_R_SUCCESS;
-
-failure:
-	if (tsigkey != NULL) {
-		dns_tsigkey_detach(&tsigkey);
-	}
-
-	if (dstkey != NULL) {
-		dst_key_free(&dstkey);
-	}
-
-	if (outtoken != NULL) {
-		isc_buffer_free(&outtoken);
-	}
-
-	tkey_log("process_gsstkey(): %s", isc_result_totext(result)); /* XXXSRA
-								       */
-
-	return result;
-}
-
 static isc_result_t
 process_deletetkey(dns_name_t *signer, dns_name_t *name,
 		   dns_rdata_tkey_t *tkeyin, dns_rdata_tkey_t *tkeyout,
@@ -765,23 +558,13 @@ dns_tkey_processquery(dns_message_t *msg, dns_tkeyctx_t *tctx,
 		goto failure;
 	}
 
-	/*
-	 * Before we go any farther, verify that the message was signed.
-	 * GSSAPI TKEY doesn't require a signature, the rest do.
-	 */
 	dns_name_init(&tsigner, NULL);
 	result = dns_message_signer(msg, &tsigner);
 	if (result != ISC_R_SUCCESS) {
-		if (tkeyin.mode == DNS_TKEYMODE_GSSAPI &&
-		    result == ISC_R_NOTFOUND)
-		{
-			signer = NULL;
-		} else {
-			tkey_log("dns_tkey_processquery: query was not "
-				 "properly signed - rejecting");
-			result = DNS_R_FORMERR;
-			goto failure;
-		}
+		tkey_log("dns_tkey_processquery: query was not "
+			 "properly signed - rejecting");
+		result = DNS_R_FORMERR;
+		goto failure;
 	} else {
 		signer = &tsigner;
 	}
@@ -811,8 +594,7 @@ dns_tkey_processquery(dns_message_t *msg, dns_tkeyctx_t *tctx,
 	if (tkeyin.mode != DNS_TKEYMODE_DELETE) {
 		dns_tsigkey_t *tsigkey = NULL;
 
-		if (tctx->domain == NULL && tkeyin.mode != DNS_TKEYMODE_GSSAPI)
-		{
+		if (tctx->domain == NULL) {
 			tkey_log("dns_tkey_processquery: tkey-domain not set");
 			result = DNS_R_REFUSED;
 			goto failure;
@@ -849,19 +631,10 @@ dns_tkey_processquery(dns_message_t *msg, dns_tkeyctx_t *tctx,
 			}
 		}
 
-		if (tkeyin.mode == DNS_TKEYMODE_GSSAPI) {
-			/* Yup.  This is a hack */
-			result = dns_name_concatenate(keyname, dns_rootname,
-						      keyname, NULL);
-			if (result != ISC_R_SUCCESS) {
-				goto failure;
-			}
-		} else {
-			result = dns_name_concatenate(keyname, tctx->domain,
-						      keyname, NULL);
-			if (result != ISC_R_SUCCESS) {
-				goto failure;
-			}
+		result = dns_name_concatenate(keyname, tctx->domain,
+					      keyname, NULL);
+		if (result != ISC_R_SUCCESS) {
+			goto failure;
 		}
 
 		result = dns_tsigkey_find(&tsigkey, keyname, NULL, ring);
@@ -883,11 +656,6 @@ dns_tkey_processquery(dns_message_t *msg, dns_tkeyctx_t *tctx,
 		RETERR(process_dhtkey(msg, signer, keyname, &tkeyin, tctx,
 				      &tkeyout, ring, &namelist));
 		break;
-	case DNS_TKEYMODE_GSSAPI:
-		tkeyout.error = dns_rcode_noerror;
-		RETERR(process_gsstkey(msg, keyname, &tkeyin, tctx, &tkeyout,
-				       ring));
-		break;
 	case DNS_TKEYMODE_DELETE:
 		tkeyout.error = dns_rcode_noerror;
 		RETERR(process_deletetkey(signer, keyname, &tkeyin, &tkeyout,
@@ -1111,57 +879,6 @@ failure:
 	return result;
 }
 
-isc_result_t
-dns_tkey_buildgssquery(dns_message_t *msg, const dns_name_t *name,
-		       const dns_name_t *gname, isc_buffer_t *intoken,
-		       uint32_t lifetime, dns_gss_ctx_id_t *context, bool win2k,
-		       isc_mem_t *mctx, char **err_message) {
-	dns_rdata_tkey_t tkey;
-	isc_result_t result;
-	isc_stdtime_t now;
-	isc_buffer_t token;
-	unsigned char array[TEMP_BUFFER_SZ];
-
-	UNUSED(intoken);
-
-	REQUIRE(msg != NULL);
-	REQUIRE(name != NULL);
-	REQUIRE(gname != NULL);
-	REQUIRE(context != NULL);
-	REQUIRE(mctx != NULL);
-
-	isc_buffer_init(&token, array, sizeof(array));
-	result = dst_gssapi_initctx(gname, NULL, &token, context, mctx,
-				    err_message);
-	if (result != DNS_R_CONTINUE && result != ISC_R_SUCCESS) {
-		return result;
-	}
-
-	tkey.common.rdclass = dns_rdataclass_any;
-	tkey.common.rdtype = dns_rdatatype_tkey;
-	ISC_LINK_INIT(&tkey.common, link);
-	tkey.mctx = NULL;
-	dns_name_init(&tkey.algorithm, NULL);
-
-	if (win2k) {
-		dns_name_clone(DNS_TSIG_GSSAPIMS_NAME, &tkey.algorithm);
-	} else {
-		dns_name_clone(DNS_TSIG_GSSAPI_NAME, &tkey.algorithm);
-	}
-
-	isc_stdtime_get(&now);
-	tkey.inception = now;
-	tkey.expire = now + lifetime;
-	tkey.mode = DNS_TKEYMODE_GSSAPI;
-	tkey.error = 0;
-	tkey.key = isc_buffer_base(&token);
-	tkey.keylen = isc_buffer_usedlength(&token);
-	tkey.other = NULL;
-	tkey.otherlen = 0;
-
-	return buildquery(msg, name, &tkey, win2k);
-}
-
 isc_result_t
 dns_tkey_builddeletequery(dns_message_t *msg, dns_tsigkey_t *key) {
 	dns_rdata_tkey_t tkey;
@@ -1345,89 +1062,6 @@ failure:
 	return result;
 }
 
-isc_result_t
-dns_tkey_processgssresponse(dns_message_t *qmsg, dns_message_t *rmsg,
-			    const dns_name_t *gname, dns_gss_ctx_id_t *context,
-			    isc_buffer_t *outtoken, dns_tsigkey_t **outkey,
-			    dns_tsig_keyring_t *ring, char **err_message) {
-	dns_rdata_t rtkeyrdata = DNS_RDATA_INIT, qtkeyrdata = DNS_RDATA_INIT;
-	dns_name_t *tkeyname;
-	dns_rdata_tkey_t rtkey, qtkey;
-	dst_key_t *dstkey = NULL;
-	isc_buffer_t intoken;
-	isc_result_t result;
-	unsigned char array[TEMP_BUFFER_SZ];
-
-	REQUIRE(outtoken != NULL);
-	REQUIRE(qmsg != NULL);
-	REQUIRE(rmsg != NULL);
-	REQUIRE(gname != NULL);
-	REQUIRE(ring != NULL);
-	if (outkey != NULL) {
-		REQUIRE(*outkey == NULL);
-	}
-
-	if (rmsg->rcode != dns_rcode_noerror) {
-		return dns_result_fromrcode(rmsg->rcode);
-	}
-	RETERR(find_tkey(rmsg, &tkeyname, &rtkeyrdata, DNS_SECTION_ANSWER));
-	RETERR(dns_rdata_tostruct(&rtkeyrdata, &rtkey, NULL));
-
-	/*
-	 * Win2k puts the item in the ANSWER section, while the RFC
-	 * specifies it should be in the ADDITIONAL section.  Check first
-	 * where it should be, and then where it may be.
-	 */
-	result = find_tkey(qmsg, &tkeyname, &qtkeyrdata,
-			   DNS_SECTION_ADDITIONAL);
-	if (result == ISC_R_NOTFOUND) {
-		result = find_tkey(qmsg, &tkeyname, &qtkeyrdata,
-				   DNS_SECTION_ANSWER);
-	}
-	if (result != ISC_R_SUCCESS) {
-		goto failure;
-	}
-
-	RETERR(dns_rdata_tostruct(&qtkeyrdata, &qtkey, NULL));
-
-	if (rtkey.error != dns_rcode_noerror ||
-	    rtkey.mode != DNS_TKEYMODE_GSSAPI ||
-	    !dns_name_equal(&rtkey.algorithm, &qtkey.algorithm))
-	{
-		tkey_log("dns_tkey_processgssresponse: tkey mode invalid "
-			 "or error set(2) %d",
-			 rtkey.error);
-		dumpmessage(qmsg);
-		dumpmessage(rmsg);
-		result = DNS_R_INVALIDTKEY;
-		goto failure;
-	}
-
-	isc_buffer_init(outtoken, array, sizeof(array));
-	isc_buffer_init(&intoken, rtkey.key, rtkey.keylen);
-	RETERR(dst_gssapi_initctx(gname, &intoken, outtoken, context,
-				  ring->mctx, err_message));
-
-	RETERR(dst_key_fromgssapi(dns_rootname, *context, rmsg->mctx, &dstkey,
-				  NULL));
-
-	RETERR(dns_tsigkey_createfromkey(
-		tkeyname, DNS_TSIG_GSSAPI_NAME, dstkey, false, NULL,
-		rtkey.inception, rtkey.expire, ring->mctx, ring, outkey));
-	dst_key_free(&dstkey);
-	dns_rdata_freestruct(&rtkey);
-	return result;
-
-failure:
-	/*
-	 * XXXSRA This probably leaks memory from rtkey and qtkey.
-	 */
-	if (dstkey != NULL) {
-		dst_key_free(&dstkey);
-	}
-	return result;
-}
-
 isc_result_t
 dns_tkey_processdeleteresponse(dns_message_t *qmsg, dns_message_t *rmsg,
 			       dns_tsig_keyring_t *ring) {
@@ -1481,124 +1115,3 @@ dns_tkey_processdeleteresponse(dns_message_t *qmsg, dns_message_t *rmsg,
 failure:
 	return result;
 }
-
-isc_result_t
-dns_tkey_gssnegotiate(dns_message_t *qmsg, dns_message_t *rmsg,
-		      const dns_name_t *server, dns_gss_ctx_id_t *context,
-		      dns_tsigkey_t **outkey, dns_tsig_keyring_t *ring,
-		      bool win2k, char **err_message) {
-	dns_rdata_t rtkeyrdata = DNS_RDATA_INIT, qtkeyrdata = DNS_RDATA_INIT;
-	dns_name_t *tkeyname;
-	dns_rdata_tkey_t rtkey, qtkey, tkey;
-	isc_buffer_t intoken, outtoken;
-	dst_key_t *dstkey = NULL;
-	isc_result_t result;
-	unsigned char array[TEMP_BUFFER_SZ];
-	bool freertkey = false;
-
-	REQUIRE(qmsg != NULL);
-	REQUIRE(rmsg != NULL);
-	REQUIRE(server != NULL);
-	if (outkey != NULL) {
-		REQUIRE(*outkey == NULL);
-	}
-
-	if (rmsg->rcode != dns_rcode_noerror) {
-		return dns_result_fromrcode(rmsg->rcode);
-	}
-
-	RETERR(find_tkey(rmsg, &tkeyname, &rtkeyrdata, DNS_SECTION_ANSWER));
-	RETERR(dns_rdata_tostruct(&rtkeyrdata, &rtkey, NULL));
-	freertkey = true;
-
-	if (win2k) {
-		RETERR(find_tkey(qmsg, &tkeyname, &qtkeyrdata,
-				 DNS_SECTION_ANSWER));
-	} else {
-		RETERR(find_tkey(qmsg, &tkeyname, &qtkeyrdata,
-				 DNS_SECTION_ADDITIONAL));
-	}
-
-	RETERR(dns_rdata_tostruct(&qtkeyrdata, &qtkey, NULL));
-
-	if (rtkey.error != dns_rcode_noerror ||
-	    rtkey.mode != DNS_TKEYMODE_GSSAPI ||
-	    !dns_name_equal(&rtkey.algorithm, &qtkey.algorithm))
-	{
-		tkey_log("dns_tkey_processdhresponse: tkey mode invalid "
-			 "or error set(4)");
-		result = DNS_R_INVALIDTKEY;
-		goto failure;
-	}
-
-	isc_buffer_init(&intoken, rtkey.key, rtkey.keylen);
-	isc_buffer_init(&outtoken, array, sizeof(array));
-
-	result = dst_gssapi_initctx(server, &intoken, &outtoken, context,
-				    ring->mctx, err_message);
-	if (result != DNS_R_CONTINUE && result != ISC_R_SUCCESS) {
-		return result;
-	}
-
-	if (result == DNS_R_CONTINUE) {
-		dns_fixedname_t fixed;
-
-		dns_fixedname_init(&fixed);
-		dns_name_copy(tkeyname, dns_fixedname_name(&fixed));
-		tkeyname = dns_fixedname_name(&fixed);
-
-		tkey.common.rdclass = dns_rdataclass_any;
-		tkey.common.rdtype = dns_rdatatype_tkey;
-		ISC_LINK_INIT(&tkey.common, link);
-		tkey.mctx = NULL;
-		dns_name_init(&tkey.algorithm, NULL);
-
-		if (win2k) {
-			dns_name_clone(DNS_TSIG_GSSAPIMS_NAME, &tkey.algorithm);
-		} else {
-			dns_name_clone(DNS_TSIG_GSSAPI_NAME, &tkey.algorithm);
-		}
-
-		tkey.inception = qtkey.inception;
-		tkey.expire = qtkey.expire;
-		tkey.mode = DNS_TKEYMODE_GSSAPI;
-		tkey.error = 0;
-		tkey.key = isc_buffer_base(&outtoken);
-		tkey.keylen = isc_buffer_usedlength(&outtoken);
-		tkey.other = NULL;
-		tkey.otherlen = 0;
-
-		dns_message_reset(qmsg, DNS_MESSAGE_INTENTRENDER);
-		RETERR(buildquery(qmsg, tkeyname, &tkey, win2k));
-		return DNS_R_CONTINUE;
-	}
-
-	RETERR(dst_key_fromgssapi(dns_rootname, *context, rmsg->mctx, &dstkey,
-				  NULL));
-
-	/*
-	 * XXXSRA This seems confused.  If we got CONTINUE from initctx,
-	 * the GSS negotiation hasn't completed yet, so we can't sign
-	 * anything yet.
-	 */
-
-	RETERR(dns_tsigkey_createfromkey(
-		tkeyname, win2k ? DNS_TSIG_GSSAPIMS_NAME : DNS_TSIG_GSSAPI_NAME,
-		dstkey, true, NULL, rtkey.inception, rtkey.expire, ring->mctx,
-		ring, outkey));
-	dst_key_free(&dstkey);
-	dns_rdata_freestruct(&rtkey);
-	return result;
-
-failure:
-	/*
-	 * XXXSRA This probably leaks memory from qtkey.
-	 */
-	if (freertkey) {
-		dns_rdata_freestruct(&rtkey);
-	}
-	if (dstkey != NULL) {
-		dst_key_free(&dstkey);
-	}
-	return result;
-}
diff --git a/lib/dns/tsig.c b/lib/dns/tsig.c
--- a/lib/dns/tsig.c
+++ b/lib/dns/tsig.c
@@ -58,22 +58,6 @@ static dns_name_t const hmacmd5 = DNS_NAME_INITABSOLUTE(hmacmd5_ndata,
 							hmacmd5_offsets);
 const dns_name_t *dns_tsig_hmacmd5_name = &hmacmd5;
 
-static unsigned char gsstsig_ndata[] = "\010gss-tsig";
-static unsigned char gsstsig_offsets[] = { 0, 9 };
-static dns_name_t const gsstsig = DNS_NAME_INITABSOLUTE(gsstsig_ndata,
-							gsstsig_offsets);
-const dns_name_t *dns_tsig_gssapi_name = &gsstsig;
-
-/*
- * Since Microsoft doesn't follow its own standard, we will use this
- * alternate name as a second guess.
- */
-static unsigned char gsstsigms_ndata[] = "\003gss\011microsoft\003com";
-static unsigned char gsstsigms_offsets[] = { 0, 4, 14, 18 };
-static dns_name_t const gsstsigms = DNS_NAME_INITABSOLUTE(gsstsigms_ndata,
-							  gsstsigms_offsets);
-const dns_name_t *dns_tsig_gssapims_name = &gsstsigms;
-
 static unsigned char hmacsha1_ndata[] = "\011hmac-sha1";
 static unsigned char hmacsha1_offsets[] = { 0, 10 };
 static dns_name_t const hmacsha1 = DNS_NAME_INITABSOLUTE(hmacsha1_ndata,
@@ -108,8 +92,6 @@ static const struct {
 	const dns_name_t *name;
 	unsigned int dstalg;
 } known_algs[] = { { &hmacmd5, DST_ALG_HMACMD5 },
-		   { &gsstsig, DST_ALG_GSSAPI },
-		   { &gsstsigms, DST_ALG_GSSAPI },
 		   { &hmacsha1, DST_ALG_HMACSHA1 },
 		   { &hmacsha224, DST_ALG_HMACSHA224 },
 		   { &hmacsha256, DST_ALG_HMACSHA256 },
@@ -331,12 +313,7 @@ dns_tsigkey_createfromkey(const dns_name_t *name, const dns_name_t *algorithm,
 		}
 	}
 
-	/*
-	 * Ignore this if it's a GSS key, since the key size is meaningless.
-	 */
-	if (dstkey != NULL && dst_key_size(dstkey) < 64 &&
-	    dstalg != DST_ALG_GSSAPI)
-	{
+	if (dstkey != NULL && dst_key_size(dstkey) < 64) {
 		char namestr[DNS_NAME_FORMATSIZE];
 		dns_name_format(name, namestr, sizeof(namestr));
 		isc_log_write(dns_lctx, DNS_LOGCATEGORY_DNSSEC,
diff --git a/lib/irs/resconf.c b/lib/irs/resconf.c
--- a/lib/irs/resconf.c
+++ b/lib/irs/resconf.c
@@ -37,11 +37,10 @@
 #include <ctype.h>
 #include <errno.h>
 #include <inttypes.h>
-#include <netdb.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/socket.h>
+#include <winsock2.h>
 #include <sys/types.h>
 
 #include <isc/magic.h>
diff --git a/lib/isc/Makefile.am b/lib/isc/Makefile.am
--- a/lib/isc/Makefile.am
+++ b/lib/isc/Makefile.am
@@ -31,14 +31,11 @@ libisc_la_HEADERS =			\
 	include/isc/file.h		\
 	include/isc/formatcheck.h	\
 	include/isc/fuzz.h		\
-	include/isc/glob.h		\
 	include/isc/hash.h		\
 	include/isc/heap.h		\
 	include/isc/hex.h		\
 	include/isc/hmac.h		\
 	include/isc/ht.h		\
-	include/isc/httpd.h		\
-	include/isc/interfaceiter.h	\
 	include/isc/iterated_hash.h	\
 	include/isc/lang.h		\
 	include/isc/lex.h		\
@@ -48,7 +45,6 @@ libisc_la_HEADERS =			\
 	include/isc/managers.h		\
 	include/isc/md.h		\
 	include/isc/mem.h		\
-	include/isc/meminfo.h		\
 	include/isc/mutex.h		\
 	include/isc/mutexblock.h	\
 	include/isc/net.h		\
@@ -67,11 +63,8 @@ libisc_la_HEADERS =			\
 	include/isc/quota.h		\
 	include/isc/radix.h		\
 	include/isc/random.h		\
-	include/isc/ratelimiter.h	\
 	include/isc/refcount.h		\
-	include/isc/regex.h		\
 	include/isc/region.h		\
-	include/isc/resource.h		\
 	include/isc/result.h		\
 	include/isc/rwlock.h		\
 	include/isc/safe.h		\
@@ -79,14 +72,12 @@ libisc_la_HEADERS =			\
 	include/isc/siphash.h		\
 	include/isc/sockaddr.h		\
 	include/isc/stat.h		\
-	include/isc/stats.h		\
 	include/isc/stdatomic.h		\
 	include/isc/stdio.h		\
 	include/isc/stdtime.h		\
 	include/isc/strerr.h		\
 	include/isc/string.h		\
 	include/isc/symtab.h		\
-	include/isc/syslog.h		\
 	include/isc/task.h		\
 	include/isc/taskpool.h		\
 	include/isc/thread.h		\
@@ -132,14 +123,11 @@ libisc_la_SOURCES =		\
 	error.c			\
 	event.c			\
 	file.c			\
-	glob.c			\
 	hash.c			\
 	heap.c			\
 	hex.c			\
 	hmac.c			\
 	ht.c			\
-	httpd.c			\
-	interfaceiter.c		\
 	iterated_hash.c		\
 	jemalloc_shim.h		\
 	lex.c			\
@@ -149,7 +137,6 @@ libisc_la_SOURCES =		\
 	md.c			\
 	mem.c			\
 	mem_p.h			\
-	meminfo.c		\
 	mutex.c			\
 	mutexblock.c		\
 	net.c			\
@@ -163,28 +150,21 @@ libisc_la_SOURCES =		\
 	os_p.h			\
 	parseint.c		\
 	pool.c			\
-	picohttpparser.c	\
-	picohttpparser.h	\
 	portset.c		\
 	quota.c			\
 	radix.c			\
 	random.c		\
-	ratelimiter.c		\
-	regex.c			\
 	region.c		\
-	resource.c		\
 	result.c		\
 	rwlock.c		\
 	safe.c			\
 	serial.c		\
 	siphash.c		\
 	sockaddr.c		\
-	stats.c			\
 	stdio.c			\
 	stdtime.c		\
 	string.c		\
 	symtab.c		\
-	syslog.c		\
 	task.c			\
 	task_p.h		\
 	taskpool.c		\
@@ -212,26 +192,11 @@ libisc_la_LDFLAGS =		\
 	-release "$(PACKAGE_VERSION)"
 
 libisc_la_LIBADD =		\
+	-lsynchronization	\
 	$(LIBUV_LIBS)		\
 	$(OPENSSL_LIBS)		\
 	$(ZLIB_LIBS)
 
-if HAVE_JEMALLOC
-libisc_la_CPPFLAGS +=		\
-	$(JEMALLOC_CFLAGS)
-
-libisc_la_LIBADD +=		\
-	$(JEMALLOC_LIBS)
-endif HAVE_JEMALLOC
-
-if HAVE_JSON_C
-libisc_la_CPPFLAGS +=		\
-	$(JSON_C_CFLAGS)
-
-libisc_la_LIBADD +=		\
-	$(JSON_C_LIBS)
-endif HAVE_JSON_C
-
 if HAVE_LIBNGHTTP2
 libisc_la_SOURCES +=		\
 	netmgr/http.c		\
@@ -243,11 +208,3 @@ libisc_la_CPPFLAGS +=		\
 libisc_la_LIBADD +=		\
 	$(LIBNGHTTP2_LIBS)
 endif
-
-if HAVE_LIBXML2
-libisc_la_CPPFLAGS +=		\
-	$(LIBXML2_CFLAGS)
-
-libisc_la_LIBADD +=		\
-	$(LIBXML2_LIBS)
-endif HAVE_LIBXML2
diff --git a/lib/isc/app.c b/lib/isc/app.c
--- a/lib/isc/app.c
+++ b/lib/isc/app.c
@@ -36,6 +36,8 @@
 #include <isc/time.h>
 #include <isc/util.h>
 
+#include <windows.h>
+
 /*%
  * For BIND9 applications built with threads, we use a single app
  * context and let multiple taskmgr and netmgr threads do actual jobs.
@@ -68,12 +70,7 @@ static isc_appctx_t isc_g_appctx;
 
 static void
 handle_signal(int sig, void (*handler)(int)) {
-	struct sigaction sa;
-
-	memset(&sa, 0, sizeof(sa));
-	sa.sa_handler = handler;
-
-	if (sigfillset(&sa.sa_mask) != 0 || sigaction(sig, &sa, NULL) < 0) {
+	if (signal(sig, handler) == SIG_ERR) {
 		FATAL_SYSERROR(errno, "signal %d", sig);
 	}
 }
@@ -81,7 +78,6 @@ handle_signal(int sig, void (*handler)(int)) {
 isc_result_t
 isc_app_ctxstart(isc_appctx_t *ctx) {
 	int presult;
-	sigset_t sset;
 
 	REQUIRE(VALID_APPCTX(ctx));
 
@@ -102,34 +98,8 @@ isc_app_ctxstart(isc_appctx_t *ctx) {
 	atomic_init(&ctx->want_reload, false);
 	atomic_init(&ctx->blocked, false);
 
-	/*
-	 * Always ignore SIGPIPE.
-	 */
-	handle_signal(SIGPIPE, SIG_IGN);
-
-	handle_signal(SIGHUP, SIG_DFL);
-	handle_signal(SIGTERM, SIG_DFL);
 	handle_signal(SIGINT, SIG_DFL);
 
-	/*
-	 * Block SIGHUP, SIGINT, SIGTERM.
-	 *
-	 * If isc_app_start() is called from the main thread before any other
-	 * threads have been created, then the pthread_sigmask() call below
-	 * will result in all threads having SIGHUP, SIGINT and SIGTERM
-	 * blocked by default, ensuring that only the thread that calls
-	 * sigwait() for them will get those signals.
-	 */
-	if (sigemptyset(&sset) != 0 || sigaddset(&sset, SIGHUP) != 0 ||
-	    sigaddset(&sset, SIGINT) != 0 || sigaddset(&sset, SIGTERM) != 0)
-	{
-		FATAL_SYSERROR(errno, "sigsetops");
-	}
-	presult = pthread_sigmask(SIG_BLOCK, &sset, NULL);
-	if (presult != 0) {
-		FATAL_SYSERROR(presult, "pthread_sigmask()");
-	}
-
 	return ISC_R_SUCCESS;
 }
 
@@ -208,34 +178,9 @@ isc_app_ctxrun(isc_appctx_t *ctx) {
 	 */
 	while (!atomic_load_acquire(&ctx->want_shutdown)) {
 		if (ctx == &isc_g_appctx) {
-			sigset_t sset;
-			int sig;
-			/*
-			 * Wait for SIGHUP, SIGINT, or SIGTERM.
-			 */
-			if (sigemptyset(&sset) != 0 ||
-			    sigaddset(&sset, SIGHUP) != 0 ||
-			    sigaddset(&sset, SIGINT) != 0 ||
-			    sigaddset(&sset, SIGTERM) != 0)
-			{
-				FATAL_SYSERROR(errno, "sigsetops");
-			}
-
-			if (sigwait(&sset, &sig) == 0) {
-				switch (sig) {
-				case SIGINT:
-				case SIGTERM:
-					atomic_store_release(
-						&ctx->want_shutdown, true);
-					break;
-				case SIGHUP:
-					atomic_store_release(&ctx->want_reload,
-							     true);
-					break;
-				default:
-					UNREACHABLE();
-				}
-			}
+			WaitOnAddress(&ctx->want_shutdown,
+				      &(atomic_bool){ false },
+				      sizeof(atomic_bool), INFINITE);
 		} else {
 			/*
 			 * Tools using multiple contexts don't
@@ -251,12 +196,6 @@ isc_app_ctxrun(isc_appctx_t *ctx) {
 				UNLOCK(&ctx->readylock);
 			}
 		}
-		if (atomic_compare_exchange_strong_acq_rel(
-			    &ctx->want_reload, &(bool){ true }, false))
-		{
-			return ISC_R_RELOAD;
-		}
-
 		if (atomic_load_acquire(&ctx->want_shutdown) &&
 		    atomic_load_acquire(&ctx->blocked))
 		{
@@ -302,9 +241,8 @@ isc_app_ctxshutdown(isc_appctx_t *ctx) {
 			SIGNAL(&ctx->ready);
 		} else {
 			/* Normal single BIND9 context */
-			if (kill(getpid(), SIGTERM) < 0) {
-				FATAL_SYSERROR(errno, "kill");
-			}
+			atomic_store_release(&ctx->want_shutdown, true);
+			WakeByAddressSingle(&ctx->want_shutdown);
 		}
 	}
 }
@@ -330,9 +268,7 @@ isc_app_ctxsuspend(isc_appctx_t *ctx) {
 			SIGNAL(&ctx->ready);
 		} else {
 			/* Normal single BIND9 context */
-			if (kill(getpid(), SIGHUP) < 0) {
-				FATAL_SYSERROR(errno, "kill");
-			}
+			FATAL_SYSERROR(0, "kill");
 		}
 	}
 }
@@ -358,34 +294,21 @@ isc_app_finish(void) {
 
 void
 isc_app_block(void) {
-	sigset_t sset;
-
 	REQUIRE(atomic_load_acquire(&isc_g_appctx.running));
 
 	atomic_compare_exchange_enforced(&isc_g_appctx.blocked,
 					 &(bool){ false }, true);
 
 	blockedthread = pthread_self();
-	RUNTIME_CHECK(sigemptyset(&sset) == 0 &&
-		      sigaddset(&sset, SIGINT) == 0 &&
-		      sigaddset(&sset, SIGTERM) == 0);
-	RUNTIME_CHECK(pthread_sigmask(SIG_UNBLOCK, &sset, NULL) == 0);
 }
 
 void
 isc_app_unblock(void) {
-	sigset_t sset;
-
 	REQUIRE(atomic_load_acquire(&isc_g_appctx.running));
 	REQUIRE(blockedthread == pthread_self());
 
 	atomic_compare_exchange_enforced(&isc_g_appctx.blocked, &(bool){ true },
 					 false);
-
-	RUNTIME_CHECK(sigemptyset(&sset) == 0 &&
-		      sigaddset(&sset, SIGINT) == 0 &&
-		      sigaddset(&sset, SIGTERM) == 0);
-	RUNTIME_CHECK(pthread_sigmask(SIG_BLOCK, &sset, NULL) == 0);
 }
 
 isc_result_t
diff --git a/lib/isc/dir.c b/lib/isc/dir.c
--- a/lib/isc/dir.c
+++ b/lib/isc/dir.c
@@ -163,106 +163,3 @@ isc_dir_chdir(const char *dirname) {
 
 	return ISC_R_SUCCESS;
 }
-
-isc_result_t
-isc_dir_chroot(const char *dirname) {
-#ifdef HAVE_CHROOT
-	void *tmp;
-#endif /* ifdef HAVE_CHROOT */
-
-	REQUIRE(dirname != NULL);
-
-#ifdef HAVE_CHROOT
-	/*
-	 * Try to use getservbyname and getprotobyname before chroot.
-	 * If WKS records are used in a zone under chroot, Name Service Switch
-	 * may fail to load library in chroot.
-	 * Do not report errors if it fails, we do not need any result now.
-	 */
-	tmp = getprotobyname("udp");
-	if (tmp != NULL) {
-		(void)getservbyname("domain", "udp");
-	}
-
-	if (chroot(dirname) < 0 || chdir("/") < 0) {
-		return isc__errno2result(errno);
-	}
-
-	return ISC_R_SUCCESS;
-#else  /* ifdef HAVE_CHROOT */
-	return ISC_R_NOTIMPLEMENTED;
-#endif /* ifdef HAVE_CHROOT */
-}
-
-isc_result_t
-isc_dir_createunique(char *templet) {
-	isc_result_t result;
-	char *x;
-	char *p;
-	int i;
-	int pid;
-
-	REQUIRE(templet != NULL);
-
-	/*!
-	 * \brief mkdtemp is not portable, so this emulates it.
-	 */
-
-	pid = getpid();
-
-	/*
-	 * Replace trailing Xs with the process-id, zero-filled.
-	 */
-	for (x = templet + strlen(templet) - 1; *x == 'X' && x >= templet;
-	     x--, pid /= 10)
-	{
-		*x = pid % 10 + '0';
-	}
-
-	x++; /* Set x to start of ex-Xs. */
-
-	do {
-		i = mkdir(templet, 0700);
-		if (i == 0 || errno != EEXIST) {
-			break;
-		}
-
-		/*
-		 * The BSD algorithm.
-		 */
-		p = x;
-		while (*p != '\0') {
-			if (isdigit((unsigned char)*p)) {
-				*p = 'a';
-			} else if (*p != 'z') {
-				++*p;
-			} else {
-				/*
-				 * Reset character and move to next.
-				 */
-				*p++ = 'a';
-				continue;
-			}
-
-			break;
-		}
-
-		if (*p == '\0') {
-			/*
-			 * Tried all combinations.  errno should already
-			 * be EEXIST, but ensure it is anyway for
-			 * isc__errno2result().
-			 */
-			errno = EEXIST;
-			break;
-		}
-	} while (1);
-
-	if (i == -1) {
-		result = isc__errno2result(errno);
-	} else {
-		result = ISC_R_SUCCESS;
-	}
-
-	return result;
-}
diff --git a/lib/isc/file.c b/lib/isc/file.c
--- a/lib/isc/file.c
+++ b/lib/isc/file.c
@@ -174,47 +174,6 @@ isc_file_getsize(const char *file, off_t *size) {
 	return result;
 }
 
-isc_result_t
-isc_file_settime(const char *file, isc_time_t *when) {
-	struct timeval times[2];
-
-	REQUIRE(file != NULL && when != NULL);
-
-	/*
-	 * tv_sec is at least a 32 bit quantity on all platforms we're
-	 * dealing with, but it is signed on most (all?) of them,
-	 * so we need to make sure the high bit isn't set.  This unfortunately
-	 * loses when either:
-	 *   * tv_sec becomes a signed 64 bit integer but long is 32 bits
-	 *	and isc_time_seconds > LONG_MAX, or
-	 *   * isc_time_seconds is changed to be > 32 bits but long is 32 bits
-	 *      and isc_time_seconds has at least 33 significant bits.
-	 */
-	times[0].tv_sec = times[1].tv_sec = (long)isc_time_seconds(when);
-
-	/*
-	 * Here is the real check for the high bit being set.
-	 */
-	if ((times[0].tv_sec &
-	     (1ULL << (sizeof(times[0].tv_sec) * CHAR_BIT - 1))) != 0)
-	{
-		return ISC_R_RANGE;
-	}
-
-	/*
-	 * isc_time_nanoseconds guarantees a value that divided by 1000 will
-	 * fit into the minimum possible size tv_usec field.
-	 */
-	times[0].tv_usec = times[1].tv_usec =
-		(int32_t)(isc_time_nanoseconds(when) / 1000);
-
-	if (utimes(file, times) < 0) {
-		return isc__errno2result(errno);
-	}
-
-	return ISC_R_SUCCESS;
-}
-
 #undef TEMPLATE
 #define TEMPLATE "tmp-XXXXXXXXXX" /*%< 14 characters. */
 
@@ -265,53 +224,6 @@ isc_file_template(const char *path, const char *templet, char *buf,
 static const char alphnum[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuv"
 			      "wxyz0123456789";
 
-isc_result_t
-isc_file_renameunique(const char *file, char *templet) {
-	char *x;
-	char *cp;
-
-	REQUIRE(file != NULL);
-	REQUIRE(templet != NULL);
-
-	cp = templet;
-	while (*cp != '\0') {
-		cp++;
-	}
-	if (cp == templet) {
-		return ISC_R_FAILURE;
-	}
-
-	x = cp--;
-	while (cp >= templet && *cp == 'X') {
-		*cp = alphnum[isc_random_uniform(sizeof(alphnum) - 1)];
-		x = cp--;
-	}
-	while (link(file, templet) == -1) {
-		if (errno != EEXIST) {
-			return isc__errno2result(errno);
-		}
-		for (cp = x;;) {
-			const char *t;
-			if (*cp == '\0') {
-				return ISC_R_FAILURE;
-			}
-			t = strchr(alphnum, *cp);
-			if (t == NULL || *++t == '\0') {
-				*cp++ = alphnum[0];
-			} else {
-				*cp = *t;
-				break;
-			}
-		}
-	}
-	if (unlink(file) < 0) {
-		if (errno != ENOENT) {
-			return isc__errno2result(errno);
-		}
-	}
-	return ISC_R_SUCCESS;
-}
-
 isc_result_t
 isc_file_openunique(char *templet, FILE **fp) {
 	int mode = S_IWUSR | S_IRUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
@@ -496,30 +408,6 @@ isc_file_isdirectory(const char *filename) {
 	return ISC_R_SUCCESS;
 }
 
-bool
-isc_file_isabsolute(const char *filename) {
-	REQUIRE(filename != NULL);
-	return filename[0] == '/';
-}
-
-bool
-isc_file_iscurrentdir(const char *filename) {
-	REQUIRE(filename != NULL);
-	return filename[0] == '.' && filename[1] == '\0';
-}
-
-bool
-isc_file_ischdiridempotent(const char *filename) {
-	REQUIRE(filename != NULL);
-	if (isc_file_isabsolute(filename)) {
-		return true;
-	}
-	if (isc_file_iscurrentdir(filename)) {
-		return true;
-	}
-	return false;
-}
-
 const char *
 isc_file_basename(const char *filename) {
 	const char *s;
@@ -649,143 +537,6 @@ isc_file_safecreate(const char *filename, FILE **fp) {
 	return ISC_R_SUCCESS;
 }
 
-isc_result_t
-isc_file_splitpath(isc_mem_t *mctx, const char *path, char **dirname,
-		   char const **bname) {
-	char *dir;
-	const char *file, *slash;
-
-	if (path == NULL) {
-		return ISC_R_INVALIDFILE;
-	}
-
-	slash = strrchr(path, '/');
-
-	if (slash == path) {
-		file = ++slash;
-		dir = isc_mem_strdup(mctx, "/");
-	} else if (slash != NULL) {
-		file = ++slash;
-		dir = isc_mem_allocate(mctx, slash - path);
-		strlcpy(dir, path, slash - path);
-	} else {
-		file = path;
-		dir = isc_mem_strdup(mctx, ".");
-	}
-
-	if (dir == NULL) {
-		return ISC_R_NOMEMORY;
-	}
-
-	if (*file == '\0') {
-		isc_mem_free(mctx, dir);
-		return ISC_R_INVALIDFILE;
-	}
-
-	*dirname = dir;
-	*bname = file;
-
-	return ISC_R_SUCCESS;
-}
-
-#define DISALLOW "\\/ABCDEFGHIJKLMNOPQRSTUVWXYZ"
-
-static isc_result_t
-digest2hex(unsigned char *digest, unsigned int digestlen, char *hash,
-	   size_t hashlen) {
-	unsigned int i;
-	int ret;
-	for (i = 0; i < digestlen; i++) {
-		size_t left = hashlen - i * 2;
-		ret = snprintf(hash + i * 2, left, "%02x", digest[i]);
-		if (ret < 0 || (size_t)ret >= left) {
-			return ISC_R_NOSPACE;
-		}
-	}
-	return ISC_R_SUCCESS;
-}
-
-isc_result_t
-isc_file_sanitize(const char *dir, const char *base, const char *ext,
-		  char *path, size_t length) {
-	char buf[PATH_MAX];
-	unsigned char digest[ISC_MAX_MD_SIZE];
-	unsigned int digestlen;
-	char hash[ISC_MAX_MD_SIZE * 2 + 1];
-	size_t l = 0;
-	isc_result_t err;
-
-	REQUIRE(base != NULL);
-	REQUIRE(path != NULL);
-
-	l = strlen(base) + 1;
-
-	/*
-	 * allow room for a full sha256 hash (64 chars
-	 * plus null terminator)
-	 */
-	if (l < 65U) {
-		l = 65;
-	}
-
-	if (dir != NULL) {
-		l += strlen(dir) + 1;
-	}
-	if (ext != NULL) {
-		l += strlen(ext) + 1;
-	}
-
-	if (l > length || l > (unsigned)PATH_MAX) {
-		return ISC_R_NOSPACE;
-	}
-
-	/* Check whether the full-length SHA256 hash filename exists */
-	err = isc_md(ISC_MD_SHA256, (const unsigned char *)base, strlen(base),
-		     digest, &digestlen);
-	if (err != ISC_R_SUCCESS) {
-		return err;
-	}
-
-	err = digest2hex(digest, digestlen, hash, sizeof(hash));
-	if (err != ISC_R_SUCCESS) {
-		return err;
-	}
-
-	snprintf(buf, sizeof(buf), "%s%s%s%s%s", dir != NULL ? dir : "",
-		 dir != NULL ? "/" : "", hash, ext != NULL ? "." : "",
-		 ext != NULL ? ext : "");
-	if (isc_file_exists(buf)) {
-		strlcpy(path, buf, length);
-		return ISC_R_SUCCESS;
-	}
-
-	/* Check for a truncated SHA256 hash filename */
-	hash[16] = '\0';
-	snprintf(buf, sizeof(buf), "%s%s%s%s%s", dir != NULL ? dir : "",
-		 dir != NULL ? "/" : "", hash, ext != NULL ? "." : "",
-		 ext != NULL ? ext : "");
-	if (isc_file_exists(buf)) {
-		strlcpy(path, buf, length);
-		return ISC_R_SUCCESS;
-	}
-
-	/*
-	 * If neither hash filename already exists, then we'll use
-	 * the original base name if it has no disallowed characters,
-	 * or the truncated hash name if it does.
-	 */
-	if (strpbrk(base, DISALLOW) != NULL) {
-		strlcpy(path, buf, length);
-		return ISC_R_SUCCESS;
-	}
-
-	snprintf(buf, sizeof(buf), "%s%s%s%s%s", dir != NULL ? dir : "",
-		 dir != NULL ? "/" : "", base, ext != NULL ? "." : "",
-		 ext != NULL ? ext : "");
-	strlcpy(path, buf, length);
-	return ISC_R_SUCCESS;
-}
-
 bool
 isc_file_isdirwritable(const char *path) {
 	return access(path, W_OK | X_OK) == 0;
diff --git a/lib/isc/include/isc/dir.h b/lib/isc/include/isc/dir.h
--- a/lib/isc/include/isc/dir.h
+++ b/lib/isc/include/isc/dir.h
@@ -65,16 +65,4 @@ isc_dir_close(isc_dir_t *dir);
 isc_result_t
 isc_dir_chdir(const char *dirname);
 
-isc_result_t
-isc_dir_chroot(const char *dirname);
-
-isc_result_t
-isc_dir_createunique(char *templet);
-/*!<
- * Use a templet (such as from isc_file_mktemplate()) to create a uniquely
- * named, empty directory.  The templet string is modified in place.
- * If result == ISC_R_SUCCESS, it is the name of the directory that was
- * created.
- */
-
 ISC_LANG_ENDDECLS
diff --git a/lib/isc/include/isc/endian.h b/lib/isc/include/isc/endian.h
--- a/lib/isc/include/isc/endian.h
+++ b/lib/isc/include/isc/endian.h
@@ -71,9 +71,6 @@
 #elif defined(__ANDROID__) || defined(__CYGWIN__) || defined(__GNUC__) || \
 	defined(__GNU__)
 
-#include <byteswap.h>
-#include <endian.h>
-
 #else /* if defined(__DragonFly__) || defined(__FreeBSD__) || \
        * defined(__NetBSD__) || defined(__OpenBSD__) || defined(__bsdi__) */
 
diff --git a/lib/isc/include/isc/file.h b/lib/isc/include/isc/file.h
--- a/lib/isc/include/isc/file.h
+++ b/lib/isc/include/isc/file.h
@@ -24,9 +24,6 @@
 
 ISC_LANG_BEGINDECLS
 
-isc_result_t
-isc_file_settime(const char *file, isc_time_t *time);
-
 isc_result_t
 isc_file_mode(const char *file, mode_t *modep);
 
@@ -185,12 +182,6 @@ isc_file_exists(const char *pathname);
  * privileges to search the entire path.
  */
 
-bool
-isc_file_isabsolute(const char *filename);
-/*!<
- * \brief Return #true if the given file name is absolute.
- */
-
 isc_result_t
 isc_file_isplainfile(const char *name);
 
@@ -231,19 +222,6 @@ isc_file_isdirectory(const char *name);
  *		These occur when stat returns -1 and an errno.
  */
 
-bool
-isc_file_iscurrentdir(const char *filename);
-/*!<
- * \brief Return #true if the given file name is the current directory (".").
- */
-
-bool
-isc_file_ischdiridempotent(const char *filename);
-/*%<
- * Return #true if calling chdir(filename) multiple times will give
- * the same result as calling it once.
- */
-
 const char *
 isc_file_basename(const char *filename);
 /*%<
@@ -276,12 +254,6 @@ isc_file_template(const char *path, const char *templet, char *buf,
  * such that path can be renamed to buf atomically.
  */
 
-isc_result_t
-isc_file_renameunique(const char *file, char *templet);
-/*%<
- * Rename 'file' using 'templet' as a template for the new file name.
- */
-
 isc_result_t
 isc_file_absolutepath(const char *filename, char *path, size_t pathlen);
 /*%<
@@ -308,21 +280,6 @@ isc_file_safecreate(const char *filename, FILE **fp);
  * that only the owner can read/write it.
  */
 
-isc_result_t
-isc_file_splitpath(isc_mem_t *mctx, const char *path, char **dirname,
-		   char const **basename);
-/*%<
- * Split a path into dirname and basename.  If 'path' contains no slash
- * (or, on windows, backslash), then '*dirname' is set to ".".
- *
- * Allocates memory for '*dirname', which can be freed with isc_mem_free().
- *
- * Returns:
- * - ISC_R_SUCCESS on success
- * - ISC_R_INVALIDFILE if 'path' is empty or ends with '/'
- * - ISC_R_NOMEMORY if unable to allocate memory
- */
-
 isc_result_t
 isc_file_getsize(const char *file, off_t *size);
 /*%<
@@ -343,35 +300,6 @@ isc_file_getsizefd(int fd, off_t *size);
  * - ISC_R_SUCCESS on success
  */
 
-isc_result_t
-isc_file_sanitize(const char *dir, const char *base, const char *ext,
-		  char *path, size_t length);
-/*%<
- * Generate a sanitized filename, such as for MKEYS or NZF files.
- *
- * Historically, MKEYS and NZF files used SHA256 hashes of the view
- * name for the filename; this was to deal with the possibility of
- * forbidden characters such as "/" being in a view name, and to
- * avoid problems with case-insensitive file systems.
- *
- * Given a basename 'base' and an extension 'ext', this function checks
- * for the existence of file using the old-style name format in directory
- * 'dir'. If found, it returns the path to that file.  If there is no
- * file already in place, a new pathname is generated; if the basename
- * contains any excluded characters, then a truncated SHA256 hash is
- * used, otherwise the basename is used.  The path name is copied
- * into 'path', which must point to a buffer of at least 'length'
- * bytes.
- *
- * Requires:
- * - base != NULL
- * - path != NULL
- *
- * Returns:
- * - ISC_R_SUCCESS on success
- * - ISC_R_NOSPACE if the resulting path would be longer than 'length'
- */
-
 bool
 isc_file_isdirwritable(const char *path);
 /*%<
diff --git a/lib/isc/include/isc/log.h b/lib/isc/include/isc/log.h
--- a/lib/isc/include/isc/log.h
+++ b/lib/isc/include/isc/log.h
@@ -18,7 +18,6 @@
 #include <stdarg.h>
 #include <stdbool.h>
 #include <stdio.h>
-#include <syslog.h> /* XXXDCL NT */
 
 #include <isc/formatcheck.h>
 #include <isc/lang.h>
@@ -48,7 +47,6 @@
  */
 #define ISC_LOG_TONULL	   1
 #define ISC_LOG_TOSYSLOG   2
-#define ISC_LOG_TOFILE	   3
 #define ISC_LOG_TOFILEDESC 4
 /*@}*/
 
@@ -127,19 +125,9 @@ struct isc_logmodule {
 typedef struct isc_logfile {
 	FILE *stream;	      /*%< Initialized to NULL for
 			       * #ISC_LOG_TOFILE. */
-	const char *name;     /*%< NULL for #ISC_LOG_TOFILEDESC. */
 	int	    versions; /* >= 0, #ISC_LOG_ROLLNEVER,
 			       * #ISC_LOG_ROLLINFINITE. */
 	isc_log_rollsuffix_t suffix;
-	/*%
-	 * stdio's ftell is standardized to return a long, which may well not
-	 * be big enough for the largest file supportable by the operating
-	 * system (though it is _probably_ big enough for the largest log
-	 * anyone would want).  st_size returned by fstat should be typedef'd
-	 * to a size large enough for the largest possible file on a system.
-	 */
-	isc_offset_t maximum_size;
-	bool	     maximum_reached; /*%< Private. */
 } isc_logfile_t;
 
 /*%
@@ -228,10 +216,10 @@ isc_logconfig_create(isc_log_t *lctx, isc_logconfig_t **lcfgp);
  *
  *\li	Four default channels are established:
  *\verbatim
- *	    	default_syslog
- *		 - log to syslog's daemon facility #ISC_LOG_INFO or higher
  *		default_stderr
  *		 - log to stderr #ISC_LOG_INFO or higher
+ *	    	default_syslog
+ *		 - (same as default_stderr)
  *		default_debug
  *		 - log to stderr #ISC_LOG_DEBUG dynamically
  *		null
@@ -419,7 +407,7 @@ isc_log_createchannel(isc_logconfig_t *lcfg, const char *name,
  *
  *\li	name is not NULL.
  *
- *\li	type is #ISC_LOG_TOSYSLOG, #ISC_LOG_TOFILE, #ISC_LOG_TOFILEDESC or
+ *\li	type is #ISC_LOG_TOSYSLOG, #ISC_LOG_TOFILEDESC or
  *		#ISC_LOG_TONULL.
  *
  *\li	destination is not NULL unless type is #ISC_LOG_TONULL.
@@ -725,69 +713,6 @@ isc_log_gettag(isc_logconfig_t *lcfg);
  *\li	A pointer to the current identifier, or NULL if none has been set.
  */
 
-void
-isc_log_opensyslog(const char *tag, int options, int facility);
-/*%<
- * Initialize syslog logging.
- *
- * Notes:
- *\li	XXXDCL NT
- *	This is currently equivalent to openlog(), but is not going to remain
- *	that way.  In the meantime, the arguments are all identical to
- *	those used by openlog(3), as follows:
- *
- * \code
- *		tag: The string to use in the position of the program
- *			name in syslog messages.  Most (all?) syslogs
- *			will use basename(argv[0]) if tag is NULL.
- *
- *		options: LOG_CONS, LOG_PID, LOG_NDELAY ... whatever your
- *			syslog supports.
- *
- *		facility: The default syslog facility.  This is irrelevant
- *			since isc_log_write will ALWAYS use the channel's
- *			declared facility.
- * \endcode
- *
- *\li	Zero effort has been made (yet) to accommodate systems with openlog()
- *	that only takes two arguments, or to identify valid syslog
- *	facilities or options for any given architecture.
- *
- *\li	It is necessary to call isc_log_opensyslog() to initialize
- *	syslogging on machines which do not support network connections to
- *	syslogd because they require a Unix domain socket to be used.  Since
- *	this is a chore to determine at run-time, it is suggested that it
- *	always be called by programs using the ISC logging system.
- *
- * Requires:
- *\li	Nothing.
- *
- * Ensures:
- *\li	openlog() is called to initialize the syslog system.
- */
-
-void
-isc_log_closefilelogs(isc_log_t *lctx);
-/*%<
- * Close all open files used by #ISC_LOG_TOFILE channels.
- *
- * Notes:
- *\li	This function is provided for programs that want to use their own
- *	log rolling mechanism rather than the one provided internally.
- *	For example, a program that wanted to keep daily logs would define
- *	a channel which used #ISC_LOG_ROLLNEVER, then once a day would
- *	rename the log file and call isc_log_closefilelogs().
- *
- *\li	#ISC_LOG_TOFILEDESC channels are unaffected.
- *
- * Requires:
- *\li	lctx is a valid context.
- *
- * Ensures:
- *\li	The open files are closed and will be reopened when they are
- *	next needed.
- */
-
 isc_logcategory_t *
 isc_log_categorybyname(isc_log_t *lctx, const char *name);
 /*%<
diff --git a/lib/isc/include/isc/mem.h b/lib/isc/include/isc/mem.h
--- a/lib/isc/include/isc/mem.h
+++ b/lib/isc/include/isc/mem.h
@@ -183,40 +183,7 @@ extern unsigned int isc_mem_defaultflags;
 		(p) = NULL;                                     \
 	} while (0)
 
-/*@{*/
-/*
- * This is a little hack to help with dynamic link order,
- * see https://github.com/jemalloc/jemalloc/issues/2566
- * for more information.
- */
-#if HAVE_JEMALLOC
-
-/*
- * cmocka.h has confliction definitions with the jemalloc header but we only
- * need the mallocx symbol from jemalloc.
- */
-void *
-mallocx(size_t size, int flags);
-
-extern volatile void *isc__mem_malloc;
-
-#ifndef CMM_ACCESS_ONCE
-/*
- * This macro has been borrowed from Userspace-RCU to ensure the access
- * to isc__mem_malloc will not be optimized away by the compiler.
- */
-#define CMM_ACCESS_ONCE(x) (*(__volatile__ __typeof__(x) *)&(x))
-#endif
-
-#define isc_mem_create(cp)                                            \
-	{                                                             \
-		ISCMEMFUNC(create)((cp)_ISC_MEM_FILELINE);            \
-		isc__mem_malloc = mallocx;                            \
-		ISC_INSIST(CMM_ACCESS_ONCE(isc__mem_malloc) != NULL); \
-	}
-#else
 #define isc_mem_create(cp) ISCMEMFUNC(create)((cp)_ISC_MEM_FILELINE)
-#endif
 void ISCMEMFUNC(create)(isc_mem_t **_ISC_MEM_FLARG);
 
 /*!<
@@ -433,22 +400,6 @@ isc_mem_getname(isc_mem_t *ctx);
  * 	empty.
  */
 
-#ifdef HAVE_LIBXML2
-int
-isc_mem_renderxml(void *writer0);
-/*%<
- * Render all contexts' statistics and status in XML for writer.
- */
-#endif /* HAVE_LIBXML2 */
-
-#ifdef HAVE_JSON_C
-isc_result_t
-isc_mem_renderjson(void *memobj0);
-/*%<
- * Render all contexts' statistics and status in JSON.
- */
-#endif /* HAVE_JSON_C */
-
 /*
  * Memory pools
  */
diff --git a/lib/isc/include/isc/net.h b/lib/isc/include/isc/net.h
--- a/lib/isc/include/isc/net.h
+++ b/lib/isc/include/isc/net.h
@@ -70,12 +70,14 @@
 #include <isc/lang.h>
 #include <isc/types.h>
 
-#include <arpa/inet.h> /* Contractual promise. */
-#include <net/if.h>
-#include <netinet/in.h> /* Contractual promise. */
-#include <sys/socket.h> /* Contractual promise. */
+#include <winsock2.h> /* Contractual promise. */
+#include <ws2tcpip.h> /* Contractual promise. */
 #include <sys/types.h>
 
+typedef unsigned short in_port_t;
+
+#define sa_family_t ADDRESS_FAMILY
+
 #ifndef IN6ADDR_LOOPBACK_INIT
 #ifdef s6_addr
 /*% IPv6 address loopback init */
diff --git a/lib/isc/include/isc/netaddr.h b/lib/isc/include/isc/netaddr.h
--- a/lib/isc/include/isc/netaddr.h
+++ b/lib/isc/include/isc/netaddr.h
@@ -23,7 +23,7 @@
 #include <isc/types.h>
 
 #include <sys/types.h>
-#include <sys/un.h>
+#include <winsock2.h>
 
 ISC_LANG_BEGINDECLS
 
@@ -36,7 +36,6 @@ struct isc_netaddr {
 	union {
 		struct in_addr	in;
 		struct in6_addr in6;
-		char		un[sizeof(((struct sockaddr_un *)0)->sun_path)];
 	} type;
 	uint32_t zone;
 };
@@ -111,9 +110,6 @@ isc_netaddr_fromin(isc_netaddr_t *netaddr, const struct in_addr *ina);
 void
 isc_netaddr_fromin6(isc_netaddr_t *netaddr, const struct in6_addr *ina6);
 
-isc_result_t
-isc_netaddr_frompath(isc_netaddr_t *netaddr, const char *path);
-
 void
 isc_netaddr_setzone(isc_netaddr_t *netaddr, uint32_t zone);
 
diff --git a/lib/isc/include/isc/netdb.h b/lib/isc/include/isc/netdb.h
--- a/lib/isc/include/isc/netdb.h
+++ b/lib/isc/include/isc/netdb.h
@@ -43,6 +43,4 @@
  *** Imports.
  ***/
 
-#include <netdb.h>
-
 #include <isc/net.h>
diff --git a/lib/isc/include/isc/netmgr.h b/lib/isc/include/isc/netmgr.h
--- a/lib/isc/include/isc/netmgr.h
+++ b/lib/isc/include/isc/netmgr.h
@@ -21,7 +21,8 @@
 #include <isc/tls.h>
 #include <isc/types.h>
 
-#include <sys/socket.h>
+#include <winsock2.h>
+#include <ws2tcpip.h>
 #include <sys/types.h>
 
 #if defined(SO_REUSEPORT_LB) || (defined(SO_REUSEPORT) && defined(__linux__))
@@ -509,18 +510,6 @@ isc_nm_maxudp(isc_nm_t *mgr, uint32_t maxudp);
  * size.
  */
 
-void
-isc_nm_setstats(isc_nm_t *mgr, isc_stats_t *stats);
-/*%<
- * Set a socket statistics counter set 'stats' for 'mgr'.
- *
- * Requires:
- *\li	'mgr' is valid and doesn't have stats already set.
- *
- *\li	stats is a valid set of statistics counters supporting the
- *	full range of socket-related stats counter numbers.
- */
-
 isc_result_t
 isc_nm_checkaddr(const isc_sockaddr_t *addr, isc_socktype_t type);
 /*%<
diff --git a/lib/isc/include/isc/sockaddr.h b/lib/isc/include/isc/sockaddr.h
--- a/lib/isc/include/isc/sockaddr.h
+++ b/lib/isc/include/isc/sockaddr.h
@@ -21,7 +21,7 @@
 #include <isc/net.h>
 #include <isc/types.h>
 
-#include <sys/un.h>
+#include <winsock2.h>
 
 /*
  * Any updates to this structure should also be applied in
diff --git a/lib/isc/include/isc/task.h b/lib/isc/include/isc/task.h
--- a/lib/isc/include/isc/task.h
+++ b/lib/isc/include/isc/task.h
@@ -633,14 +633,4 @@ isc_taskmgr_excltask(isc_taskmgr_t *mgr, isc_task_t **taskp);
  *\li	taskp != NULL && *taskp == NULL
  */
 
-#ifdef HAVE_LIBXML2
-int
-isc_taskmgr_renderxml(isc_taskmgr_t *mgr, void *writer0);
-#endif /* ifdef HAVE_LIBXML2 */
-
-#ifdef HAVE_JSON_C
-isc_result_t
-isc_taskmgr_renderjson(isc_taskmgr_t *mgr, void *tasksobj0);
-#endif /* HAVE_JSON_C */
-
 ISC_LANG_ENDDECLS
diff --git a/lib/isc/include/isc/types.h b/lib/isc/include/isc/types.h
--- a/lib/isc/include/isc/types.h
+++ b/lib/isc/include/isc/types.h
@@ -45,12 +45,6 @@ typedef struct isc_event   isc_event_t;			  /*%< Event */
 typedef ISC_LIST(isc_event_t) isc_eventlist_t;		  /*%< Event List */
 typedef unsigned int	 isc_eventtype_t;		  /*%< Event Type */
 typedef struct isc_hash	 isc_hash_t;			  /*%< Hash */
-typedef struct isc_httpd isc_httpd_t;			  /*%< HTTP client */
-typedef void(isc_httpdfree_t)(isc_buffer_t *, void *); /*%< HTTP free function
-							*/
-typedef struct isc_httpdmgr isc_httpdmgr_t;	       /*%< HTTP manager */
-typedef struct isc_httpdurl isc_httpdurl_t;	       /*%< HTTP URL */
-typedef void(isc_httpdondestroy_t)(void *); /*%< Callback on destroying httpd */
 typedef struct isc_interface	 isc_interface_t;     /*%< Interface */
 typedef struct isc_interfaceiter isc_interfaceiter_t; /*%< Interface Iterator */
 typedef struct isc_interval	 isc_interval_t;      /*%< Interval */
@@ -68,16 +62,12 @@ typedef struct isc_nmsocket	 isc_nmsocket_t; /*%< Network manager socket */
 typedef struct isc_nmhandle	 isc_nmhandle_t; /*%< Network manager handle */
 typedef struct isc_portset	 isc_portset_t;	 /*%< Port Set */
 typedef struct isc_quota	 isc_quota_t;	 /*%< Quota */
-typedef struct isc_ratelimiter	 isc_ratelimiter_t;   /*%< Rate Limiter */
 typedef struct isc_region	 isc_region_t;	      /*%< Region */
 typedef uint64_t		 isc_resourcevalue_t; /*%< Resource Value */
 typedef struct isc_rwlock	 isc_rwlock_t;	      /*%< Read Write Lock */
 typedef struct isc_sockaddr	 isc_sockaddr_t;      /*%< Socket Address */
 typedef ISC_LIST(isc_sockaddr_t) isc_sockaddrlist_t;  /*%< Socket Address List
 						       * */
-typedef struct isc_stats    isc_stats_t;	      /*%< Statistics */
-typedef int_fast64_t	    isc_statscounter_t;
-typedef atomic_int_fast64_t isc_atomic_statscounter_t;
 typedef struct isc_symtab   isc_symtab_t;	/*%< Symbol Table */
 typedef struct isc_task	    isc_task_t;		/*%< Task */
 typedef ISC_LIST(isc_task_t) isc_tasklist_t;	/*%< Task List */
@@ -107,13 +97,6 @@ typedef enum {
 	isc_resource_stacksize
 } isc_resource_t;
 
-/*% Statistics formats (text file or XML) */
-typedef enum {
-	isc_statsformat_file,
-	isc_statsformat_xml,
-	isc_statsformat_json
-} isc_statsformat_t;
-
 typedef enum isc_nmsocket_type {
 	isc_nm_nonesocket = 0,
 	isc_nm_udpsocket = 1 << 1,
diff --git a/lib/isc/jemalloc_shim.h b/lib/isc/jemalloc_shim.h
--- a/lib/isc/jemalloc_shim.h
+++ b/lib/isc/jemalloc_shim.h
@@ -13,8 +13,6 @@
 
 #pragma once
 
-#if !defined(HAVE_JEMALLOC)
-
 #include <stddef.h>
 
 #include <isc/util.h>
@@ -77,5 +75,3 @@ rallocx(void *ptr, size_t size, int flags) {
 
 	return ptr;
 }
-
-#endif /* !defined(HAVE_JEMALLOC) */
diff --git a/lib/isc/log.c b/lib/isc/log.c
--- a/lib/isc/log.c
+++ b/lib/isc/log.c
@@ -166,13 +166,6 @@ struct isc_log {
 static const char *log_level_strings[] = { "debug",   "info",  "notice",
 					   "warning", "error", "critical" };
 
-/*!
- * Used to convert ISC_LOG_* priorities into syslog priorities.
- * XXXDCL This will need modification for NT.
- */
-static const int syslog_map[] = { LOG_DEBUG,   LOG_INFO, LOG_NOTICE,
-				  LOG_WARNING, LOG_ERR,	 LOG_CRIT };
-
 /*!
  * When adding new categories, a corresponding ISC_LOGCATEGORY_foo
  * definition needs to be added to <isc/log.h>.
@@ -221,9 +214,6 @@ sync_channellist(isc_logconfig_t *lcfg);
 static void
 sync_highest_level(isc_log_t *lctx, isc_logconfig_t *lcfg);
 
-static isc_result_t
-greatest_version(isc_logfile_t *file, int versions, int *greatest);
-
 static void
 isc_log_doit(isc_log_t *lctx, isc_logcategory_t *category,
 	     isc_logmodule_t *module, int level, bool write_once,
@@ -235,12 +225,9 @@ isc_log_doit(isc_log_t *lctx, isc_logcategory_t *category,
  */
 
 #define FACILITY(channel)	 (channel->destination.facility)
-#define FILE_NAME(channel)	 (channel->destination.file.name)
 #define FILE_STREAM(channel)	 (channel->destination.file.stream)
 #define FILE_VERSIONS(channel)	 (channel->destination.file.versions)
 #define FILE_SUFFIX(channel)	 (channel->destination.file.suffix)
-#define FILE_MAXSIZE(channel)	 (channel->destination.file.maximum_size)
-#define FILE_MAXREACHED(channel) (channel->destination.file.maximum_reached)
 
 /*@}*/
 /****
@@ -324,17 +311,13 @@ isc_logconfig_create(isc_log_t *lctx, isc_logconfig_t **lcfgp) {
 	 * Create the default channels:
 	 *      default_syslog, default_stderr, default_debug and null.
 	 */
-	destination.facility = LOG_DAEMON;
-	isc_log_createchannel(lcfg, "default_syslog", ISC_LOG_TOSYSLOG, level,
-			      &destination, 0);
-
 	destination.file.stream = stderr;
-	destination.file.name = NULL;
 	destination.file.versions = ISC_LOG_ROLLNEVER;
 	destination.file.suffix = isc_log_rollsuffix_increment;
-	destination.file.maximum_size = 0;
 	isc_log_createchannel(lcfg, "default_stderr", ISC_LOG_TOFILEDESC, level,
 			      &destination, ISC_LOG_PRINTTIME);
+	isc_log_createchannel(lcfg, "default_syslog", ISC_LOG_TOFILEDESC, level,
+			      &destination, ISC_LOG_PRINTTIME);
 
 	/*
 	 * Set the default category's channel to default_stderr,
@@ -344,10 +327,8 @@ isc_logconfig_create(isc_log_t *lctx, isc_logconfig_t **lcfgp) {
 	default_channel.channel = ISC_LIST_HEAD(lcfg->channels);
 
 	destination.file.stream = stderr;
-	destination.file.name = NULL;
 	destination.file.versions = ISC_LOG_ROLLNEVER;
 	destination.file.suffix = isc_log_rollsuffix_increment;
-	destination.file.maximum_size = 0;
 	isc_log_createchannel(lcfg, "default_debug", ISC_LOG_TOFILEDESC,
 			      ISC_LOG_DYNAMIC, &destination, ISC_LOG_PRINTTIME);
 
@@ -434,7 +415,6 @@ isc_logconfig_destroy(isc_logconfig_t **lcfgp) {
 	isc_logconfig_t *lcfg;
 	isc_mem_t *mctx;
 	isc_logchannel_t *channel;
-	char *filename;
 	unsigned int i;
 
 	REQUIRE(lcfgp != NULL && VALID_CONFIG(*lcfgp));
@@ -457,21 +437,6 @@ isc_logconfig_destroy(isc_logconfig_t **lcfgp) {
 	while ((channel = ISC_LIST_HEAD(lcfg->channels)) != NULL) {
 		ISC_LIST_UNLINK(lcfg->channels, channel, link);
 
-		if (channel->type == ISC_LOG_TOFILE) {
-			/*
-			 * The filename for the channel may have ultimately
-			 * started its life in user-land as a const string,
-			 * but in isc_log_createchannel it gets copied
-			 * into writable memory and is not longer truly const.
-			 */
-			DE_CONST(FILE_NAME(channel), filename);
-			isc_mem_free(mctx, filename);
-
-			if (FILE_STREAM(channel) != NULL) {
-				(void)fclose(FILE_STREAM(channel));
-			}
-		}
-
 		isc_mem_free(mctx, channel->name);
 		isc_mem_put(mctx, channel, sizeof(*channel));
 	}
@@ -657,8 +622,8 @@ isc_log_createchannel(isc_logconfig_t *lcfg, const char *name,
 
 	REQUIRE(VALID_CONFIG(lcfg));
 	REQUIRE(name != NULL);
-	REQUIRE(type == ISC_LOG_TOSYSLOG || type == ISC_LOG_TOFILE ||
-		type == ISC_LOG_TOFILEDESC || type == ISC_LOG_TONULL);
+	REQUIRE(type == ISC_LOG_TOSYSLOG || type == ISC_LOG_TOFILEDESC ||
+		type == ISC_LOG_TONULL);
 	REQUIRE(destination != NULL || type == ISC_LOG_TONULL);
 	REQUIRE(level >= ISC_LOG_CRITICAL);
 	REQUIRE((flags & ~permitted) == 0);
@@ -681,25 +646,8 @@ isc_log_createchannel(isc_logconfig_t *lcfg, const char *name,
 		FACILITY(channel) = destination->facility;
 		break;
 
-	case ISC_LOG_TOFILE:
-		/*
-		 * The file name is copied because greatest_version wants
-		 * to scribble on it, so it needs to be definitely in
-		 * writable memory.
-		 */
-		FILE_NAME(channel) = isc_mem_strdup(mctx,
-						    destination->file.name);
-		FILE_STREAM(channel) = NULL;
-		FILE_VERSIONS(channel) = destination->file.versions;
-		FILE_SUFFIX(channel) = destination->file.suffix;
-		FILE_MAXSIZE(channel) = destination->file.maximum_size;
-		FILE_MAXREACHED(channel) = false;
-		break;
-
 	case ISC_LOG_TOFILEDESC:
-		FILE_NAME(channel) = NULL;
 		FILE_STREAM(channel) = destination->file.stream;
-		FILE_MAXSIZE(channel) = 0;
 		FILE_VERSIONS(channel) = ISC_LOG_ROLLNEVER;
 		FILE_SUFFIX(channel) = isc_log_rollsuffix_increment;
 		break;
@@ -830,31 +778,6 @@ isc_log_setdebuglevel(isc_log_t *lctx, unsigned int level) {
 	REQUIRE(VALID_CONTEXT(lctx));
 
 	atomic_store_release(&lctx->debug_level, level);
-	/*
-	 * Close ISC_LOG_DEBUGONLY channels if level is zero.
-	 */
-	if (level == 0) {
-		RDLOCK(&lctx->lcfg_rwl);
-		isc_logconfig_t *lcfg = lctx->logconfig;
-		if (lcfg != NULL) {
-			LOCK(&lctx->lock);
-			for (isc_logchannel_t *channel =
-				     ISC_LIST_HEAD(lcfg->channels);
-			     channel != NULL;
-			     channel = ISC_LIST_NEXT(channel, link))
-			{
-				if (channel->type == ISC_LOG_TOFILE &&
-				    (channel->flags & ISC_LOG_DEBUGONLY) != 0 &&
-				    FILE_STREAM(channel) != NULL)
-				{
-					(void)fclose(FILE_STREAM(channel));
-					FILE_STREAM(channel) = NULL;
-				}
-			}
-			UNLOCK(&lctx->lock);
-		}
-		RDUNLOCK(&lctx->lcfg_rwl);
-	}
 }
 
 unsigned int
@@ -902,35 +825,6 @@ isc_log_gettag(isc_logconfig_t *lcfg) {
 	return lcfg->tag;
 }
 
-/* XXXDCL NT  -- This interface will assuredly be changing. */
-void
-isc_log_opensyslog(const char *tag, int options, int facility) {
-	(void)openlog(tag, options, facility);
-}
-
-void
-isc_log_closefilelogs(isc_log_t *lctx) {
-	REQUIRE(VALID_CONTEXT(lctx));
-
-	RDLOCK(&lctx->lcfg_rwl);
-	isc_logconfig_t *lcfg = lctx->logconfig;
-	if (lcfg != NULL) {
-		LOCK(&lctx->lock);
-		for (isc_logchannel_t *channel = ISC_LIST_HEAD(lcfg->channels);
-		     channel != NULL; channel = ISC_LIST_NEXT(channel, link))
-		{
-			if (channel->type == ISC_LOG_TOFILE &&
-			    FILE_STREAM(channel) != NULL)
-			{
-				(void)fclose(FILE_STREAM(channel));
-				FILE_STREAM(channel) = NULL;
-			}
-		}
-		UNLOCK(&lctx->lock);
-	}
-	RDUNLOCK(&lctx->lcfg_rwl);
-}
-
 /****
 **** Internal functions
 ****/
@@ -1019,366 +913,8 @@ sync_highest_level(isc_log_t *lctx, isc_logconfig_t *lcfg) {
 	atomic_store(&lctx->dynamic, lcfg->dynamic);
 }
 
-static isc_result_t
-greatest_version(isc_logfile_t *file, int versions, int *greatestp) {
-	char *digit_end;
-	char dirbuf[PATH_MAX + 1];
-	const char *bname;
-	const char *dirname = ".";
-	int version, greatest = -1;
-	isc_dir_t dir;
-	isc_result_t result;
-	size_t bnamelen;
-
-	bname = strrchr(file->name, '/');
-	if (bname != NULL) {
-		/*
-		 * Copy the complete file name to dirbuf.
-		 */
-		size_t len = strlcpy(dirbuf, file->name, sizeof(dirbuf));
-		if (len >= sizeof(dirbuf)) {
-			result = ISC_R_NOSPACE;
-			syslog(LOG_ERR, "unable to remove log files: %s",
-			       isc_result_totext(result));
-			return result;
-		}
-
-		/*
-		 * Truncate after trailing '/' so the code works for
-		 * files in the root directory.
-		 */
-		bname++;
-		dirbuf[bname - file->name] = '\0';
-		dirname = dirbuf;
-	} else {
-		bname = file->name;
-	}
-	bnamelen = strlen(bname);
-
-	isc_dir_init(&dir);
-	result = isc_dir_open(&dir, dirname);
-
-	/*
-	 * Return if the directory open failed.
-	 */
-	if (result != ISC_R_SUCCESS) {
-		return result;
-	}
-
-	while (isc_dir_read(&dir) == ISC_R_SUCCESS) {
-		if (dir.entry.length > bnamelen &&
-		    strncmp(dir.entry.name, bname, bnamelen) == 0 &&
-		    dir.entry.name[bnamelen] == '.')
-		{
-			version = strtol(&dir.entry.name[bnamelen + 1],
-					 &digit_end, 10);
-			/*
-			 * Remove any backup files that exceed versions.
-			 */
-			if (*digit_end == '\0' && version >= versions) {
-				int n = dirfd(dir.handle);
-				if (n >= 0) {
-					n = unlinkat(n, dir.entry.name, 0);
-				}
-				if (n < 0) {
-					result = isc_errno_toresult(errno);
-					if (result != ISC_R_SUCCESS &&
-					    result != ISC_R_FILENOTFOUND)
-					{
-						syslog(LOG_ERR,
-						       "unable to remove log "
-						       "file '%s%s': %s",
-						       bname == file->name
-							       ? ""
-							       : dirname,
-						       dir.entry.name,
-						       isc_result_totext(
-							       result));
-					}
-				}
-			} else if (*digit_end == '\0' && version > greatest) {
-				greatest = version;
-			}
-		}
-	}
-	isc_dir_close(&dir);
-
-	*greatestp = greatest;
-	return ISC_R_SUCCESS;
-}
-
-static void
-insert_sort(int64_t to_keep[], int64_t versions, int64_t version) {
-	int i = 0;
-	while (i < versions && version < to_keep[i]) {
-		i++;
-	}
-	if (i == versions) {
-		return;
-	}
-	if (i < versions - 1) {
-		memmove(&to_keep[i + 1], &to_keep[i],
-			sizeof(to_keep[0]) * (versions - i - 1));
-	}
-	to_keep[i] = version;
-}
-
-static int64_t
-last_to_keep(int64_t versions, isc_dir_t *dirp, const char *bname,
-	     size_t bnamelen) {
-	int64_t to_keep[ISC_LOG_MAX_VERSIONS] = { 0 };
-	int64_t version = 0;
-
-	if (versions <= 0) {
-		return INT64_MAX;
-	}
-
-	if (versions > ISC_LOG_MAX_VERSIONS) {
-		versions = ISC_LOG_MAX_VERSIONS;
-	}
-	/*
-	 * First we fill 'to_keep' structure using insertion sort
-	 */
-	memset(to_keep, 0, sizeof(to_keep));
-	while (isc_dir_read(dirp) == ISC_R_SUCCESS) {
-		char *digit_end = NULL;
-		char *ename = NULL;
-
-		if (dirp->entry.length <= bnamelen ||
-		    strncmp(dirp->entry.name, bname, bnamelen) != 0 ||
-		    dirp->entry.name[bnamelen] != '.')
-		{
-			continue;
-		}
-
-		ename = &dirp->entry.name[bnamelen + 1];
-		version = strtoull(ename, &digit_end, 10);
-		if (*digit_end == '\0') {
-			insert_sort(to_keep, versions, version);
-		}
-	}
-
-	isc_dir_reset(dirp);
-
-	/*
-	 * to_keep[versions - 1] is the last one we want to keep
-	 */
-	return to_keep[versions - 1];
-}
-
-static isc_result_t
-remove_old_tsversions(isc_logfile_t *file, int versions) {
-	char *digit_end;
-	char dirbuf[PATH_MAX + 1];
-	const char *bname;
-	const char *dirname = ".";
-	int64_t version, last = INT64_MAX;
-	isc_dir_t dir;
-	isc_result_t result;
-	size_t bnamelen;
-
-	bname = strrchr(file->name, '/');
-	if (bname != NULL) {
-		/*
-		 * Copy the complete file name to dirbuf.
-		 */
-		size_t len = strlcpy(dirbuf, file->name, sizeof(dirbuf));
-		if (len >= sizeof(dirbuf)) {
-			result = ISC_R_NOSPACE;
-			syslog(LOG_ERR, "unable to remove log files: %s",
-			       isc_result_totext(result));
-			return result;
-		}
-
-		/*
-		 * Truncate after trailing '/' so the code works for
-		 * files in the root directory.
-		 */
-		bname++;
-		dirbuf[bname - file->name] = '\0';
-		dirname = dirbuf;
-	} else {
-		bname = file->name;
-	}
-	bnamelen = strlen(bname);
-
-	isc_dir_init(&dir);
-	result = isc_dir_open(&dir, dirname);
-
-	/*
-	 * Return if the directory open failed.
-	 */
-	if (result != ISC_R_SUCCESS) {
-		return result;
-	}
-
-	last = last_to_keep(versions, &dir, bname, bnamelen);
-
-	while (isc_dir_read(&dir) == ISC_R_SUCCESS) {
-		if (dir.entry.length > bnamelen &&
-		    strncmp(dir.entry.name, bname, bnamelen) == 0 &&
-		    dir.entry.name[bnamelen] == '.')
-		{
-			version = strtoull(&dir.entry.name[bnamelen + 1],
-					   &digit_end, 10);
-			/*
-			 * Remove any backup files that exceed versions.
-			 */
-			if (*digit_end == '\0' && version < last) {
-				int n = dirfd(dir.handle);
-				if (n >= 0) {
-					n = unlinkat(n, dir.entry.name, 0);
-				}
-				if (n < 0) {
-					result = isc_errno_toresult(errno);
-					if (result != ISC_R_SUCCESS &&
-					    result != ISC_R_FILENOTFOUND)
-					{
-						syslog(LOG_ERR,
-						       "unable to remove log "
-						       "file '%s%s': %s",
-						       bname == file->name
-							       ? ""
-							       : dirname,
-						       dir.entry.name,
-						       isc_result_totext(
-							       result));
-					}
-				}
-			}
-		}
-	}
-	isc_dir_close(&dir);
-	return ISC_R_SUCCESS;
-}
-
-static isc_result_t
-roll_increment(isc_logfile_t *file) {
-	int i, n, greatest;
-	char current[PATH_MAX + 1];
-	char newpath[PATH_MAX + 1];
-	const char *path;
-	isc_result_t result = ISC_R_SUCCESS;
-
-	REQUIRE(file != NULL);
-	REQUIRE(file->versions != 0);
-
-	path = file->name;
-
-	if (file->versions == ISC_LOG_ROLLINFINITE) {
-		/*
-		 * Find the first missing entry in the log file sequence.
-		 */
-		for (greatest = 0; greatest < INT_MAX; greatest++) {
-			n = snprintf(current, sizeof(current), "%s.%u", path,
-				     (unsigned)greatest);
-			if (n >= (int)sizeof(current) || n < 0 ||
-			    !isc_file_exists(current))
-			{
-				break;
-			}
-		}
-	} else {
-		/*
-		 * Get the largest existing version and remove any
-		 * version greater than the permitted version.
-		 */
-		result = greatest_version(file, file->versions, &greatest);
-		if (result != ISC_R_SUCCESS) {
-			return result;
-		}
-
-		/*
-		 * Increment if greatest is not the actual maximum value.
-		 */
-		if (greatest < file->versions - 1) {
-			greatest++;
-		}
-	}
-
-	for (i = greatest; i > 0; i--) {
-		result = ISC_R_SUCCESS;
-		n = snprintf(current, sizeof(current), "%s.%u", path,
-			     (unsigned)(i - 1));
-		if (n >= (int)sizeof(current) || n < 0) {
-			result = ISC_R_NOSPACE;
-		}
-		if (result == ISC_R_SUCCESS) {
-			n = snprintf(newpath, sizeof(newpath), "%s.%u", path,
-				     (unsigned)i);
-			if (n >= (int)sizeof(newpath) || n < 0) {
-				result = ISC_R_NOSPACE;
-			}
-		}
-		if (result == ISC_R_SUCCESS) {
-			result = isc_file_rename(current, newpath);
-		}
-		if (result != ISC_R_SUCCESS && result != ISC_R_FILENOTFOUND) {
-			syslog(LOG_ERR,
-			       "unable to rename log file '%s.%u' to "
-			       "'%s.%u': %s",
-			       path, i - 1, path, i, isc_result_totext(result));
-		}
-	}
-
-	n = snprintf(newpath, sizeof(newpath), "%s.0", path);
-	if (n >= (int)sizeof(newpath) || n < 0) {
-		result = ISC_R_NOSPACE;
-	} else {
-		result = isc_file_rename(path, newpath);
-	}
-	if (result != ISC_R_SUCCESS && result != ISC_R_FILENOTFOUND) {
-		syslog(LOG_ERR, "unable to rename log file '%s' to '%s.0': %s",
-		       path, path, isc_result_totext(result));
-	}
-
-	return ISC_R_SUCCESS;
-}
-
-static isc_result_t
-roll_timestamp(isc_logfile_t *file) {
-	int n;
-	char newts[PATH_MAX + 1];
-	char newpath[PATH_MAX + 1];
-	const char *path;
-	isc_time_t now;
-	isc_result_t result = ISC_R_SUCCESS;
-
-	REQUIRE(file != NULL);
-	REQUIRE(file->versions != 0);
-
-	path = file->name;
-
-	/*
-	 * First find all the logfiles and remove the oldest ones
-	 * Save one fewer than file->versions because we'll be renaming
-	 * the existing file to a timestamped version after this.
-	 */
-	if (file->versions != ISC_LOG_ROLLINFINITE) {
-		remove_old_tsversions(file, file->versions - 1);
-	}
-
-	/* Then just rename the current logfile */
-	isc_time_now(&now);
-	isc_time_formatshorttimestamp(&now, newts, PATH_MAX + 1);
-	n = snprintf(newpath, sizeof(newpath), "%s.%s", path, newts);
-	if (n >= (int)sizeof(newpath) || n < 0) {
-		result = ISC_R_NOSPACE;
-	} else {
-		result = isc_file_rename(path, newpath);
-	}
-	if (result != ISC_R_SUCCESS && result != ISC_R_FILENOTFOUND) {
-		syslog(LOG_ERR, "unable to rename log file '%s' to '%s.0': %s",
-		       path, path, isc_result_totext(result));
-	}
-
-	return ISC_R_SUCCESS;
-}
-
 isc_result_t
 isc_logfile_roll(isc_logfile_t *file) {
-	isc_result_t result;
-
 	REQUIRE(file != NULL);
 
 	/*
@@ -1388,86 +924,9 @@ isc_logfile_roll(isc_logfile_t *file) {
 	 */
 	if (file->versions == ISC_LOG_ROLLNEVER) {
 		return ISC_R_SUCCESS;
-	} else if (file->versions == 0) {
-		result = isc_file_remove(file->name);
-		if (result != ISC_R_SUCCESS && result != ISC_R_FILENOTFOUND) {
-			syslog(LOG_ERR, "unable to remove log file '%s': %s",
-			       file->name, isc_result_totext(result));
-		}
-		return ISC_R_SUCCESS;
-	}
-
-	switch (file->suffix) {
-	case isc_log_rollsuffix_increment:
-		return roll_increment(file);
-	case isc_log_rollsuffix_timestamp:
-		return roll_timestamp(file);
-	default:
-		return ISC_R_UNEXPECTED;
-	}
-}
-
-static isc_result_t
-isc_log_open(isc_logchannel_t *channel) {
-	struct stat statbuf;
-	bool regular_file;
-	bool roll = false;
-	isc_result_t result = ISC_R_SUCCESS;
-	const char *path;
-
-	REQUIRE(channel->type == ISC_LOG_TOFILE);
-	REQUIRE(FILE_STREAM(channel) == NULL);
-
-	path = FILE_NAME(channel);
-
-	REQUIRE(path != NULL && *path != '\0');
-
-	/*
-	 * Determine type of file; only regular files will be
-	 * version renamed, and only if the base file exists
-	 * and either has no size limit or has reached its size limit.
-	 */
-	if (stat(path, &statbuf) == 0) {
-		regular_file = S_ISREG(statbuf.st_mode) ? true : false;
-		/* XXXDCL if not regular_file complain? */
-		if ((FILE_MAXSIZE(channel) == 0 &&
-		     FILE_VERSIONS(channel) != ISC_LOG_ROLLNEVER) ||
-		    (FILE_MAXSIZE(channel) > 0 &&
-		     statbuf.st_size >= FILE_MAXSIZE(channel)))
-		{
-			roll = regular_file;
-		}
-	} else if (errno == ENOENT) {
-		regular_file = true;
-		POST(regular_file);
-	} else {
-		result = ISC_R_INVALIDFILE;
-	}
-
-	/*
-	 * Version control.
-	 */
-	if (result == ISC_R_SUCCESS && roll) {
-		if (FILE_VERSIONS(channel) == ISC_LOG_ROLLNEVER) {
-			return ISC_R_MAXSIZE;
-		}
-		result = isc_logfile_roll(&channel->destination.file);
-		if (result != ISC_R_SUCCESS) {
-			if ((channel->flags & ISC_LOG_OPENERR) == 0) {
-				syslog(LOG_ERR,
-				       "isc_log_open: isc_logfile_roll '%s' "
-				       "failed: %s",
-				       FILE_NAME(channel),
-				       isc_result_totext(result));
-				channel->flags |= ISC_LOG_OPENERR;
-			}
-			return result;
-		}
 	}
 
-	result = isc_stdio_open(path, "a", &FILE_STREAM(channel));
-
-	return result;
+	return ISC_R_UNEXPECTED;
 }
 
 ISC_NO_SANITIZE_THREAD bool
@@ -1507,20 +966,17 @@ static void
 isc_log_doit(isc_log_t *lctx, isc_logcategory_t *category,
 	     isc_logmodule_t *module, int level, bool write_once,
 	     const char *format, va_list args) {
-	int syslog_level;
 	const char *time_string;
 	char local_time[64];
 	char iso8601z_string[64];
 	char iso8601l_string[64];
 	char level_string[24] = { 0 };
-	struct stat statbuf;
 	bool matched = false;
 	bool printtime, iso8601, utc, printtag, printcolon;
 	bool printcategory, printmodule, printlevel, buffered;
 	isc_logchannel_t *channel;
 	isc_logchannellist_t *category_channels;
 	int_fast32_t dlevel;
-	isc_result_t result;
 
 	REQUIRE(lctx == NULL || VALID_CONTEXT(lctx));
 	REQUIRE(category != NULL);
@@ -1787,55 +1243,6 @@ isc_log_doit(isc_log_t *lctx, isc_logcategory_t *category,
 		}
 
 		switch (channel->type) {
-		case ISC_LOG_TOFILE:
-			if (FILE_MAXREACHED(channel)) {
-				/*
-				 * If the file can be rolled, OR
-				 * If the file no longer exists, OR
-				 * If the file is less than the maximum
-				 * size, (such as if it had been renamed
-				 * and a new one touched, or it was
-				 * truncated in place)
-				 * ... then close it to trigger
-				 * reopening.
-				 */
-				if (FILE_VERSIONS(channel) !=
-					    ISC_LOG_ROLLNEVER ||
-				    (stat(FILE_NAME(channel), &statbuf) != 0 &&
-				     errno == ENOENT) ||
-				    statbuf.st_size < FILE_MAXSIZE(channel))
-				{
-					(void)fclose(FILE_STREAM(channel));
-					FILE_STREAM(channel) = NULL;
-					FILE_MAXREACHED(channel) = false;
-				} else {
-					/*
-					 * Eh, skip it.
-					 */
-					break;
-				}
-			}
-
-			if (FILE_STREAM(channel) == NULL) {
-				result = isc_log_open(channel);
-				if (result != ISC_R_SUCCESS &&
-				    result != ISC_R_MAXSIZE &&
-				    (channel->flags & ISC_LOG_OPENERR) == 0)
-				{
-					syslog(LOG_ERR,
-					       "isc_log_open '%s' "
-					       "failed: %s",
-					       FILE_NAME(channel),
-					       isc_result_totext(result));
-					channel->flags |= ISC_LOG_OPENERR;
-				}
-				if (result != ISC_R_SUCCESS) {
-					break;
-				}
-				channel->flags &= ~ISC_LOG_OPENERR;
-			}
-			FALLTHROUGH;
-
 		case ISC_LOG_TOFILEDESC:
 			fprintf(FILE_STREAM(channel), "%s%s%s%s%s%s%s%s%s%s\n",
 				printtime ? time_string : "",
@@ -1853,38 +1260,12 @@ isc_log_doit(isc_log_t *lctx, isc_logcategory_t *category,
 				fflush(FILE_STREAM(channel));
 			}
 
-			/*
-			 * If the file now exceeds its maximum size
-			 * threshold, note it so that it will not be
-			 * logged to any more.
-			 */
-			if (FILE_MAXSIZE(channel) > 0) {
-				INSIST(channel->type == ISC_LOG_TOFILE);
-
-				/* XXXDCL NT fstat/fileno */
-				/* XXXDCL complain if fstat fails? */
-				if (fstat(fileno(FILE_STREAM(channel)),
-					  &statbuf) >= 0 &&
-				    statbuf.st_size > FILE_MAXSIZE(channel))
-				{
-					FILE_MAXREACHED(channel) = true;
-				}
-			}
-
 			break;
 
 		case ISC_LOG_TOSYSLOG:
-			if (level > 0) {
-				syslog_level = LOG_DEBUG;
-			} else if (level < ISC_LOG_CRITICAL) {
-				syslog_level = LOG_CRIT;
-			} else {
-				syslog_level = syslog_map[-level];
-			}
-
-			(void)syslog(
-				FACILITY(channel) | syslog_level,
-				"%s%s%s%s%s%s%s%s%s%s",
+			fprintf(
+				stderr,
+				"%s%s%s%s%s%s%s%s%s%s\n",
 				printtime ? time_string : "",
 				printtime ? " " : "", printtag ? lcfg->tag : "",
 				printcolon ? ": " : "",
diff --git a/lib/isc/mem.c b/lib/isc/mem.c
--- a/lib/isc/mem.c
+++ b/lib/isc/mem.c
@@ -34,28 +34,10 @@
 #include <isc/types.h>
 #include <isc/util.h>
 
-#ifdef HAVE_LIBXML2
-#include <libxml/xmlwriter.h>
-#define ISC_XMLCHAR (const xmlChar *)
-#endif /* HAVE_LIBXML2 */
-
-#ifdef HAVE_JSON_C
-#include <json_object.h>
-#endif /* HAVE_JSON_C */
-
 /* On DragonFly BSD the header does not provide jemalloc API */
 #if defined(HAVE_MALLOC_NP_H) && !defined(__DragonFly__)
 #include <malloc_np.h>
 #define JEMALLOC_API_SUPPORTED 1
-#elif defined(HAVE_JEMALLOC)
-#include <jemalloc/jemalloc.h>
-#define JEMALLOC_API_SUPPORTED 1
-
-#if JEMALLOC_VERSION_MAJOR < 4
-#define sdallocx(ptr, size, flags) dallocx(ptr, flags)
-#define MALLOCX_TCACHE_NONE	   (0)
-#endif /* JEMALLOC_VERSION_MAJOR < 4 */
-
 #else
 #include "jemalloc_shim.h"
 #endif
@@ -1517,297 +1499,6 @@ typedef struct summarystat {
 	uint64_t contextsize;
 } summarystat_t;
 
-#ifdef HAVE_LIBXML2
-#define TRY0(a)                     \
-	do {                        \
-		xmlrc = (a);        \
-		if (xmlrc < 0)      \
-			goto error; \
-	} while (0)
-static int
-xml_renderctx(isc_mem_t *ctx, summarystat_t *summary, xmlTextWriterPtr writer) {
-	REQUIRE(VALID_CONTEXT(ctx));
-
-	int xmlrc;
-
-	MCTXLOCK(ctx);
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "context"));
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "id"));
-	TRY0(xmlTextWriterWriteFormatString(writer, "%p", ctx));
-	TRY0(xmlTextWriterEndElement(writer)); /* id */
-
-	if (ctx->name[0] != 0) {
-		TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "name"));
-		TRY0(xmlTextWriterWriteFormatString(writer, "%s", ctx->name));
-		TRY0(xmlTextWriterEndElement(writer)); /* name */
-	}
-
-	summary->contextsize += sizeof(*ctx);
-#if ISC_MEM_TRACKLINES
-	if (ctx->debuglist != NULL) {
-		summary->contextsize += DEBUG_TABLE_COUNT *
-						sizeof(debuglist_t) +
-					ctx->debuglistcnt * sizeof(debuglink_t);
-	}
-#endif /* if ISC_MEM_TRACKLINES */
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "references"));
-	TRY0(xmlTextWriterWriteFormatString(
-		writer, "%" PRIuFAST32,
-		isc_refcount_current(&ctx->references)));
-	TRY0(xmlTextWriterEndElement(writer)); /* references */
-
-	summary->total += isc_mem_total(ctx);
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "total"));
-	TRY0(xmlTextWriterWriteFormatString(writer, "%" PRIu64 "",
-					    (uint64_t)isc_mem_total(ctx)));
-	TRY0(xmlTextWriterEndElement(writer)); /* total */
-
-	summary->inuse += isc_mem_inuse(ctx);
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "inuse"));
-	TRY0(xmlTextWriterWriteFormatString(writer, "%" PRIu64 "",
-					    (uint64_t)isc_mem_inuse(ctx)));
-	TRY0(xmlTextWriterEndElement(writer)); /* inuse */
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "maxinuse"));
-	TRY0(xmlTextWriterWriteFormatString(writer, "%" PRIu64 "",
-					    (uint64_t)isc_mem_maxinuse(ctx)));
-	TRY0(xmlTextWriterEndElement(writer)); /* maxinuse */
-
-	summary->malloced += isc_mem_malloced(ctx);
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "malloced"));
-	TRY0(xmlTextWriterWriteFormatString(writer, "%" PRIu64 "",
-					    (uint64_t)isc_mem_malloced(ctx)));
-	TRY0(xmlTextWriterEndElement(writer)); /* malloced */
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "maxmalloced"));
-	TRY0(xmlTextWriterWriteFormatString(
-		writer, "%" PRIu64 "", (uint64_t)isc_mem_maxmalloced(ctx)));
-	TRY0(xmlTextWriterEndElement(writer)); /* maxmalloced */
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "pools"));
-	TRY0(xmlTextWriterWriteFormatString(writer, "%u", ctx->poolcnt));
-	TRY0(xmlTextWriterEndElement(writer)); /* pools */
-	summary->contextsize += ctx->poolcnt * sizeof(isc_mempool_t);
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "hiwater"));
-	TRY0(xmlTextWriterWriteFormatString(
-		writer, "%" PRIu64 "",
-		(uint64_t)atomic_load_relaxed(&ctx->hi_water)));
-	TRY0(xmlTextWriterEndElement(writer)); /* hiwater */
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "lowater"));
-	TRY0(xmlTextWriterWriteFormatString(
-		writer, "%" PRIu64 "",
-		(uint64_t)atomic_load_relaxed(&ctx->lo_water)));
-	TRY0(xmlTextWriterEndElement(writer)); /* lowater */
-
-	TRY0(xmlTextWriterEndElement(writer)); /* context */
-
-error:
-	MCTXUNLOCK(ctx);
-
-	return xmlrc;
-}
-
-int
-isc_mem_renderxml(void *writer0) {
-	isc_mem_t *ctx;
-	summarystat_t summary = { 0 };
-	uint64_t lost;
-	int xmlrc;
-	xmlTextWriterPtr writer = (xmlTextWriterPtr)writer0;
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "contexts"));
-
-	LOCK(&contextslock);
-	lost = totallost;
-	for (ctx = ISC_LIST_HEAD(contexts); ctx != NULL;
-	     ctx = ISC_LIST_NEXT(ctx, link))
-	{
-		xmlrc = xml_renderctx(ctx, &summary, writer);
-		if (xmlrc < 0) {
-			UNLOCK(&contextslock);
-			goto error;
-		}
-	}
-	UNLOCK(&contextslock);
-
-	TRY0(xmlTextWriterEndElement(writer)); /* contexts */
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "summary"));
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "TotalUse"));
-	TRY0(xmlTextWriterWriteFormatString(writer, "%" PRIu64 "",
-					    summary.total));
-	TRY0(xmlTextWriterEndElement(writer)); /* TotalUse */
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "InUse"));
-	TRY0(xmlTextWriterWriteFormatString(writer, "%" PRIu64 "",
-					    summary.inuse));
-	TRY0(xmlTextWriterEndElement(writer)); /* InUse */
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "Malloced"));
-	TRY0(xmlTextWriterWriteFormatString(writer, "%" PRIu64 "",
-					    summary.malloced));
-	TRY0(xmlTextWriterEndElement(writer)); /* InUse */
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "ContextSize"));
-	TRY0(xmlTextWriterWriteFormatString(writer, "%" PRIu64 "",
-					    summary.contextsize));
-	TRY0(xmlTextWriterEndElement(writer)); /* ContextSize */
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "Lost"));
-	TRY0(xmlTextWriterWriteFormatString(writer, "%" PRIu64 "", lost));
-	TRY0(xmlTextWriterEndElement(writer)); /* Lost */
-
-	TRY0(xmlTextWriterEndElement(writer)); /* summary */
-error:
-	return xmlrc;
-}
-
-#endif /* HAVE_LIBXML2 */
-
-#ifdef HAVE_JSON_C
-#define CHECKMEM(m) RUNTIME_CHECK(m != NULL)
-
-static isc_result_t
-json_renderctx(isc_mem_t *ctx, summarystat_t *summary, json_object *array) {
-	REQUIRE(VALID_CONTEXT(ctx));
-	REQUIRE(summary != NULL);
-	REQUIRE(array != NULL);
-
-	json_object *ctxobj, *obj;
-	char buf[1024];
-
-	MCTXLOCK(ctx);
-
-	summary->contextsize += sizeof(*ctx);
-	summary->total += isc_mem_total(ctx);
-	summary->inuse += isc_mem_inuse(ctx);
-	summary->malloced += isc_mem_malloced(ctx);
-#if ISC_MEM_TRACKLINES
-	if (ctx->debuglist != NULL) {
-		summary->contextsize += DEBUG_TABLE_COUNT *
-						sizeof(debuglist_t) +
-					ctx->debuglistcnt * sizeof(debuglink_t);
-	}
-#endif /* if ISC_MEM_TRACKLINES */
-
-	ctxobj = json_object_new_object();
-	CHECKMEM(ctxobj);
-
-	snprintf(buf, sizeof(buf), "%p", ctx);
-	obj = json_object_new_string(buf);
-	CHECKMEM(obj);
-	json_object_object_add(ctxobj, "id", obj);
-
-	if (ctx->name[0] != 0) {
-		obj = json_object_new_string(ctx->name);
-		CHECKMEM(obj);
-		json_object_object_add(ctxobj, "name", obj);
-	}
-
-	obj = json_object_new_int64(isc_refcount_current(&ctx->references));
-	CHECKMEM(obj);
-	json_object_object_add(ctxobj, "references", obj);
-
-	obj = json_object_new_int64(isc_mem_total(ctx));
-	CHECKMEM(obj);
-	json_object_object_add(ctxobj, "total", obj);
-
-	obj = json_object_new_int64(isc_mem_inuse(ctx));
-	CHECKMEM(obj);
-	json_object_object_add(ctxobj, "inuse", obj);
-
-	obj = json_object_new_int64(isc_mem_maxinuse(ctx));
-	CHECKMEM(obj);
-	json_object_object_add(ctxobj, "maxinuse", obj);
-
-	obj = json_object_new_int64(isc_mem_malloced(ctx));
-	CHECKMEM(obj);
-	json_object_object_add(ctxobj, "malloced", obj);
-
-	obj = json_object_new_int64(isc_mem_maxmalloced(ctx));
-	CHECKMEM(obj);
-	json_object_object_add(ctxobj, "maxmalloced", obj);
-
-	obj = json_object_new_int64(ctx->poolcnt);
-	CHECKMEM(obj);
-	json_object_object_add(ctxobj, "pools", obj);
-
-	summary->contextsize += ctx->poolcnt * sizeof(isc_mempool_t);
-
-	obj = json_object_new_int64(atomic_load_relaxed(&ctx->hi_water));
-	CHECKMEM(obj);
-	json_object_object_add(ctxobj, "hiwater", obj);
-
-	obj = json_object_new_int64(atomic_load_relaxed(&ctx->lo_water));
-	CHECKMEM(obj);
-	json_object_object_add(ctxobj, "lowater", obj);
-
-	MCTXUNLOCK(ctx);
-	json_object_array_add(array, ctxobj);
-	return ISC_R_SUCCESS;
-}
-
-isc_result_t
-isc_mem_renderjson(void *memobj0) {
-	isc_result_t result = ISC_R_SUCCESS;
-	isc_mem_t *ctx;
-	summarystat_t summary = { 0 };
-	uint64_t lost;
-	json_object *ctxarray, *obj;
-	json_object *memobj = (json_object *)memobj0;
-
-	ctxarray = json_object_new_array();
-	CHECKMEM(ctxarray);
-
-	LOCK(&contextslock);
-	lost = totallost;
-	for (ctx = ISC_LIST_HEAD(contexts); ctx != NULL;
-	     ctx = ISC_LIST_NEXT(ctx, link))
-	{
-		result = json_renderctx(ctx, &summary, ctxarray);
-		if (result != ISC_R_SUCCESS) {
-			UNLOCK(&contextslock);
-			goto error;
-		}
-	}
-	UNLOCK(&contextslock);
-
-	obj = json_object_new_int64(summary.total);
-	CHECKMEM(obj);
-	json_object_object_add(memobj, "TotalUse", obj);
-
-	obj = json_object_new_int64(summary.inuse);
-	CHECKMEM(obj);
-	json_object_object_add(memobj, "InUse", obj);
-
-	obj = json_object_new_int64(summary.malloced);
-	CHECKMEM(obj);
-	json_object_object_add(memobj, "Malloced", obj);
-
-	obj = json_object_new_int64(summary.contextsize);
-	CHECKMEM(obj);
-	json_object_object_add(memobj, "ContextSize", obj);
-
-	obj = json_object_new_int64(lost);
-	CHECKMEM(obj);
-	json_object_object_add(memobj, "Lost", obj);
-
-	json_object_object_add(memobj, "contexts", ctxarray);
-	return ISC_R_SUCCESS;
-
-error:
-	if (ctxarray != NULL) {
-		json_object_put(ctxarray);
-	}
-	return result;
-}
-#endif /* HAVE_JSON_C */
-
 void
 isc__mem_create(isc_mem_t **mctxp FLARG) {
 	mem_create(mctxp, isc_mem_defaultflags, 0);
diff --git a/lib/isc/net.c b/lib/isc/net.c
--- a/lib/isc/net.c
+++ b/lib/isc/net.c
@@ -22,7 +22,6 @@
 #endif /* if defined(HAVE_SYS_SYSCTL_H) && !defined(__linux__) */
 #include <errno.h>
 #include <fcntl.h>
-#include <sys/uio.h>
 #include <unistd.h>
 
 #include <isc/log.h>
@@ -139,42 +138,6 @@ try_proto(int domain) {
 		}
 	}
 
-	if (domain == PF_INET6) {
-		struct sockaddr_in6 sin6;
-		unsigned int len;
-
-		/*
-		 * Check to see if IPv6 is broken, as is common on Linux.
-		 */
-		len = sizeof(sin6);
-		if (getsockname(s, (struct sockaddr *)&sin6, (void *)&len) < 0)
-		{
-			isc_log_write(isc_lctx, ISC_LOGCATEGORY_GENERAL,
-				      ISC_LOGMODULE_SOCKET, ISC_LOG_ERROR,
-				      "retrieving the address of an IPv6 "
-				      "socket from the kernel failed.");
-			isc_log_write(isc_lctx, ISC_LOGCATEGORY_GENERAL,
-				      ISC_LOGMODULE_SOCKET, ISC_LOG_ERROR,
-				      "IPv6 is not supported.");
-			result = ISC_R_NOTFOUND;
-		} else {
-			if (len == sizeof(struct sockaddr_in6)) {
-				result = ISC_R_SUCCESS;
-			} else {
-				isc_log_write(isc_lctx, ISC_LOGCATEGORY_GENERAL,
-					      ISC_LOGMODULE_SOCKET,
-					      ISC_LOG_ERROR,
-					      "IPv6 structures in kernel and "
-					      "user space do not match.");
-				isc_log_write(isc_lctx, ISC_LOGCATEGORY_GENERAL,
-					      ISC_LOGMODULE_SOCKET,
-					      ISC_LOG_ERROR,
-					      "IPv6 is not supported.");
-				result = ISC_R_NOTFOUND;
-			}
-		}
-	}
-
 	(void)close(s);
 
 	return result;
@@ -184,7 +147,7 @@ static void
 initialize_action(void) {
 	ipv4_result = try_proto(PF_INET);
 	ipv6_result = try_proto(PF_INET6);
-	unix_result = try_proto(PF_UNIX);
+	unix_result = ISC_R_NOTFOUND;
 }
 
 static void
@@ -213,7 +176,8 @@ isc_net_probeunix(void) {
 static void
 try_ipv6only(void) {
 #ifdef IPV6_V6ONLY
-	int s, on;
+	int s;
+	DWORD on;
 #endif /* ifdef IPV6_V6ONLY */
 	isc_result_t result;
 
@@ -235,8 +199,8 @@ try_ipv6only(void) {
 		return;
 	}
 
-	on = 1;
-	if (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof(on)) < 0) {
+	on = TRUE;
+	if (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, (const char *) &on, sizeof(on)) < 0) {
 		ipv6only_result = ISC_R_NOTFOUND;
 		goto close;
 	}
@@ -251,8 +215,8 @@ try_ipv6only(void) {
 		return;
 	}
 
-	on = 1;
-	if (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof(on)) < 0) {
+	on = TRUE;
+	if (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, (const char *) &on, sizeof(on)) < 0) {
 		ipv6only_result = ISC_R_NOTFOUND;
 		goto close;
 	}
@@ -274,7 +238,8 @@ initialize_ipv6only(void) {
 #ifdef __notyet__
 static void
 try_ipv6pktinfo(void) {
-	int s, on;
+	int s;
+	DWORD on;
 	isc_result_t result;
 	int optname;
 
@@ -297,8 +262,8 @@ try_ipv6pktinfo(void) {
 #else  /* ifdef IPV6_RECVPKTINFO */
 	optname = IPV6_PKTINFO;
 #endif /* ifdef IPV6_RECVPKTINFO */
-	on = 1;
-	if (setsockopt(s, IPPROTO_IPV6, optname, &on, sizeof(on)) < 0) {
+	on = TRUE;
+	if (setsockopt(s, IPPROTO_IPV6, optname, (const char *) &on, sizeof(on)) < 0) {
 		ipv6pktinfo_result = ISC_R_NOTFOUND;
 		goto close;
 	}
diff --git a/lib/isc/netaddr.c b/lib/isc/netaddr.c
--- a/lib/isc/netaddr.c
+++ b/lib/isc/netaddr.c
@@ -51,11 +51,6 @@ isc_netaddr_equal(const isc_netaddr_t *a, const isc_netaddr_t *b) {
 			return false;
 		}
 		break;
-	case AF_UNIX:
-		if (strcmp(a->type.un, b->type.un) != 0) {
-			return false;
-		}
-		break;
 	default:
 		return false;
 	}
@@ -142,15 +137,6 @@ isc_netaddr_totext(const isc_netaddr_t *netaddr, isc_buffer_t *target) {
 	case AF_INET6:
 		type = &netaddr->type.in6;
 		break;
-	case AF_UNIX:
-		alen = strlen(netaddr->type.un);
-		if (alen > isc_buffer_availablelength(target)) {
-			return ISC_R_NOSPACE;
-		}
-		isc_buffer_putmem(target,
-				  (const unsigned char *)(netaddr->type.un),
-				  alen);
-		return ISC_R_SUCCESS;
 	default:
 		return ISC_R_FAILURE;
 	}
@@ -309,19 +295,6 @@ isc_netaddr_fromin6(isc_netaddr_t *netaddr, const struct in6_addr *ina6) {
 	netaddr->type.in6 = *ina6;
 }
 
-isc_result_t
-isc_netaddr_frompath(isc_netaddr_t *netaddr, const char *path) {
-	if (strlen(path) > sizeof(netaddr->type.un) - 1) {
-		return ISC_R_NOSPACE;
-	}
-
-	memset(netaddr, 0, sizeof(*netaddr));
-	netaddr->family = AF_UNIX;
-	strlcpy(netaddr->type.un, path, sizeof(netaddr->type.un));
-	netaddr->zone = 0;
-	return ISC_R_SUCCESS;
-}
-
 void
 isc_netaddr_setzone(isc_netaddr_t *netaddr, uint32_t zone) {
 	/* we currently only support AF_INET6. */
diff --git a/lib/isc/netmgr/http.c b/lib/isc/netmgr/http.c
--- a/lib/isc/netmgr/http.c
+++ b/lib/isc/netmgr/http.c
@@ -205,18 +205,6 @@ struct isc_nm_http_session {
 	uint64_t processed_useful_data; /* DNS data */
 };
 
-typedef enum isc_http_error_responses {
-	ISC_HTTP_ERROR_SUCCESS,		       /* 200 */
-	ISC_HTTP_ERROR_NOT_FOUND,	       /* 404 */
-	ISC_HTTP_ERROR_PAYLOAD_TOO_LARGE,      /* 413 */
-	ISC_HTTP_ERROR_URI_TOO_LONG,	       /* 414 */
-	ISC_HTTP_ERROR_UNSUPPORTED_MEDIA_TYPE, /* 415 */
-	ISC_HTTP_ERROR_BAD_REQUEST,	       /* 400 */
-	ISC_HTTP_ERROR_NOT_IMPLEMENTED,	       /* 501 */
-	ISC_HTTP_ERROR_GENERIC,		       /* 500 Internal Server Error */
-	ISC_HTTP_ERROR_MAX
-} isc_http_error_responses_t;
-
 typedef struct isc_http_send_req {
 	isc_nm_http_session_t *session;
 	isc_nmhandle_t *transphandle;
@@ -258,23 +246,12 @@ http_do_bio(isc_nm_http_session_t *session, isc_nmhandle_t *send_httphandle,
 static void
 http_do_bio_async(isc_nm_http_session_t *session);
 
-static void
-failed_httpstream_read_cb(isc_nmsocket_t *sock, isc_result_t result,
-			  isc_nm_http_session_t *session);
-
 static void
 client_call_failed_read_cb(isc_result_t result, isc_nm_http_session_t *session);
 
-static void
-server_call_failed_read_cb(isc_result_t result, isc_nm_http_session_t *session);
-
 static void
 failed_read_cb(isc_result_t result, isc_nm_http_session_t *session);
 
-static isc_result_t
-server_send_error_response(const isc_http_error_responses_t error,
-			   nghttp2_session *ngsession, isc_nmsocket_t *socket);
-
 static isc_result_t
 client_send(isc_nmhandle_t *handle, const isc_region_t *region);
 
@@ -288,24 +265,13 @@ static void
 call_pending_callbacks(isc__nm_http_pending_callbacks_t pending_callbacks,
 		       isc_result_t result);
 
-static void
-server_call_cb(isc_nmsocket_t *socket, const isc_result_t result,
-	       isc_region_t *data);
-
 static isc_nm_httphandler_t *
 http_endpoints_find(const char *request_path,
 		    const isc_nm_http_endpoints_t *restrict eps);
 
-static void
-http_init_listener_endpoints(isc_nmsocket_t *listener,
-			     isc_nm_http_endpoints_t *epset);
-
 static void
 http_cleanup_listener_endpoints(isc_nmsocket_t *listener);
 
-static isc_nm_http_endpoints_t *
-http_get_listener_endpoints(isc_nmsocket_t *listener, const int tid);
-
 static bool
 http_session_active(isc_nm_http_session_t *session) {
 	REQUIRE(VALID_HTTP2_SESSION(session));
@@ -574,7 +540,7 @@ finish_http_session(isc_nm_http_session_t *session) {
 		if (session->client) {
 			client_call_failed_read_cb(ISC_R_UNEXPECTED, session);
 		} else {
-			server_call_failed_read_cb(ISC_R_UNEXPECTED, session);
+			UNREACHABLE();
 		}
 
 		call_pending_callbacks(session->pending_write_callbacks,
@@ -2073,533 +2039,9 @@ error:
 	return result;
 }
 
-static int
-server_on_begin_headers_callback(nghttp2_session *ngsession,
-				 const nghttp2_frame *frame, void *user_data) {
-	isc_nm_http_session_t *session = (isc_nm_http_session_t *)user_data;
-	isc_nmsocket_t *socket = NULL;
-
-	if (frame->hd.type != NGHTTP2_HEADERS ||
-	    frame->headers.cat != NGHTTP2_HCAT_REQUEST)
-	{
-		return 0;
-	} else if (frame->hd.length > MAX_ALLOWED_DATA_IN_HEADERS) {
-		return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
-	}
-
-	if (session->nsstreams >= session->max_concurrent_streams) {
-		return NGHTTP2_ERR_CALLBACK_FAILURE;
-	}
-
-	socket = isc_mem_get(session->mctx, sizeof(isc_nmsocket_t));
-	isc__nmsocket_init(socket, session->serversocket->mgr,
-			   isc_nm_httpsocket,
-			   (isc_sockaddr_t *)&session->handle->sock->iface);
-	socket->peer = session->handle->sock->peer;
-	socket->h2 = (isc_nmsocket_h2_t){
-		.psock = socket,
-		.stream_id = frame->hd.stream_id,
-		.headers_error_code = ISC_HTTP_ERROR_SUCCESS,
-		.request_type = ISC_HTTP_REQ_UNSUPPORTED,
-		.request_scheme = ISC_HTTP_SCHEME_UNSUPPORTED
-	};
-	isc_buffer_initnull(&socket->h2.rbuf);
-	isc_buffer_initnull(&socket->h2.wbuf);
-	isc_nm_http_endpoints_attach(
-		http_get_listener_endpoints(session->serversocket, socket->tid),
-		&socket->h2.peer_endpoints);
-	session->nsstreams++;
-	isc__nm_httpsession_attach(session, &socket->h2.session);
-	socket->tid = session->handle->sock->tid;
-	ISC_LINK_INIT(&socket->h2, link);
-	ISC_LIST_APPEND(session->sstreams, &socket->h2, link);
-	session->total_opened_sstreams++;
-
-	nghttp2_session_set_stream_user_data(ngsession, frame->hd.stream_id,
-					     socket);
-	return 0;
-}
-
-static isc_http_error_responses_t
-server_handle_path_header(isc_nmsocket_t *socket, const uint8_t *value,
-			  const size_t valuelen) {
-	isc_nm_httphandler_t *handler = NULL;
-	const uint8_t *qstr = NULL;
-	size_t vlen = valuelen;
-
-	qstr = memchr(value, '?', valuelen);
-	if (qstr != NULL) {
-		vlen = qstr - value;
-	}
-
-	if (socket->h2.request_path != NULL) {
-		isc_mem_free(socket->mgr->mctx, socket->h2.request_path);
-	}
-	socket->h2.request_path = isc_mem_strndup(
-		socket->mgr->mctx, (const char *)value, vlen + 1);
-
-	if (!isc_nm_http_path_isvalid(socket->h2.request_path)) {
-		isc_mem_free(socket->mgr->mctx, socket->h2.request_path);
-		socket->h2.request_path = NULL;
-		return ISC_HTTP_ERROR_BAD_REQUEST;
-	}
-
-	handler = http_endpoints_find(socket->h2.request_path,
-				      socket->h2.peer_endpoints);
-	if (handler != NULL) {
-		socket->h2.cb = handler->cb;
-		socket->h2.cbarg = handler->cbarg;
-		socket->extrahandlesize = handler->extrahandlesize;
-	} else {
-		isc_mem_free(socket->mgr->mctx, socket->h2.request_path);
-		socket->h2.request_path = NULL;
-		return ISC_HTTP_ERROR_NOT_FOUND;
-	}
-
-	if (qstr != NULL) {
-		const char *dns_value = NULL;
-		size_t dns_value_len = 0;
-
-		if (isc__nm_parse_httpquery((const char *)qstr, &dns_value,
-					    &dns_value_len))
-		{
-			const size_t decoded_size = dns_value_len / 4 * 3;
-			if (decoded_size <= MAX_DNS_MESSAGE_SIZE) {
-				if (socket->h2.query_data != NULL) {
-					isc_mem_free(socket->mgr->mctx,
-						     socket->h2.query_data);
-				}
-				socket->h2.query_data =
-					isc__nm_base64url_to_base64(
-						socket->mgr->mctx, dns_value,
-						dns_value_len,
-						&socket->h2.query_data_len);
-				socket->h2.session->processed_useful_data +=
-					dns_value_len;
-			} else {
-				socket->h2.query_too_large = true;
-				return ISC_HTTP_ERROR_PAYLOAD_TOO_LARGE;
-			}
-		} else {
-			return ISC_HTTP_ERROR_BAD_REQUEST;
-		}
-	}
-	return ISC_HTTP_ERROR_SUCCESS;
-}
-
-static isc_http_error_responses_t
-server_handle_method_header(isc_nmsocket_t *socket, const uint8_t *value,
-			    const size_t valuelen) {
-	const char get[] = "GET";
-	const char post[] = "POST";
-
-	if (HEADER_MATCH(get, value, valuelen)) {
-		socket->h2.request_type = ISC_HTTP_REQ_GET;
-	} else if (HEADER_MATCH(post, value, valuelen)) {
-		socket->h2.request_type = ISC_HTTP_REQ_POST;
-	} else {
-		return ISC_HTTP_ERROR_NOT_IMPLEMENTED;
-	}
-	return ISC_HTTP_ERROR_SUCCESS;
-}
-
-static isc_http_error_responses_t
-server_handle_scheme_header(isc_nmsocket_t *socket, const uint8_t *value,
-			    const size_t valuelen) {
-	const char http[] = "http";
-	const char http_secure[] = "https";
-
-	if (HEADER_MATCH(http_secure, value, valuelen)) {
-		socket->h2.request_scheme = ISC_HTTP_SCHEME_HTTP_SECURE;
-	} else if (HEADER_MATCH(http, value, valuelen)) {
-		socket->h2.request_scheme = ISC_HTTP_SCHEME_HTTP;
-	} else {
-		return ISC_HTTP_ERROR_BAD_REQUEST;
-	}
-	return ISC_HTTP_ERROR_SUCCESS;
-}
-
-static isc_http_error_responses_t
-server_handle_content_length_header(isc_nmsocket_t *socket,
-				    const uint8_t *value,
-				    const size_t valuelen) {
-	char tmp[32] = { 0 };
-	const size_t tmplen = sizeof(tmp) - 1;
-
-	strncpy(tmp, (const char *)value,
-		valuelen > tmplen ? tmplen : valuelen);
-	socket->h2.content_length = strtoul(tmp, NULL, 10);
-	if (socket->h2.content_length > MAX_DNS_MESSAGE_SIZE) {
-		return ISC_HTTP_ERROR_PAYLOAD_TOO_LARGE;
-	} else if (socket->h2.content_length == 0) {
-		return ISC_HTTP_ERROR_BAD_REQUEST;
-	}
-	return ISC_HTTP_ERROR_SUCCESS;
-}
-
-static isc_http_error_responses_t
-server_handle_content_type_header(isc_nmsocket_t *socket, const uint8_t *value,
-				  const size_t valuelen) {
-	const char type_dns_message[] = DNS_MEDIA_TYPE;
-	isc_http_error_responses_t resp = ISC_HTTP_ERROR_SUCCESS;
-
-	UNUSED(socket);
-
-	if (!HEADER_MATCH(type_dns_message, value, valuelen)) {
-		resp = ISC_HTTP_ERROR_UNSUPPORTED_MEDIA_TYPE;
-	}
-	return resp;
-}
-
-static isc_http_error_responses_t
-server_handle_header(isc_nmsocket_t *socket, const uint8_t *name,
-		     size_t namelen, const uint8_t *value,
-		     const size_t valuelen) {
-	isc_http_error_responses_t code = ISC_HTTP_ERROR_SUCCESS;
-	bool was_error;
-	const char path[] = ":path";
-	const char method[] = ":method";
-	const char scheme[] = ":scheme";
-	const char content_length[] = "Content-Length";
-	const char content_type[] = "Content-Type";
-
-	was_error = socket->h2.headers_error_code != ISC_HTTP_ERROR_SUCCESS;
-	/*
-	 * process Content-Length even when there was an error,
-	 * to drop the connection earlier if required.
-	 */
-	if (HEADER_MATCH(content_length, name, namelen)) {
-		code = server_handle_content_length_header(socket, value,
-							   valuelen);
-	} else if (!was_error && HEADER_MATCH(path, name, namelen)) {
-		code = server_handle_path_header(socket, value, valuelen);
-	} else if (!was_error && HEADER_MATCH(method, name, namelen)) {
-		code = server_handle_method_header(socket, value, valuelen);
-	} else if (!was_error && HEADER_MATCH(scheme, name, namelen)) {
-		code = server_handle_scheme_header(socket, value, valuelen);
-	} else if (!was_error && HEADER_MATCH(content_type, name, namelen)) {
-		code = server_handle_content_type_header(socket, value,
-							 valuelen);
-	}
-
-	return code;
-}
-
-static int
-server_on_header_callback(nghttp2_session *session, const nghttp2_frame *frame,
-			  const uint8_t *name, size_t namelen,
-			  const uint8_t *value, size_t valuelen, uint8_t flags,
-			  void *user_data) {
-	isc_nmsocket_t *socket = NULL;
-	isc_http_error_responses_t code = ISC_HTTP_ERROR_SUCCESS;
-
-	UNUSED(flags);
-	UNUSED(user_data);
-
-	socket = nghttp2_session_get_stream_user_data(session,
-						      frame->hd.stream_id);
-	if (socket == NULL) {
-		return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
-	}
-
-	socket->h2.headers_data_processed += (namelen + valuelen);
-
-	switch (frame->hd.type) {
-	case NGHTTP2_HEADERS:
-		if (frame->headers.cat != NGHTTP2_HCAT_REQUEST) {
-			break;
-		}
-		code = server_handle_header(socket, name, namelen, value,
-					    valuelen);
-		break;
-	}
-
-	INSIST(socket != NULL);
-
-	if (socket->h2.headers_data_processed > MAX_ALLOWED_DATA_IN_HEADERS) {
-		return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
-	} else if (socket->h2.content_length > MAX_ALLOWED_DATA_IN_POST) {
-		return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
-	}
-
-	if (code == ISC_HTTP_ERROR_SUCCESS) {
-		return 0;
-	} else {
-		socket->h2.headers_error_code = code;
-	}
-
-	return 0;
-}
-
-static ssize_t
-server_read_callback(nghttp2_session *ngsession, int32_t stream_id,
-		     uint8_t *buf, size_t length, uint32_t *data_flags,
-		     nghttp2_data_source *source, void *user_data) {
-	isc_nm_http_session_t *session = (isc_nm_http_session_t *)user_data;
-	isc_nmsocket_t *socket = (isc_nmsocket_t *)source->ptr;
-	size_t buflen;
-
-	REQUIRE(socket->h2.stream_id == stream_id);
-
-	UNUSED(ngsession);
-	UNUSED(session);
-
-	buflen = isc_buffer_remaininglength(&socket->h2.wbuf);
-	if (buflen > length) {
-		buflen = length;
-	}
-
-	if (buflen > 0) {
-		(void)memmove(buf, isc_buffer_current(&socket->h2.wbuf),
-			      buflen);
-		isc_buffer_forward(&socket->h2.wbuf, buflen);
-	}
-
-	if (isc_buffer_remaininglength(&socket->h2.wbuf) == 0) {
-		*data_flags |= NGHTTP2_DATA_FLAG_EOF;
-	}
-
-	return buflen;
-}
-
-static isc_result_t
-server_send_response(nghttp2_session *ngsession, int32_t stream_id,
-		     const nghttp2_nv *nva, size_t nvlen,
-		     isc_nmsocket_t *socket) {
-	nghttp2_data_provider data_prd;
-	int rv;
-
-	if (socket->h2.response_submitted) {
-		/* NGHTTP2 will gladly accept new response (write request)
-		 * from us even though we cannot send more than one over the
-		 * same HTTP/2 stream. Thus, we need to handle this case
-		 * manually. We will return failure code so that it will be
-		 * passed to the write callback. */
-		return ISC_R_FAILURE;
-	}
-
-	data_prd.source.ptr = socket;
-	data_prd.read_callback = server_read_callback;
-
-	rv = nghttp2_submit_response(ngsession, stream_id, nva, nvlen,
-				     &data_prd);
-	if (rv != 0) {
-		return ISC_R_FAILURE;
-	}
-
-	socket->h2.response_submitted = true;
-	return ISC_R_SUCCESS;
-}
-
 #define MAKE_ERROR_REPLY(tag, code, desc) \
 	{ tag, MAKE_NV2(":status", #code), desc }
 
-/*
- * Here we use roughly the same error codes that Unbound uses.
- * (https://blog.nlnetlabs.nl/dns-over-https-in-unbound/)
- */
-
-static struct http_error_responses {
-	const isc_http_error_responses_t type;
-	const nghttp2_nv header;
-	const char *desc;
-} error_responses[] = {
-	MAKE_ERROR_REPLY(ISC_HTTP_ERROR_BAD_REQUEST, 400, "Bad Request"),
-	MAKE_ERROR_REPLY(ISC_HTTP_ERROR_NOT_FOUND, 404, "Not Found"),
-	MAKE_ERROR_REPLY(ISC_HTTP_ERROR_PAYLOAD_TOO_LARGE, 413,
-			 "Payload Too Large"),
-	MAKE_ERROR_REPLY(ISC_HTTP_ERROR_URI_TOO_LONG, 414, "URI Too Long"),
-	MAKE_ERROR_REPLY(ISC_HTTP_ERROR_UNSUPPORTED_MEDIA_TYPE, 415,
-			 "Unsupported Media Type"),
-	MAKE_ERROR_REPLY(ISC_HTTP_ERROR_GENERIC, 500, "Internal Server Error"),
-	MAKE_ERROR_REPLY(ISC_HTTP_ERROR_NOT_IMPLEMENTED, 501, "Not Implemented")
-};
-
-static void
-log_server_error_response(const isc_nmsocket_t *socket,
-			  const struct http_error_responses *response) {
-	const int log_level = ISC_LOG_DEBUG(1);
-	char client_sabuf[ISC_SOCKADDR_FORMATSIZE];
-	char local_sabuf[ISC_SOCKADDR_FORMATSIZE];
-
-	if (!isc_log_wouldlog(isc_lctx, log_level)) {
-		return;
-	}
-
-	isc_sockaddr_format(&socket->peer, client_sabuf, sizeof(client_sabuf));
-	isc_sockaddr_format(&socket->iface, local_sabuf, sizeof(local_sabuf));
-	isc_log_write(isc_lctx, ISC_LOGCATEGORY_GENERAL, ISC_LOGMODULE_NETMGR,
-		      log_level, "HTTP/2 request from %s (on %s) failed: %s %s",
-		      client_sabuf, local_sabuf, response->header.value,
-		      response->desc);
-}
-
-static isc_result_t
-server_send_error_response(const isc_http_error_responses_t error,
-			   nghttp2_session *ngsession, isc_nmsocket_t *socket) {
-	void *base;
-
-	REQUIRE(error != ISC_HTTP_ERROR_SUCCESS);
-
-	base = isc_buffer_base(&socket->h2.rbuf);
-	if (base != NULL) {
-		isc_mem_free(socket->h2.session->mctx, base);
-		isc_buffer_initnull(&socket->h2.rbuf);
-	}
-
-	/* We do not want the error response to be cached anywhere. */
-	socket->h2.min_ttl = 0;
-
-	for (size_t i = 0;
-	     i < sizeof(error_responses) / sizeof(error_responses[0]); i++)
-	{
-		if (error_responses[i].type == error) {
-			log_server_error_response(socket, &error_responses[i]);
-			return server_send_response(
-				ngsession, socket->h2.stream_id,
-				&error_responses[i].header, 1, socket);
-		}
-	}
-
-	return server_send_error_response(ISC_HTTP_ERROR_GENERIC, ngsession,
-					  socket);
-}
-
-static void
-server_call_cb(isc_nmsocket_t *socket, const isc_result_t result,
-	       isc_region_t *data) {
-	isc_nmhandle_t *handle = NULL;
-
-	REQUIRE(VALID_NMSOCK(socket));
-
-	/*
-	 * In some cases the callback could not have been set (e.g. when
-	 * the stream was closed prematurely (before processing its HTTP
-	 * path).
-	 */
-	if (socket->h2.cb == NULL) {
-		return;
-	}
-
-	handle = isc__nmhandle_get(socket, NULL, NULL);
-	if (result != ISC_R_SUCCESS) {
-		data = NULL;
-	} else if (socket->h2.session->handle != NULL) {
-		isc__nmsocket_timer_restart(socket->h2.session->handle->sock);
-	}
-	if (result == ISC_R_SUCCESS) {
-		socket->h2.request_received = true;
-		socket->h2.session->received++;
-	}
-	socket->h2.cb(handle, result, data, socket->h2.cbarg);
-	isc_nmhandle_detach(&handle);
-}
-
-void
-isc__nm_http_bad_request(isc_nmhandle_t *handle) {
-	isc_nmsocket_t *sock = NULL;
-
-	REQUIRE(VALID_NMHANDLE(handle));
-	REQUIRE(VALID_NMSOCK(handle->sock));
-	sock = handle->sock;
-	REQUIRE(sock->type == isc_nm_httpsocket);
-	REQUIRE(!atomic_load(&sock->client));
-	REQUIRE(VALID_HTTP2_SESSION(sock->h2.session));
-
-	if (sock->h2.response_submitted ||
-	    !http_session_active(sock->h2.session))
-	{
-		return;
-	}
-
-	(void)server_send_error_response(ISC_HTTP_ERROR_BAD_REQUEST,
-					 sock->h2.session->ngsession, sock);
-}
-
-static int
-server_on_request_recv(nghttp2_session *ngsession, isc_nmsocket_t *socket) {
-	isc_result_t result;
-	isc_http_error_responses_t code = ISC_HTTP_ERROR_SUCCESS;
-	isc_region_t data;
-	uint8_t tmp_buf[MAX_DNS_MESSAGE_SIZE];
-
-	code = socket->h2.headers_error_code;
-	if (code != ISC_HTTP_ERROR_SUCCESS) {
-		goto error;
-	}
-
-	if (socket->h2.request_path == NULL || socket->h2.cb == NULL) {
-		code = ISC_HTTP_ERROR_NOT_FOUND;
-	} else if (socket->h2.request_type == ISC_HTTP_REQ_POST &&
-		   socket->h2.content_length == 0)
-	{
-		code = ISC_HTTP_ERROR_BAD_REQUEST;
-	} else if (socket->h2.request_type == ISC_HTTP_REQ_POST &&
-		   isc_buffer_usedlength(&socket->h2.rbuf) >
-			   socket->h2.content_length)
-	{
-		code = ISC_HTTP_ERROR_PAYLOAD_TOO_LARGE;
-	} else if (socket->h2.request_type == ISC_HTTP_REQ_POST &&
-		   isc_buffer_usedlength(&socket->h2.rbuf) !=
-			   socket->h2.content_length)
-	{
-		code = ISC_HTTP_ERROR_BAD_REQUEST;
-	} else if (socket->h2.request_type == ISC_HTTP_REQ_POST &&
-		   socket->h2.query_data != NULL)
-	{
-		/* The spec does not mention which value the query string for
-		 * POST should have. For GET we use its value to decode a DNS
-		 * message from it, for POST the message is transferred in the
-		 * body of the request. Taking it into account, it is much safer
-		 * to treat POST
-		 * requests with query strings as malformed ones. */
-		code = ISC_HTTP_ERROR_BAD_REQUEST;
-	} else if (socket->h2.request_type == ISC_HTTP_REQ_GET &&
-		   socket->h2.content_length > 0)
-	{
-		code = ISC_HTTP_ERROR_BAD_REQUEST;
-	} else if (socket->h2.request_type == ISC_HTTP_REQ_GET &&
-		   socket->h2.query_data == NULL)
-	{
-		/* A GET request without any query data - there is nothing to
-		 * decode. */
-		INSIST(socket->h2.query_data_len == 0);
-		code = ISC_HTTP_ERROR_BAD_REQUEST;
-	}
-
-	if (code != ISC_HTTP_ERROR_SUCCESS) {
-		goto error;
-	}
-
-	if (socket->h2.request_type == ISC_HTTP_REQ_GET) {
-		isc_buffer_t decoded_buf;
-		isc_buffer_init(&decoded_buf, tmp_buf, sizeof(tmp_buf));
-		if (isc_base64_decodestring(socket->h2.query_data,
-					    &decoded_buf) != ISC_R_SUCCESS)
-		{
-			code = ISC_HTTP_ERROR_BAD_REQUEST;
-			goto error;
-		}
-		isc_buffer_usedregion(&decoded_buf, &data);
-	} else if (socket->h2.request_type == ISC_HTTP_REQ_POST) {
-		INSIST(socket->h2.content_length > 0);
-		isc_buffer_usedregion(&socket->h2.rbuf, &data);
-	} else {
-		UNREACHABLE();
-	}
-
-	server_call_cb(socket, ISC_R_SUCCESS, &data);
-
-	return 0;
-
-error:
-	result = server_send_error_response(code, ngsession, socket);
-	if (result != ISC_R_SUCCESS) {
-		return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
-	}
-	return 0;
-}
-
 void
 isc__nm_http_send(isc_nmhandle_t *handle, const isc_region_t *region,
 		  isc_nm_cb_t cb, void *cbarg) {
@@ -2658,61 +2100,6 @@ client_httpsend(isc_nmhandle_t *handle, isc_nmsocket_t *sock,
 	isc__nm_uvreq_put(&req, sock);
 }
 
-static void
-server_httpsend(isc_nmhandle_t *handle, isc_nmsocket_t *sock,
-		isc__nm_uvreq_t *req) {
-	size_t content_len_buf_len, cache_control_buf_len;
-	isc_result_t result = ISC_R_SUCCESS;
-	isc_nm_cb_t cb = req->cb.send;
-	void *cbarg = req->cbarg;
-	if (isc__nmsocket_closing(sock) ||
-	    !http_session_active(handle->httpsession))
-	{
-		failed_send_cb(sock, req, ISC_R_CANCELED);
-		return;
-	}
-
-	INSIST(handle->httpsession->handle->sock->tid == isc_nm_tid());
-	INSIST(VALID_NMHANDLE(handle->httpsession->handle));
-	INSIST(VALID_NMSOCK(handle->httpsession->handle->sock));
-
-	isc_buffer_init(&sock->h2.wbuf, req->uvbuf.base, req->uvbuf.len);
-	isc_buffer_add(&sock->h2.wbuf, req->uvbuf.len);
-
-	content_len_buf_len = snprintf(sock->h2.clenbuf,
-				       sizeof(sock->h2.clenbuf), "%lu",
-				       (unsigned long)req->uvbuf.len);
-	if (sock->h2.min_ttl == 0) {
-		cache_control_buf_len =
-			snprintf(sock->h2.cache_control_buf,
-				 sizeof(sock->h2.cache_control_buf), "%s",
-				 DEFAULT_CACHE_CONTROL);
-	} else {
-		cache_control_buf_len =
-			snprintf(sock->h2.cache_control_buf,
-				 sizeof(sock->h2.cache_control_buf),
-				 "max-age=%" PRIu32, sock->h2.min_ttl);
-	}
-	const nghttp2_nv hdrs[] = { MAKE_NV2(":status", "200"),
-				    MAKE_NV2("Content-Type", DNS_MEDIA_TYPE),
-				    MAKE_NV("Content-Length", sock->h2.clenbuf,
-					    content_len_buf_len),
-				    MAKE_NV("Cache-Control",
-					    sock->h2.cache_control_buf,
-					    cache_control_buf_len) };
-
-	result = server_send_response(handle->httpsession->ngsession,
-				      sock->h2.stream_id, hdrs,
-				      sizeof(hdrs) / sizeof(nghttp2_nv), sock);
-
-	if (result == ISC_R_SUCCESS) {
-		http_do_bio(handle->httpsession, handle, cb, cbarg);
-	} else {
-		cb(handle, result, cbarg);
-	}
-	isc__nm_uvreq_put(&req, sock);
-}
-
 void
 isc__nm_async_httpsend(isc__networker_t *worker, isc__netievent_t *ev0) {
 	isc__netievent_httpsend_t *ievent = (isc__netievent_httpsend_t *)ev0;
@@ -2736,7 +2123,7 @@ isc__nm_async_httpsend(isc__networker_t *worker, isc__netievent_t *ev0) {
 	if (session != NULL && session->client) {
 		client_httpsend(handle, sock, req);
 	} else {
-		server_httpsend(handle, sock, req);
+		UNREACHABLE();
 	}
 }
 
@@ -2775,86 +2162,6 @@ isc__nm_http_read(isc_nmhandle_t *handle, isc_nm_recv_cb_t cb, void *cbarg) {
 	}
 }
 
-static int
-server_on_frame_recv_callback(nghttp2_session *ngsession,
-			      const nghttp2_frame *frame, void *user_data) {
-	isc_nmsocket_t *socket = NULL;
-
-	UNUSED(user_data);
-
-	switch (frame->hd.type) {
-	case NGHTTP2_DATA:
-	case NGHTTP2_HEADERS:
-		/* Check that the client request has finished */
-		if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {
-			socket = nghttp2_session_get_stream_user_data(
-				ngsession, frame->hd.stream_id);
-
-			/*
-			 * For DATA and HEADERS frame, this callback may be
-			 * called after on_stream_close_callback. Check that
-			 * the stream is still alive.
-			 */
-			if (socket == NULL) {
-				return 0;
-			}
-
-			return server_on_request_recv(ngsession, socket);
-		}
-		break;
-	default:
-		break;
-	}
-	return 0;
-}
-
-static void
-initialize_nghttp2_server_session(isc_nm_http_session_t *session) {
-	nghttp2_session_callbacks *callbacks = NULL;
-	nghttp2_mem mem;
-
-	init_nghttp2_mem(session->mctx, &mem);
-
-	RUNTIME_CHECK(nghttp2_session_callbacks_new(&callbacks) == 0);
-
-	nghttp2_session_callbacks_set_on_data_chunk_recv_callback(
-		callbacks, on_data_chunk_recv_callback);
-
-	nghttp2_session_callbacks_set_on_stream_close_callback(
-		callbacks, on_stream_close_callback);
-
-	nghttp2_session_callbacks_set_on_header_callback(
-		callbacks, server_on_header_callback);
-
-	nghttp2_session_callbacks_set_on_begin_headers_callback(
-		callbacks, server_on_begin_headers_callback);
-
-	nghttp2_session_callbacks_set_on_frame_recv_callback(
-		callbacks, server_on_frame_recv_callback);
-
-	RUNTIME_CHECK(nghttp2_session_server_new3(&session->ngsession,
-						  callbacks, session, NULL,
-						  &mem) == 0);
-
-	nghttp2_session_callbacks_del(callbacks);
-}
-
-static int
-server_send_connection_header(isc_nm_http_session_t *session) {
-	nghttp2_settings_entry iv[1] = {
-		{ NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS,
-		  session->max_concurrent_streams }
-	};
-	int rv;
-
-	rv = nghttp2_submit_settings(session->ngsession, NGHTTP2_FLAG_NONE, iv,
-				     1);
-	if (rv != 0) {
-		return -1;
-	}
-	return 0;
-}
-
 /*
  * It is advisable to disable Nagle's algorithm for HTTP/2
  * connections because multiple HTTP/2 streams could be multiplexed
@@ -2878,121 +2185,6 @@ http_transpost_tcp_nodelay(isc_nmhandle_t *transphandle) {
 	(void)isc__nm_socket_tcp_nodelay((uv_os_sock_t)tcp_fd);
 }
 
-static isc_result_t
-httplisten_acceptcb(isc_nmhandle_t *handle, isc_result_t result, void *cbarg) {
-	isc_nmsocket_t *httplistensock = (isc_nmsocket_t *)cbarg;
-	isc_nm_http_session_t *session = NULL;
-	isc_nmsocket_t *listener = NULL, *httpserver = NULL;
-
-	REQUIRE(VALID_NMHANDLE(handle));
-	REQUIRE(VALID_NMSOCK(handle->sock));
-
-	if (handle->sock->type == isc_nm_tlssocket) {
-		REQUIRE(VALID_NMSOCK(handle->sock->listener));
-		listener = handle->sock->listener;
-		httpserver = listener->h2.httpserver;
-	} else {
-		REQUIRE(VALID_NMSOCK(handle->sock->server));
-		listener = handle->sock->server;
-		REQUIRE(VALID_NMSOCK(listener->parent));
-		httpserver = listener->parent->h2.httpserver;
-	}
-
-	/*
-	 * NOTE: HTTP listener socket might be destroyed by the time this
-	 * function gets invoked, so we need to do extra sanity checks to
-	 * detect this case.
-	 */
-	if (isc__nmsocket_closing(handle->sock) || httpserver == NULL) {
-		return ISC_R_CANCELED;
-	}
-
-	if (result != ISC_R_SUCCESS) {
-		/* XXXWPK do nothing? */
-		return result;
-	}
-
-	REQUIRE(VALID_NMSOCK(httplistensock));
-	INSIST(httplistensock == httpserver);
-
-	if (isc__nmsocket_closing(httplistensock) ||
-	    !atomic_load(&httplistensock->listening))
-	{
-		return ISC_R_CANCELED;
-	}
-
-	http_transpost_tcp_nodelay(handle);
-
-	new_session(httplistensock->mgr->mctx, NULL, &session);
-	session->max_concurrent_streams =
-		atomic_load(&httplistensock->h2.max_concurrent_streams);
-	initialize_nghttp2_server_session(session);
-	handle->sock->h2.session = session;
-
-	isc_nmhandle_attach(handle, &session->handle);
-	isc__nmsocket_attach(httplistensock, &session->serversocket);
-	server_send_connection_header(session);
-
-	isc__nmhandle_set_manual_timer(session->handle, true);
-
-	/* TODO H2 */
-	http_do_bio(session, NULL, NULL, NULL);
-	return ISC_R_SUCCESS;
-}
-
-isc_result_t
-isc_nm_listenhttp(isc_nm_t *mgr, isc_sockaddr_t *iface, int backlog,
-		  isc_quota_t *quota, isc_tlsctx_t *ctx,
-		  isc_nm_http_endpoints_t *eps, uint32_t max_concurrent_streams,
-		  isc_nmsocket_t **sockp) {
-	isc_nmsocket_t *sock = NULL;
-	isc_result_t result;
-
-	REQUIRE(VALID_NM(mgr));
-	REQUIRE(!ISC_LIST_EMPTY(eps->handlers));
-	REQUIRE(atomic_load(&eps->in_use) == false);
-
-	sock = isc_mem_get(mgr->mctx, sizeof(*sock));
-	isc__nmsocket_init(sock, mgr, isc_nm_httplistener, iface);
-	atomic_init(&sock->h2.max_concurrent_streams,
-		    NGHTTP2_INITIAL_MAX_CONCURRENT_STREAMS);
-
-	isc_nmsocket_set_max_streams(sock, max_concurrent_streams);
-
-	atomic_store(&eps->in_use, true);
-	http_init_listener_endpoints(sock, eps);
-
-	if (ctx != NULL) {
-		result = isc_nm_listentls(mgr, iface, httplisten_acceptcb, sock,
-					  sizeof(isc_nm_http_session_t),
-					  backlog, quota, ctx, &sock->outer);
-	} else {
-		result = isc_nm_listentcp(mgr, iface, httplisten_acceptcb, sock,
-					  sizeof(isc_nm_http_session_t),
-					  backlog, quota, &sock->outer);
-	}
-
-	if (result != ISC_R_SUCCESS) {
-		atomic_store(&sock->closed, true);
-		isc__nmsocket_detach(&sock);
-		return result;
-	}
-
-	isc__nmsocket_attach(sock, &sock->outer->h2.httpserver);
-
-	sock->nchildren = sock->outer->nchildren;
-	sock->result = ISC_R_UNSET;
-	sock->tid = 0;
-	sock->fd = (uv_os_sock_t)-1;
-
-	isc__nmsocket_barrier_init(sock);
-	atomic_init(&sock->rchildren, sock->nchildren);
-
-	atomic_store(&sock->listening, true);
-	*sockp = sock;
-	return ISC_R_SUCCESS;
-}
-
 isc_nm_http_endpoints_t *
 isc_nm_http_endpoints_new(isc_mem_t *mctx) {
 	isc_nm_http_endpoints_t *restrict eps;
@@ -3190,24 +2382,6 @@ isc__nm_async_httpclose(isc__networker_t *worker, isc__netievent_t *ev0) {
 	http_close_direct(sock);
 }
 
-static void
-failed_httpstream_read_cb(isc_nmsocket_t *sock, isc_result_t result,
-			  isc_nm_http_session_t *session) {
-	isc_region_t data;
-	REQUIRE(VALID_NMSOCK(sock));
-	INSIST(sock->type == isc_nm_httpsocket);
-
-	if (sock->h2.request_path == NULL) {
-		return;
-	}
-
-	(void)nghttp2_submit_rst_stream(
-		session->ngsession, NGHTTP2_FLAG_END_STREAM, sock->h2.stream_id,
-		NGHTTP2_REFUSED_STREAM);
-	isc_buffer_usedregion(&sock->h2.rbuf, &data);
-	server_call_cb(sock, result, &data);
-}
-
 static void
 client_call_failed_read_cb(isc_result_t result,
 			   isc_nm_http_session_t *session) {
@@ -3245,33 +2419,6 @@ client_call_failed_read_cb(isc_result_t result,
 	}
 }
 
-static void
-server_call_failed_read_cb(isc_result_t result,
-			   isc_nm_http_session_t *session) {
-	isc_nmsocket_h2_t *h2data = NULL; /* stream socket */
-
-	REQUIRE(VALID_HTTP2_SESSION(session));
-	REQUIRE(result != ISC_R_SUCCESS);
-
-	for (h2data = ISC_LIST_HEAD(session->sstreams); h2data != NULL;
-	     h2data = ISC_LIST_NEXT(h2data, link))
-	{
-		failed_httpstream_read_cb(h2data->psock, result, session);
-	}
-
-	h2data = ISC_LIST_HEAD(session->sstreams);
-	while (h2data != NULL) {
-		isc_nmsocket_h2_t *next = ISC_LIST_NEXT(h2data, link);
-		ISC_LIST_DEQUEUE(session->sstreams, h2data, link);
-		/* Cleanup socket in place */
-		atomic_store(&h2data->psock->active, false);
-		atomic_store(&h2data->psock->closed, true);
-		isc__nmsocket_detach(&h2data->psock);
-
-		h2data = next;
-	}
-}
-
 static void
 failed_read_cb(isc_result_t result, isc_nm_http_session_t *session) {
 	if (session->client) {
@@ -3285,11 +2432,7 @@ failed_read_cb(isc_result_t result, isc_nm_http_session_t *session) {
 			finish_http_session(session);
 		}
 	} else {
-		server_call_failed_read_cb(result, session);
-		/*
-		 * All streams are now destroyed; close the session.
-		 */
-		finish_http_session(session);
+		UNREACHABLE();
 	}
 }
 
@@ -3423,29 +2566,6 @@ isc__nm_async_httpendpoints(isc__networker_t *worker, isc__netievent_t *ev0) {
 				     &listener->h2.listener_endpoints[tid]);
 }
 
-static void
-http_init_listener_endpoints(isc_nmsocket_t *listener,
-			     isc_nm_http_endpoints_t *epset) {
-	size_t nlisteners;
-
-	REQUIRE(VALID_NMSOCK(listener));
-	REQUIRE(VALID_NM(listener->mgr));
-	REQUIRE(VALID_HTTP_ENDPOINTS(epset));
-
-	nlisteners = (size_t)listener->mgr->nlisteners;
-	INSIST(nlisteners > 0);
-
-	listener->h2.listener_endpoints =
-		isc_mem_get(listener->mgr->mctx,
-			    sizeof(isc_nm_http_endpoints_t *) * nlisteners);
-	listener->h2.n_listener_endpoints = nlisteners;
-	for (size_t i = 0; i < nlisteners; i++) {
-		listener->h2.listener_endpoints[i] = NULL;
-		isc_nm_http_endpoints_attach(
-			epset, &listener->h2.listener_endpoints[i]);
-	}
-}
-
 static void
 http_cleanup_listener_endpoints(isc_nmsocket_t *listener) {
 	REQUIRE(VALID_NM(listener->mgr));
@@ -3464,18 +2584,6 @@ http_cleanup_listener_endpoints(isc_nmsocket_t *listener) {
 	listener->h2.n_listener_endpoints = 0;
 }
 
-static isc_nm_http_endpoints_t *
-http_get_listener_endpoints(isc_nmsocket_t *listener, const int tid) {
-	isc_nm_http_endpoints_t *eps;
-	REQUIRE(VALID_NMSOCK(listener));
-	REQUIRE(tid >= 0);
-	REQUIRE((size_t)tid < listener->h2.n_listener_endpoints);
-
-	eps = listener->h2.listener_endpoints[tid];
-	INSIST(eps != NULL);
-	return eps;
-}
-
 static const bool base64url_validation_table[256] = {
 	false, false, false, false, false, false, false, false, false, false,
 	false, false, false, false, false, false, false, false, false, false,
@@ -3822,177 +2930,6 @@ typedef struct isc_httpparser_state {
 #define ADVANCE()      st->str++
 #define GETP()	       (st->str)
 
-static bool
-rule_query_string(isc_httpparser_state_t *st);
-
-bool
-isc__nm_parse_httpquery(const char *query_string, const char **start,
-			size_t *len) {
-	isc_httpparser_state_t state;
-
-	REQUIRE(start != NULL);
-	REQUIRE(len != NULL);
-
-	if (query_string == NULL || query_string[0] == '\0') {
-		return false;
-	}
-
-	state = (isc_httpparser_state_t){ .str = query_string };
-	if (!rule_query_string(&state)) {
-		return false;
-	}
-
-	if (!state.query_found) {
-		return false;
-	}
-
-	*start = state.query;
-	*len = state.query_len;
-
-	return true;
-}
-
-static bool
-rule_key_value_pair(isc_httpparser_state_t *st);
-
-static bool
-rule_key(isc_httpparser_state_t *st);
-
-static bool
-rule_value(isc_httpparser_state_t *st);
-
-static bool
-rule_value_char(isc_httpparser_state_t *st);
-
-static bool
-rule_percent_charcode(isc_httpparser_state_t *st);
-
-static bool
-rule_unreserved_char(isc_httpparser_state_t *st);
-
-static bool
-rule_query_string(isc_httpparser_state_t *st) {
-	if (MATCH('?')) {
-		ADVANCE();
-	}
-
-	while (rule_key_value_pair(st)) {
-		/* skip */;
-	}
-
-	if (!MATCH('\0')) {
-		return false;
-	}
-
-	ADVANCE();
-	return true;
-}
-
-static bool
-rule_key_value_pair(isc_httpparser_state_t *st) {
-	if (!rule_key(st)) {
-		return false;
-	}
-
-	if (MATCH('=')) {
-		ADVANCE();
-	} else {
-		return false;
-	}
-
-	if (rule_value(st)) {
-		const char dns[] = "dns";
-		if (st->last_key_len == sizeof(dns) - 1 &&
-		    memcmp(st->last_key, dns, sizeof(dns) - 1) == 0)
-		{
-			st->query_found = true;
-			st->query = st->last_value;
-			st->query_len = st->last_value_len;
-		}
-	} else {
-		return false;
-	}
-
-	if (MATCH('&')) {
-		ADVANCE();
-	}
-
-	return true;
-}
-
-static bool
-rule_key(isc_httpparser_state_t *st) {
-	if (MATCH('_') || MATCH_ALPHA()) {
-		st->last_key = GETP();
-		ADVANCE();
-	} else {
-		return false;
-	}
-
-	while (MATCH('_') || MATCH_ALNUM()) {
-		ADVANCE();
-	}
-
-	st->last_key_len = GETP() - st->last_key;
-	return true;
-}
-
-static bool
-rule_value(isc_httpparser_state_t *st) {
-	const char *s = GETP();
-	if (!rule_value_char(st)) {
-		return false;
-	}
-
-	st->last_value = s;
-	while (rule_value_char(st)) {
-		/* skip */;
-	}
-	st->last_value_len = GETP() - st->last_value;
-	return true;
-}
-
-static bool
-rule_value_char(isc_httpparser_state_t *st) {
-	if (rule_unreserved_char(st)) {
-		return true;
-	}
-
-	return rule_percent_charcode(st);
-}
-
-static bool
-rule_unreserved_char(isc_httpparser_state_t *st) {
-	if (MATCH_ALNUM() || MATCH('_') || MATCH('.') || MATCH('-') ||
-	    MATCH('~'))
-	{
-		ADVANCE();
-		return true;
-	}
-	return false;
-}
-
-static bool
-rule_percent_charcode(isc_httpparser_state_t *st) {
-	if (MATCH('%')) {
-		ADVANCE();
-	} else {
-		return false;
-	}
-
-	if (!MATCH_XDIGIT()) {
-		return false;
-	}
-	ADVANCE();
-
-	if (!MATCH_XDIGIT()) {
-		return false;
-	}
-	ADVANCE();
-
-	return true;
-}
-
 /*
  * DoH URL Location Verifier. Based on the following grammar (EBNF/WSN
  * notation):
diff --git a/lib/isc/netmgr/netmgr-int.h b/lib/isc/netmgr/netmgr-int.h
--- a/lib/isc/netmgr/netmgr-int.h
+++ b/lib/isc/netmgr/netmgr-int.h
@@ -33,7 +33,6 @@
 #include <isc/region.h>
 #include <isc/result.h>
 #include <isc/sockaddr.h>
-#include <isc/stats.h>
 #include <isc/thread.h>
 #include <isc/tls.h>
 #include <isc/util.h>
@@ -818,8 +817,6 @@ struct isc_nm {
 	isc_condition_t wkpausecond;
 	isc__networker_t *workers;
 
-	isc_stats_t *stats;
-
 	uint_fast32_t workers_running;
 	atomic_uint_fast32_t workers_paused;
 	atomic_uint_fast32_t maxudp;
@@ -1078,11 +1075,6 @@ struct isc_nmsocket {
 	isc_quota_t *pquota;
 	isc_quota_cb_t quotacb;
 
-	/*%
-	 * Socket statistics
-	 */
-	const isc_statscounter_t *statsindex;
-
 	/*%
 	 * TCP read/connect timeout timers.
 	 */
@@ -1989,18 +1981,6 @@ isc__nm_acquire_interlocked_force(isc_nm_t *mgr);
 void
 isc__nm_async_sockstop(isc__networker_t *worker, isc__netievent_t *ev0);
 
-void
-isc__nm_incstats(isc_nmsocket_t *sock, isc__nm_statid_t id);
-/*%<
- * Increment socket-related statistics counters.
- */
-
-void
-isc__nm_decstats(isc_nmsocket_t *sock, isc__nm_statid_t id);
-/*%<
- * Decrement socket-related statistics counters.
- */
-
 isc_result_t
 isc__nm_socket(int domain, int type, int protocol, uv_os_sock_t *sockp);
 /*%<
@@ -2020,7 +2000,7 @@ isc__nm_socket_freebind(uv_os_sock_t fd, sa_family_t sa_family);
  */
 
 isc_result_t
-isc__nm_socket_reuse(uv_os_sock_t fd, int val);
+isc__nm_socket_reuse(uv_os_sock_t fd, DWORD val);
 /*%<
  * Set the SO_REUSEADDR or SO_REUSEPORT (or equivalent) socket option on the fd
  */
diff --git a/lib/isc/netmgr/netmgr.c b/lib/isc/netmgr/netmgr.c
--- a/lib/isc/netmgr/netmgr.c
+++ b/lib/isc/netmgr/netmgr.c
@@ -33,7 +33,6 @@
 #include <isc/region.h>
 #include <isc/result.h>
 #include <isc/sockaddr.h>
-#include <isc/stats.h>
 #include <isc/task.h>
 #include <isc/thread.h>
 #include <isc/tls.h>
@@ -59,75 +58,6 @@
 #define ISC_NM_HANDLES_STACK_SIZE_UDP 64
 #define ISC_NM_REQS_STACK_SIZE_UDP    64
 
-/*%
- * Shortcut index arrays to get access to statistics counters.
- */
-
-static const isc_statscounter_t udp4statsindex[] = {
-	isc_sockstatscounter_udp4open,
-	isc_sockstatscounter_udp4openfail,
-	isc_sockstatscounter_udp4close,
-	isc_sockstatscounter_udp4bindfail,
-	isc_sockstatscounter_udp4connectfail,
-	isc_sockstatscounter_udp4connect,
-	-1,
-	-1,
-	isc_sockstatscounter_udp4sendfail,
-	isc_sockstatscounter_udp4recvfail,
-	isc_sockstatscounter_udp4active,
-	-1,
-};
-
-static const isc_statscounter_t udp6statsindex[] = {
-	isc_sockstatscounter_udp6open,
-	isc_sockstatscounter_udp6openfail,
-	isc_sockstatscounter_udp6close,
-	isc_sockstatscounter_udp6bindfail,
-	isc_sockstatscounter_udp6connectfail,
-	isc_sockstatscounter_udp6connect,
-	-1,
-	-1,
-	isc_sockstatscounter_udp6sendfail,
-	isc_sockstatscounter_udp6recvfail,
-	isc_sockstatscounter_udp6active,
-	-1,
-};
-
-static const isc_statscounter_t tcp4statsindex[] = {
-	isc_sockstatscounter_tcp4open,	      isc_sockstatscounter_tcp4openfail,
-	isc_sockstatscounter_tcp4close,	      isc_sockstatscounter_tcp4bindfail,
-	isc_sockstatscounter_tcp4connectfail, isc_sockstatscounter_tcp4connect,
-	isc_sockstatscounter_tcp4acceptfail,  isc_sockstatscounter_tcp4accept,
-	isc_sockstatscounter_tcp4sendfail,    isc_sockstatscounter_tcp4recvfail,
-	isc_sockstatscounter_tcp4active,      isc_sockstatscounter_tcp4clients,
-};
-
-static const isc_statscounter_t tcp6statsindex[] = {
-	isc_sockstatscounter_tcp6open,	      isc_sockstatscounter_tcp6openfail,
-	isc_sockstatscounter_tcp6close,	      isc_sockstatscounter_tcp6bindfail,
-	isc_sockstatscounter_tcp6connectfail, isc_sockstatscounter_tcp6connect,
-	isc_sockstatscounter_tcp6acceptfail,  isc_sockstatscounter_tcp6accept,
-	isc_sockstatscounter_tcp6sendfail,    isc_sockstatscounter_tcp6recvfail,
-	isc_sockstatscounter_tcp6active,      isc_sockstatscounter_tcp6clients,
-};
-
-#if 0
-/* XXX: not currently used */
-static const isc_statscounter_t unixstatsindex[] = {
-	isc_sockstatscounter_unixopen,
-	isc_sockstatscounter_unixopenfail,
-	isc_sockstatscounter_unixclose,
-	isc_sockstatscounter_unixbindfail,
-	isc_sockstatscounter_unixconnectfail,
-	isc_sockstatscounter_unixconnect,
-	isc_sockstatscounter_unixacceptfail,
-	isc_sockstatscounter_unixaccept,
-	isc_sockstatscounter_unixsendfail,
-	isc_sockstatscounter_unixrecvfail,
-	isc_sockstatscounter_unixactive
-};
-#endif /* if 0 */
-
 /*
  * libuv is not thread safe, but has mechanisms to pass messages
  * between threads. Each socket is owned by a thread. For UDP
@@ -378,10 +308,6 @@ nm_destroy(isc_nm_t **mgr0) {
 		isc_thread_join(worker->thread, NULL);
 	}
 
-	if (mgr->stats != NULL) {
-		isc_stats_detach(&mgr->stats);
-	}
-
 	isc_barrier_destroy(&mgr->resuming);
 	isc_barrier_destroy(&mgr->pausing);
 
@@ -956,7 +882,9 @@ process_netievent(isc__networker_t *worker, isc__netievent_t *ievent) {
 		NETIEVENT_CASE(udpcancel);
 		NETIEVENT_CASE(udpclose);
 
+#if 0
 		NETIEVENT_CASE(routeconnect);
+#endif
 
 		NETIEVENT_CASE(tcpaccept);
 		NETIEVENT_CASE(tcpconnect);
@@ -1262,8 +1190,6 @@ nmsocket_cleanup(isc_nmsocket_t *sock, bool dofree FLARG) {
 			 "\n",
 			 sock, isc_refcount_current(&sock->references));
 
-	isc__nm_decstats(sock, STATID_ACTIVE);
-
 	atomic_store(&sock->destroying, true);
 
 	if (sock->parent == NULL && sock->children != NULL) {
@@ -1518,7 +1444,6 @@ isc_nmsocket_close(isc_nmsocket_t **sockp) {
 void
 isc___nmsocket_init(isc_nmsocket_t *sock, isc_nm_t *mgr, isc_nmsocket_type type,
 		    isc_sockaddr_t *iface FLARG) {
-	uint16_t family;
 	size_t inactive_handles_stack_size = ISC_NM_HANDLES_STACK_SIZE;
 	size_t inactive_reqs_stack_size = ISC_NM_REQS_STACK_SIZE;
 
@@ -1542,10 +1467,7 @@ isc___nmsocket_init(isc_nmsocket_t *sock, isc_nm_t *mgr, isc_nmsocket_type type,
 	ISC_LIST_INIT(sock->tls.sendreqs);
 
 	if (iface != NULL) {
-		family = iface->type.sa.sa_family;
 		sock->iface = *iface;
-	} else {
-		family = AF_UNSPEC;
 	}
 
 #if NETMGR_TRACE
@@ -1562,49 +1484,6 @@ isc___nmsocket_init(isc_nmsocket_t *sock, isc_nm_t *mgr, isc_nmsocket_type type,
 
 	ISC_LINK_INIT(&sock->quotacb, link);
 
-	switch (type) {
-	case isc_nm_udpsocket:
-	case isc_nm_udplistener:
-		switch (family) {
-		case AF_INET:
-			sock->statsindex = udp4statsindex;
-			break;
-		case AF_INET6:
-			sock->statsindex = udp6statsindex;
-			break;
-		case AF_UNSPEC:
-			/*
-			 * Route sockets are AF_UNSPEC, and don't
-			 * have stats counters.
-			 */
-			break;
-		default:
-			UNREACHABLE();
-		}
-		break;
-	case isc_nm_tcpsocket:
-	case isc_nm_tcplistener:
-	case isc_nm_tcpdnssocket:
-	case isc_nm_tcpdnslistener:
-	case isc_nm_tlsdnssocket:
-	case isc_nm_tlsdnslistener:
-	case isc_nm_httpsocket:
-	case isc_nm_httplistener:
-		switch (family) {
-		case AF_INET:
-			sock->statsindex = tcp4statsindex;
-			break;
-		case AF_INET6:
-			sock->statsindex = tcp6statsindex;
-			break;
-		default:
-			UNREACHABLE();
-		}
-		break;
-	default:
-		break;
-	}
-
 	isc_mutex_init(&sock->lock);
 	isc_condition_init(&sock->cond);
 	isc_condition_init(&sock->scond);
@@ -1640,8 +1519,6 @@ isc___nmsocket_init(isc_nmsocket_t *sock, isc_nm_t *mgr, isc_nmsocket_type type,
 #endif
 
 	sock->magic = NMSOCK_MAGIC;
-
-	isc__nm_incstats(sock, STATID_ACTIVE);
 }
 
 void
@@ -2011,8 +1888,6 @@ isc__nm_failed_connect_cb(isc_nmsocket_t *sock, isc__nm_uvreq_t *req,
 	REQUIRE(sock->tid == isc_nm_tid());
 	REQUIRE(req->cb.connect != NULL);
 
-	isc__nm_incstats(sock, STATID_CONNECTFAIL);
-
 	isc__nmsocket_timer_stop(sock);
 	uv_handle_set_data((uv_handle_t *)&sock->read_timer, sock);
 
@@ -3217,35 +3092,6 @@ isc__nm_acquire_interlocked_force(isc_nm_t *mgr) {
 	UNLOCK(&mgr->lock);
 }
 
-void
-isc_nm_setstats(isc_nm_t *mgr, isc_stats_t *stats) {
-	REQUIRE(VALID_NM(mgr));
-	REQUIRE(mgr->stats == NULL);
-	REQUIRE(isc_stats_ncounters(stats) == isc_sockstatscounter_max);
-
-	isc_stats_attach(stats, &mgr->stats);
-}
-
-void
-isc__nm_incstats(isc_nmsocket_t *sock, isc__nm_statid_t id) {
-	REQUIRE(VALID_NMSOCK(sock));
-	REQUIRE(id < STATID_MAX);
-
-	if (sock->statsindex != NULL && sock->mgr->stats != NULL) {
-		isc_stats_increment(sock->mgr->stats, sock->statsindex[id]);
-	}
-}
-
-void
-isc__nm_decstats(isc_nmsocket_t *sock, isc__nm_statid_t id) {
-	REQUIRE(VALID_NMSOCK(sock));
-	REQUIRE(id < STATID_MAX);
-
-	if (sock->statsindex != NULL && sock->mgr->stats != NULL) {
-		isc_stats_decrement(sock->mgr->stats, sock->statsindex[id]);
-	}
-}
-
 isc_result_t
 isc__nm_socket(int domain, int type, int protocol, uv_os_sock_t *sockp) {
 	int sock = socket(domain, type, protocol);
@@ -3263,10 +3109,10 @@ isc__nm_closesocket(uv_os_sock_t sock) {
 }
 
 #define setsockopt_on(socket, level, name) \
-	setsockopt(socket, level, name, &(int){ 1 }, sizeof(int))
+	setsockopt(socket, level, name, (const char *) &(DWORD){ 1 }, sizeof(DWORD))
 
 #define setsockopt_off(socket, level, name) \
-	setsockopt(socket, level, name, &(int){ 0 }, sizeof(int))
+	setsockopt(socket, level, name, (const char *) &(DWORD){ 0 }, sizeof(DWORD))
 
 isc_result_t
 isc__nm_socket_freebind(uv_os_sock_t fd, sa_family_t sa_family) {
@@ -3310,7 +3156,7 @@ isc__nm_socket_freebind(uv_os_sock_t fd, sa_family_t sa_family) {
 }
 
 isc_result_t
-isc__nm_socket_reuse(uv_os_sock_t fd, int val) {
+isc__nm_socket_reuse(uv_os_sock_t fd, DWORD val) {
 	/*
 	 * Generally, the SO_REUSEADDR socket option allows reuse of
 	 * local addresses.
@@ -3327,12 +3173,12 @@ isc__nm_socket_reuse(uv_os_sock_t fd, int val) {
 	 */
 
 #if defined(SO_REUSEPORT) && !defined(__linux__)
-	if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &val, sizeof(val)) == -1) {
+	if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, (const char *) &val, sizeof(val)) == -1) {
 		return ISC_R_FAILURE;
 	}
 	return ISC_R_SUCCESS;
 #elif defined(SO_REUSEADDR)
-	if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val)) == -1) {
+	if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (const char *) &val, sizeof(val)) == -1) {
 		return ISC_R_FAILURE;
 	}
 	return ISC_R_SUCCESS;
@@ -3386,7 +3232,7 @@ isc__nm_socket_disable_pmtud(uv_os_sock_t fd, sa_family_t sa_family) {
 		}
 #elif defined(IPV6_MTU_DISCOVER) && defined(IP_PMTUDISC_OMIT)
 		if (setsockopt(fd, IPPROTO_IPV6, IPV6_MTU_DISCOVER,
-			       &(int){ IP_PMTUDISC_OMIT }, sizeof(int)) == -1)
+			       (const char *) &(DWORD){ IP_PMTUDISC_OMIT }, sizeof(DWORD)) == -1)
 		{
 			return ISC_R_FAILURE;
 		} else {
@@ -3404,7 +3250,7 @@ isc__nm_socket_disable_pmtud(uv_os_sock_t fd, sa_family_t sa_family) {
 		}
 #elif defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_OMIT)
 		if (setsockopt(fd, IPPROTO_IP, IP_MTU_DISCOVER,
-			       &(int){ IP_PMTUDISC_OMIT }, sizeof(int)) == -1)
+			       (const char *) &(DWORD){ IP_PMTUDISC_OMIT }, sizeof(DWORD)) == -1)
 		{
 			return ISC_R_FAILURE;
 		} else {
@@ -3561,8 +3407,8 @@ isc__nm_socket_min_mtu(uv_os_sock_t fd, sa_family_t sa_family) {
 		return ISC_R_FAILURE;
 	}
 #elif defined(IPV6_MTU)
-	if (setsockopt(fd, IPPROTO_IPV6, IPV6_MTU, &(int){ 1280 },
-		       sizeof(int)) == -1)
+	if (setsockopt(fd, IPPROTO_IPV6, IPV6_MTU, (const char *) &(DWORD){ 1280 },
+		       sizeof(DWORD)) == -1)
 	{
 		return ISC_R_FAILURE;
 	}
@@ -3724,7 +3570,7 @@ isc_nm_bad_request(isc_nmhandle_t *handle) {
 		return;
 #if HAVE_LIBNGHTTP2
 	case isc_nm_httpsocket:
-		isc__nm_http_bad_request(handle);
+		UNREACHABLE();
 		return;
 #endif /* HAVE_LIBNGHTTP2 */
 	case isc_nm_tcpsocket:
diff --git a/lib/isc/netmgr/tcp.c b/lib/isc/netmgr/tcp.c
--- a/lib/isc/netmgr/tcp.c
+++ b/lib/isc/netmgr/tcp.c
@@ -144,15 +144,12 @@ tcp_connect_direct(isc_nmsocket_t *sock, isc__nm_uvreq_t *req) {
 	r = uv_tcp_open(&sock->uv_handle.tcp, sock->fd);
 	if (r != 0) {
 		isc__nm_closesocket(sock->fd);
-		isc__nm_incstats(sock, STATID_OPENFAIL);
 		goto done;
 	}
-	isc__nm_incstats(sock, STATID_OPEN);
 
 	if (req->local.length != 0) {
 		r = uv_tcp_bind(&sock->uv_handle.tcp, &req->local.type.sa, 0);
 		if (r != 0) {
-			isc__nm_incstats(sock, STATID_BINDFAIL);
 			goto done;
 		}
 	}
@@ -163,7 +160,6 @@ tcp_connect_direct(isc_nmsocket_t *sock, isc__nm_uvreq_t *req) {
 	r = uv_tcp_connect(&req->uv_req.connect, &sock->uv_handle.tcp,
 			   &req->peer.type.sa, tcp_connect_cb);
 	if (r != 0) {
-		isc__nm_incstats(sock, STATID_CONNECTFAIL);
 		goto done;
 	}
 
@@ -281,7 +277,6 @@ tcp_connect_cb(uv_connect_t *uvreq, int status) {
 	isc__nmsocket_timer_stop(sock);
 	uv_handle_set_data((uv_handle_t *)&sock->read_timer, sock);
 
-	isc__nm_incstats(sock, STATID_CONNECT);
 	r = uv_tcp_getpeername(&sock->uv_handle.tcp, (struct sockaddr *)&ss,
 			       &(int){ sizeof(ss) });
 	if (r != 0) {
@@ -557,10 +552,8 @@ isc__nm_async_tcplisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 	r = uv_tcp_open(&sock->uv_handle.tcp, sock->fd);
 	if (r < 0) {
 		isc__nm_closesocket(sock->fd);
-		isc__nm_incstats(sock, STATID_OPENFAIL);
 		goto done;
 	}
-	isc__nm_incstats(sock, STATID_OPEN);
 
 	if (sa_family == AF_INET6) {
 		flags = UV_TCP_IPV6ONLY;
@@ -570,7 +563,6 @@ isc__nm_async_tcplisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 		r = isc_uv_tcp_freebind(&sock->uv_handle.tcp,
 					&sock->iface.type.sa, flags);
 		if (r < 0) {
-			isc__nm_incstats(sock, STATID_BINDFAIL);
 			goto done;
 		}
 	} else {
@@ -578,7 +570,6 @@ isc__nm_async_tcplisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 			r = isc_uv_tcp_freebind(&sock->uv_handle.tcp,
 						&sock->iface.type.sa, flags);
 			if (r < 0) {
-				isc__nm_incstats(sock, STATID_BINDFAIL);
 				goto done;
 			}
 			sock->parent->uv_handle.tcp.flags =
@@ -604,7 +595,6 @@ isc__nm_async_tcplisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 			      ISC_LOGMODULE_NETMGR, ISC_LOG_ERROR,
 			      "uv_listen failed: %s",
 			      isc_result_totext(isc__nm_uverr2result(r)));
-		isc__nm_incstats(sock, STATID_BINDFAIL);
 		goto done;
 	}
 
@@ -649,7 +639,6 @@ tcp_connection_cb(uv_stream_t *server, int status) {
 		result = isc_quota_attach_cb(ssock->pquota, &quota,
 					     &ssock->quotacb);
 		if (result == ISC_R_QUOTA) {
-			isc__nm_incstats(ssock, STATID_ACCEPTFAIL);
 			goto done;
 		}
 	}
@@ -879,10 +868,6 @@ isc__nm_tcp_read_cb(uv_stream_t *stream, ssize_t nread, const uv_buf_t *buf) {
 	}
 
 	if (nread < 0) {
-		if (nread != UV_EOF) {
-			isc__nm_incstats(sock, STATID_RECVFAIL);
-		}
-
 		isc__nm_tcp_failed_read_cb(sock, isc__nm_uverr2result(nread));
 
 		goto free;
@@ -1068,8 +1053,6 @@ accept_connection(isc_nmsocket_t *ssock, isc_quota_t *quota) {
 
 	atomic_store(&csock->accepting, false);
 
-	isc__nm_incstats(csock, STATID_ACCEPT);
-
 	csock->read_timeout = atomic_load(&csock->mgr->init);
 
 	atomic_fetch_add(&ssock->parent->active_child_connections, 1);
@@ -1169,7 +1152,6 @@ tcp_send_cb(uv_write_t *req, int status) {
 	isc_nm_timer_detach(&uvreq->timer);
 
 	if (status < 0) {
-		isc__nm_incstats(sock, STATID_SENDFAIL);
 		isc__nm_failed_send_cb(sock, uvreq,
 				       isc__nm_uverr2result(status));
 
@@ -1214,7 +1196,6 @@ isc__nm_async_tcpsend(isc__networker_t *worker, isc__netievent_t *ev0) {
 
 	result = tcp_send_direct(sock, uvreq);
 	if (result != ISC_R_SUCCESS) {
-		isc__nm_incstats(sock, STATID_SENDFAIL);
 		isc__nm_failed_send_cb(sock, uvreq, result);
 	}
 }
@@ -1262,8 +1243,6 @@ tcp_stop_cb(uv_handle_t *handle) {
 		UNREACHABLE();
 	}
 
-	isc__nm_incstats(sock, STATID_CLOSE);
-
 	atomic_store(&sock->listening, false);
 
 	isc__nmsocket_detach(&sock);
@@ -1281,8 +1260,6 @@ tcp_close_sock(isc_nmsocket_t *sock) {
 		UNREACHABLE();
 	}
 
-	isc__nm_incstats(sock, STATID_CLOSE);
-
 	if (sock->server != NULL) {
 		isc__nmsocket_detach(&sock->server);
 	}
diff --git a/lib/isc/netmgr/tcpdns.c b/lib/isc/netmgr/tcpdns.c
--- a/lib/isc/netmgr/tcpdns.c
+++ b/lib/isc/netmgr/tcpdns.c
@@ -110,10 +110,8 @@ tcpdns_connect_direct(isc_nmsocket_t *sock, isc__nm_uvreq_t *req) {
 	r = uv_tcp_open(&sock->uv_handle.tcp, sock->fd);
 	if (r != 0) {
 		isc__nm_closesocket(sock->fd);
-		isc__nm_incstats(sock, STATID_OPENFAIL);
 		goto done;
 	}
-	isc__nm_incstats(sock, STATID_OPEN);
 
 	if (req->local.length != 0) {
 		r = uv_tcp_bind(&sock->uv_handle.tcp, &req->local.type.sa, 0);
@@ -122,7 +120,6 @@ tcpdns_connect_direct(isc_nmsocket_t *sock, isc__nm_uvreq_t *req) {
 		 * to be ignored
 		 */
 		if (r != 0 && r != UV_EINVAL) {
-			isc__nm_incstats(sock, STATID_BINDFAIL);
 			goto done;
 		}
 	}
@@ -133,7 +130,6 @@ tcpdns_connect_direct(isc_nmsocket_t *sock, isc__nm_uvreq_t *req) {
 	r = uv_tcp_connect(&req->uv_req.connect, &sock->uv_handle.tcp,
 			   &req->peer.type.sa, tcpdns_connect_cb);
 	if (r != 0) {
-		isc__nm_incstats(sock, STATID_CONNECTFAIL);
 		goto done;
 	}
 
@@ -244,7 +240,6 @@ tcpdns_connect_cb(uv_connect_t *uvreq, int status) {
 	isc__nmsocket_timer_stop(sock);
 	uv_handle_set_data((uv_handle_t *)&sock->read_timer, sock);
 
-	isc__nm_incstats(sock, STATID_CONNECT);
 	r = uv_tcp_getpeername(&sock->uv_handle.tcp, (struct sockaddr *)&ss,
 			       &(int){ sizeof(ss) });
 	if (r != 0) {
@@ -523,10 +518,8 @@ isc__nm_async_tcpdnslisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 	r = uv_tcp_open(&sock->uv_handle.tcp, sock->fd);
 	if (r < 0) {
 		isc__nm_closesocket(sock->fd);
-		isc__nm_incstats(sock, STATID_OPENFAIL);
 		goto done;
 	}
-	isc__nm_incstats(sock, STATID_OPEN);
 
 	if (sa_family == AF_INET6) {
 		flags = UV_TCP_IPV6ONLY;
@@ -536,7 +529,6 @@ isc__nm_async_tcpdnslisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 		r = isc_uv_tcp_freebind(&sock->uv_handle.tcp,
 					&sock->iface.type.sa, flags);
 		if (r < 0) {
-			isc__nm_incstats(sock, STATID_BINDFAIL);
 			goto done;
 		}
 	} else {
@@ -544,7 +536,6 @@ isc__nm_async_tcpdnslisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 			r = isc_uv_tcp_freebind(&sock->uv_handle.tcp,
 						&sock->iface.type.sa, flags);
 			if (r < 0) {
-				isc__nm_incstats(sock, STATID_BINDFAIL);
 				goto done;
 			}
 			sock->parent->uv_handle.tcp.flags =
@@ -570,7 +561,6 @@ isc__nm_async_tcpdnslisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 			      ISC_LOGMODULE_NETMGR, ISC_LOG_ERROR,
 			      "uv_listen failed: %s",
 			      isc_result_totext(isc__nm_uverr2result(r)));
-		isc__nm_incstats(sock, STATID_BINDFAIL);
 		goto done;
 	}
 
@@ -615,7 +605,6 @@ tcpdns_connection_cb(uv_stream_t *server, int status) {
 		result = isc_quota_attach_cb(ssock->pquota, &quota,
 					     &ssock->quotacb);
 		if (result == ISC_R_QUOTA) {
-			isc__nm_incstats(ssock, STATID_ACCEPTFAIL);
 			goto done;
 		}
 	}
@@ -689,7 +678,6 @@ destroy:
 	 * chance to be executed.
 	 */
 	if (sock->quota != NULL) {
-		isc__nm_decstats(sock, STATID_CLIENTS);
 		isc_quota_detach(&sock->quota);
 	}
 }
@@ -880,10 +868,6 @@ isc__nm_tcpdns_read_cb(uv_stream_t *stream, ssize_t nread,
 	}
 
 	if (nread < 0) {
-		if (nread != UV_EOF) {
-			isc__nm_incstats(sock, STATID_RECVFAIL);
-		}
-
 		isc__nm_failed_read_cb(sock, isc__nm_uverr2result(nread), true);
 		goto free;
 	}
@@ -1075,8 +1059,6 @@ accept_connection(isc_nmsocket_t *ssock, isc_quota_t *quota) {
 
 	atomic_store(&csock->accepting, false);
 
-	isc__nm_incstats(csock, STATID_ACCEPT);
-
 	csock->read_timeout = atomic_load(&csock->mgr->init);
 
 	csock->closehandle_cb = isc__nm_resume_processing;
@@ -1104,8 +1086,6 @@ accept_connection(isc_nmsocket_t *ssock, isc_quota_t *quota) {
 
 	isc_nmhandle_detach(&handle);
 
-	isc__nm_incstats(csock, STATID_CLIENTS);
-
 	/*
 	 * sock is now attached to the handle.
 	 */
@@ -1184,7 +1164,6 @@ tcpdns_send_cb(uv_write_t *req, int status) {
 	isc_nm_timer_detach(&uvreq->timer);
 
 	if (status < 0) {
-		isc__nm_incstats(sock, STATID_SENDFAIL);
 		isc__nm_failed_send_cb(sock, uvreq,
 				       isc__nm_uverr2result(status));
 
@@ -1297,7 +1276,6 @@ isc__nm_async_tcpdnssend(isc__networker_t *worker, isc__netievent_t *ev0) {
 
 	return;
 fail:
-	isc__nm_incstats(sock, STATID_SENDFAIL);
 	isc__nm_failed_send_cb(sock, uvreq, result);
 }
 
@@ -1317,8 +1295,6 @@ tcpdns_stop_cb(uv_handle_t *handle) {
 		UNREACHABLE();
 	}
 
-	isc__nm_incstats(sock, STATID_CLOSE);
-
 	atomic_store(&sock->listening, false);
 
 	isc__nmsocket_detach(&sock);
@@ -1336,8 +1312,6 @@ tcpdns_close_sock(isc_nmsocket_t *sock) {
 		UNREACHABLE();
 	}
 
-	isc__nm_incstats(sock, STATID_CLOSE);
-
 	if (sock->server != NULL) {
 		isc__nmsocket_detach(&sock->server);
 	}
@@ -1430,7 +1404,6 @@ tcpdns_close_direct(isc_nmsocket_t *sock) {
 	REQUIRE(atomic_load(&sock->closing));
 
 	if (sock->quota != NULL) {
-		isc__nm_decstats(sock, STATID_CLIENTS);
 		isc_quota_detach(&sock->quota);
 	}
 
diff --git a/lib/isc/netmgr/tlsdns.c b/lib/isc/netmgr/tlsdns.c
--- a/lib/isc/netmgr/tlsdns.c
+++ b/lib/isc/netmgr/tlsdns.c
@@ -151,10 +151,8 @@ tlsdns_connect_direct(isc_nmsocket_t *sock, isc__nm_uvreq_t *req) {
 	r = uv_tcp_open(&sock->uv_handle.tcp, sock->fd);
 	if (r != 0) {
 		isc__nm_closesocket(sock->fd);
-		isc__nm_incstats(sock, STATID_OPENFAIL);
 		goto done;
 	}
-	isc__nm_incstats(sock, STATID_OPEN);
 
 	if (req->local.length != 0) {
 		r = uv_tcp_bind(&sock->uv_handle.tcp, &req->local.type.sa, 0);
@@ -163,7 +161,6 @@ tlsdns_connect_direct(isc_nmsocket_t *sock, isc__nm_uvreq_t *req) {
 		 * to be ignored
 		 */
 		if (r != 0 && r != UV_EINVAL) {
-			isc__nm_incstats(sock, STATID_BINDFAIL);
 			goto done;
 		}
 	}
@@ -174,7 +171,6 @@ tlsdns_connect_direct(isc_nmsocket_t *sock, isc__nm_uvreq_t *req) {
 	r = uv_tcp_connect(&req->uv_req.connect, &sock->uv_handle.tcp,
 			   &req->peer.type.sa, tlsdns_connect_cb);
 	if (r != 0) {
-		isc__nm_incstats(sock, STATID_CONNECTFAIL);
 		goto done;
 	}
 
@@ -284,7 +280,6 @@ tlsdns_connect_cb(uv_connect_t *uvreq, int status) {
 		goto error;
 	}
 
-	isc__nm_incstats(sock, STATID_CONNECT);
 	r = uv_tcp_getpeername(&sock->uv_handle.tcp, (struct sockaddr *)&ss,
 			       &(int){ sizeof(ss) });
 	if (r != 0) {
@@ -638,10 +633,8 @@ isc__nm_async_tlsdnslisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 	r = uv_tcp_open(&sock->uv_handle.tcp, sock->fd);
 	if (r < 0) {
 		isc__nm_closesocket(sock->fd);
-		isc__nm_incstats(sock, STATID_OPENFAIL);
 		goto done;
 	}
-	isc__nm_incstats(sock, STATID_OPEN);
 
 	if (sa_family == AF_INET6) {
 		flags = UV_TCP_IPV6ONLY;
@@ -651,7 +644,6 @@ isc__nm_async_tlsdnslisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 		r = isc_uv_tcp_freebind(&sock->uv_handle.tcp,
 					&sock->iface.type.sa, flags);
 		if (r < 0) {
-			isc__nm_incstats(sock, STATID_BINDFAIL);
 			goto done;
 		}
 	} else {
@@ -659,7 +651,6 @@ isc__nm_async_tlsdnslisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 			r = isc_uv_tcp_freebind(&sock->uv_handle.tcp,
 						&sock->iface.type.sa, flags);
 			if (r < 0) {
-				isc__nm_incstats(sock, STATID_BINDFAIL);
 				goto done;
 			}
 			sock->parent->uv_handle.tcp.flags =
@@ -686,7 +677,6 @@ isc__nm_async_tlsdnslisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 			      ISC_LOGMODULE_NETMGR, ISC_LOG_ERROR,
 			      "uv_listen failed: %s",
 			      isc_result_totext(isc__nm_uverr2result(r)));
-		isc__nm_incstats(sock, STATID_BINDFAIL);
 		goto done;
 	}
 
@@ -731,7 +721,6 @@ tlsdns_connection_cb(uv_stream_t *server, int status) {
 		result = isc_quota_attach_cb(ssock->pquota, &quota,
 					     &ssock->quotacb);
 		if (result == ISC_R_QUOTA) {
-			isc__nm_incstats(ssock, STATID_ACCEPTFAIL);
 			goto done;
 		}
 	}
@@ -898,7 +887,6 @@ destroy:
 	 * had a chance to be executed.
 	 */
 	if (sock->quota != NULL) {
-		isc__nm_decstats(sock, STATID_CLIENTS);
 		isc_quota_detach(&sock->quota);
 	}
 }
@@ -1513,10 +1501,6 @@ isc__nm_tlsdns_read_cb(uv_stream_t *stream, ssize_t nread,
 	}
 
 	if (nread < 0) {
-		if (nread != UV_EOF) {
-			isc__nm_incstats(sock, STATID_RECVFAIL);
-		}
-
 		isc__nm_failed_read_cb(sock, isc__nm_uverr2result(nread), true);
 
 		goto free;
@@ -1724,8 +1708,6 @@ accept_connection(isc_nmsocket_t *ssock, isc_quota_t *quota) {
 
 	atomic_store(&csock->accepting, false);
 
-	isc__nm_incstats(csock, STATID_ACCEPT);
-
 	csock->read_timeout = atomic_load(&csock->mgr->init);
 
 	csock->closehandle_cb = isc__nm_resume_processing;
@@ -1753,8 +1735,6 @@ accept_connection(isc_nmsocket_t *ssock, isc_quota_t *quota) {
 		goto failure;
 	}
 
-	isc__nm_incstats(csock, STATID_CLIENTS);
-
 	/*
 	 * sock is now attached to the handle.
 	 */
@@ -1842,7 +1822,6 @@ isc__nm_async_tlsdnssend(isc__networker_t *worker, isc__netievent_t *ev0) {
 
 	result = tlsdns_send_direct(sock, uvreq);
 	if (result != ISC_R_SUCCESS) {
-		isc__nm_incstats(sock, STATID_SENDFAIL);
 		isc__nm_failed_send_cb(sock, uvreq, result);
 	}
 }
@@ -2014,8 +1993,6 @@ tlsdns_stop_cb(uv_handle_t *handle) {
 		UNREACHABLE();
 	}
 
-	isc__nm_incstats(sock, STATID_CLOSE);
-
 	atomic_store(&sock->listening, false);
 
 	BIO_free_all(sock->tls.app_rbio);
@@ -2040,8 +2017,6 @@ tlsdns_close_sock(isc_nmsocket_t *sock) {
 		UNREACHABLE();
 	}
 
-	isc__nm_incstats(sock, STATID_CLOSE);
-
 	if (sock->server != NULL) {
 		isc__nmsocket_detach(&sock->server);
 	}
@@ -2153,7 +2128,6 @@ tlsdns_close_direct(isc_nmsocket_t *sock) {
 	REQUIRE(sock->tls.pending_req == NULL);
 
 	if (sock->quota != NULL) {
-		isc__nm_decstats(sock, STATID_CLIENTS);
 		isc_quota_detach(&sock->quota);
 	}
 
diff --git a/lib/isc/netmgr/udp.c b/lib/isc/netmgr/udp.c
--- a/lib/isc/netmgr/udp.c
+++ b/lib/isc/netmgr/udp.c
@@ -458,10 +458,8 @@ isc__nm_async_udplisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 	r = uv_udp_open(&sock->uv_handle.udp, sock->fd);
 	if (r < 0) {
 		isc__nm_closesocket(sock->fd);
-		isc__nm_incstats(sock, STATID_OPENFAIL);
 		goto done;
 	}
-	isc__nm_incstats(sock, STATID_OPEN);
 
 	if (sa_family == AF_INET6) {
 		uv_bind_flags |= UV_UDP_IPV6ONLY;
@@ -472,7 +470,6 @@ isc__nm_async_udplisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 					&sock->parent->iface.type.sa,
 					uv_bind_flags);
 		if (r < 0) {
-			isc__nm_incstats(sock, STATID_BINDFAIL);
 			goto done;
 		}
 	} else {
@@ -482,7 +479,6 @@ isc__nm_async_udplisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 						&sock->parent->iface.type.sa,
 						uv_bind_flags);
 			if (r < 0) {
-				isc__nm_incstats(sock, STATID_BINDFAIL);
 				goto done;
 			}
 			sock->parent->uv_handle.udp.flags =
@@ -500,7 +496,6 @@ isc__nm_async_udplisten(isc__networker_t *worker, isc__netievent_t *ev0) {
 	r = uv_udp_recv_start(&sock->uv_handle.udp, isc__nm_alloc_cb,
 			      udp_recv_cb);
 	if (r != 0) {
-		isc__nm_incstats(sock, STATID_BINDFAIL);
 		goto done;
 	}
 
@@ -784,7 +779,6 @@ isc__nm_async_udpsend(isc__networker_t *worker, isc__netievent_t *ev0) {
 
 	result = udp_send_direct(sock, uvreq, &ievent->peer);
 	if (result != ISC_R_SUCCESS) {
-		isc__nm_incstats(sock, STATID_SENDFAIL);
 		isc__nm_failed_send_cb(sock, uvreq, result);
 	}
 }
@@ -804,7 +798,6 @@ udp_send_cb(uv_udp_send_t *req, int status) {
 
 	if (status < 0) {
 		result = isc__nm_uverr2result(status);
-		isc__nm_incstats(sock, STATID_SENDFAIL);
 	}
 
 	isc__nm_sendcb(sock, uvreq, result, false);
@@ -919,10 +912,8 @@ udp_connect_direct(isc_nmsocket_t *sock, isc__nm_uvreq_t *req) {
 
 	r = uv_udp_open(&sock->uv_handle.udp, sock->fd);
 	if (r != 0) {
-		isc__nm_incstats(sock, STATID_OPENFAIL);
 		goto done;
 	}
-	isc__nm_incstats(sock, STATID_OPEN);
 
 	/*
 	 * uv_udp_open() enables REUSE_ADDR, we need to disable it again.
@@ -937,7 +928,6 @@ udp_connect_direct(isc_nmsocket_t *sock, isc__nm_uvreq_t *req) {
 	r = uv_udp_bind(&sock->uv_handle.udp, &sock->iface.type.sa,
 			uv_bind_flags);
 	if (r != 0) {
-		isc__nm_incstats(sock, STATID_BINDFAIL);
 		goto done;
 	}
 
@@ -953,10 +943,8 @@ udp_connect_direct(isc_nmsocket_t *sock, isc__nm_uvreq_t *req) {
 				       &req->peer.type.sa);
 	} while (r == UV_EADDRINUSE && --req->connect_tries > 0);
 	if (r != 0) {
-		isc__nm_incstats(sock, STATID_CONNECTFAIL);
 		goto done;
 	}
-	isc__nm_incstats(sock, STATID_CONNECT);
 
 	atomic_store(&sock->connecting, false);
 	atomic_store(&sock->connected, true);
@@ -1229,8 +1217,6 @@ udp_stop_cb(uv_handle_t *handle) {
 		UNREACHABLE();
 	}
 
-	isc__nm_incstats(sock, STATID_CLOSE);
-
 	atomic_store(&sock->listening, false);
 
 	isc__nmsocket_detach(&sock);
@@ -1251,8 +1237,6 @@ udp_close_cb(uv_handle_t *handle) {
 		UNREACHABLE();
 	}
 
-	isc__nm_incstats(sock, STATID_CLOSE);
-
 	if (sock->server != NULL) {
 		isc__nmsocket_detach(&sock->server);
 	}
diff --git a/lib/isc/stdio.c b/lib/isc/stdio.c
--- a/lib/isc/stdio.c
+++ b/lib/isc/stdio.c
@@ -143,10 +143,18 @@ isc_stdio_sync(FILE *f) {
 		return ISC_R_SUCCESS;
 	}
 
+#if 0
 	r = fsync(fileno(f));
 	if (r == 0) {
 		return ISC_R_SUCCESS;
 	} else {
 		return isc__errno2result(errno);
 	}
+#endif
+	r = fflush(f);
+	if (r == 0) {
+		return ISC_R_SUCCESS;
+	} else {
+		return isc__errno2result(errno);
+	}
 }
diff --git a/lib/isc/stdtime.c b/lib/isc/stdtime.c
--- a/lib/isc/stdtime.c
+++ b/lib/isc/stdtime.c
@@ -17,7 +17,6 @@
 #include <stdbool.h>
 #include <stddef.h> /* NULL */
 #include <stdlib.h> /* NULL */
-#include <syslog.h>
 #include <time.h>
 
 #include <isc/stdtime.h>
@@ -55,10 +54,8 @@ isc_stdtime_tostring(isc_stdtime_t t, char *out, size_t outlen) {
 	REQUIRE(out != NULL);
 	REQUIRE(outlen >= 26);
 
-	UNUSED(outlen);
-
 	/* time_t and isc_stdtime_t might be different sizes */
 	when = t;
-	INSIST(ctime_r(&when, out) != NULL);
+	INSIST(ctime_s(out, outlen, &when) != 0);
 	*(out + strlen(out) - 1) = '\0';
 }
diff --git a/lib/isc/string.c b/lib/isc/string.c
--- a/lib/isc/string.c
+++ b/lib/isc/string.c
@@ -141,5 +141,5 @@ strnstr(const char *s, const char *find, size_t slen) {
 
 int
 isc_string_strerror_r(int errnum, char *buf, size_t buflen) {
-	return strerror_r(errnum, buf, buflen);
+	return strerror_s(buf, buflen, errnum);
 }
diff --git a/lib/isc/task.c b/lib/isc/task.c
--- a/lib/isc/task.c
+++ b/lib/isc/task.c
@@ -38,15 +38,6 @@
 #include <isc/time.h>
 #include <isc/util.h>
 
-#ifdef HAVE_LIBXML2
-#include <libxml/xmlwriter.h>
-#define ISC_XMLCHAR (const xmlChar *)
-#endif /* HAVE_LIBXML2 */
-
-#ifdef HAVE_JSON_C
-#include <json_object.h>
-#endif /* HAVE_JSON_C */
-
 #include "task_p.h"
 
 /*
@@ -84,15 +75,6 @@ typedef enum {
 	task_state_done	    /* shutting down, no events or references */
 } task_state_t;
 
-#if defined(HAVE_LIBXML2) || defined(HAVE_JSON_C)
-static const char *statenames[] = {
-	"idle",
-	"ready",
-	"running",
-	"done",
-};
-#endif /* if defined(HAVE_LIBXML2) || defined(HAVE_JSON_C) */
-
 #define TASK_MAGIC    ISC_MAGIC('T', 'A', 'S', 'K')
 #define VALID_TASK(t) ISC_MAGIC_VALID(t, TASK_MAGIC)
 
@@ -1202,184 +1184,3 @@ isc_task_exiting(isc_task_t *task) {
 
 	return TASK_SHUTTINGDOWN(task);
 }
-
-#ifdef HAVE_LIBXML2
-#define TRY0(a)                     \
-	do {                        \
-		xmlrc = (a);        \
-		if (xmlrc < 0)      \
-			goto error; \
-	} while (0)
-int
-isc_taskmgr_renderxml(isc_taskmgr_t *mgr, void *writer0) {
-	isc_task_t *task = NULL;
-	int xmlrc;
-	xmlTextWriterPtr writer = (xmlTextWriterPtr)writer0;
-
-	LOCK(&mgr->lock);
-
-	/*
-	 * Write out the thread-model, and some details about each depending
-	 * on which type is enabled.
-	 */
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "thread-model"));
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "type"));
-	TRY0(xmlTextWriterWriteString(writer, ISC_XMLCHAR "threaded"));
-	TRY0(xmlTextWriterEndElement(writer)); /* type */
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "default-quantum"));
-	TRY0(xmlTextWriterWriteFormatString(writer, "%d",
-					    mgr->default_quantum));
-	TRY0(xmlTextWriterEndElement(writer)); /* default-quantum */
-
-	TRY0(xmlTextWriterEndElement(writer)); /* thread-model */
-
-	TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "tasks"));
-	task = ISC_LIST_HEAD(mgr->tasks);
-	while (task != NULL) {
-		LOCK(&task->lock);
-		TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "task"));
-
-		if (task->name[0] != 0) {
-			TRY0(xmlTextWriterStartElement(writer,
-						       ISC_XMLCHAR "name"));
-			TRY0(xmlTextWriterWriteFormatString(writer, "%s",
-							    task->name));
-			TRY0(xmlTextWriterEndElement(writer)); /* name */
-		}
-
-		TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "reference"
-								   "s"));
-		TRY0(xmlTextWriterWriteFormatString(
-			writer, "%" PRIuFAST32,
-			isc_refcount_current(&task->references)));
-		TRY0(xmlTextWriterEndElement(writer)); /* references */
-
-		TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "id"));
-		TRY0(xmlTextWriterWriteFormatString(writer, "%p", task));
-		TRY0(xmlTextWriterEndElement(writer)); /* id */
-
-		TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "state"));
-		TRY0(xmlTextWriterWriteFormatString(writer, "%s",
-						    statenames[task->state]));
-		TRY0(xmlTextWriterEndElement(writer)); /* state */
-
-		TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "quantum"));
-		TRY0(xmlTextWriterWriteFormatString(writer, "%d",
-						    task->quantum));
-		TRY0(xmlTextWriterEndElement(writer)); /* quantum */
-
-		TRY0(xmlTextWriterStartElement(writer, ISC_XMLCHAR "events"));
-		TRY0(xmlTextWriterWriteFormatString(writer, "%d",
-						    task->nevents));
-		TRY0(xmlTextWriterEndElement(writer)); /* events */
-
-		TRY0(xmlTextWriterEndElement(writer));
-
-		UNLOCK(&task->lock);
-		task = ISC_LIST_NEXT(task, link);
-	}
-	TRY0(xmlTextWriterEndElement(writer)); /* tasks */
-
-error:
-	if (task != NULL) {
-		UNLOCK(&task->lock);
-	}
-	UNLOCK(&mgr->lock);
-
-	return xmlrc;
-}
-#endif /* HAVE_LIBXML2 */
-
-#ifdef HAVE_JSON_C
-#define CHECKMEM(m)                              \
-	do {                                     \
-		if (m == NULL) {                 \
-			result = ISC_R_NOMEMORY; \
-			goto error;              \
-		}                                \
-	} while (0)
-
-isc_result_t
-isc_taskmgr_renderjson(isc_taskmgr_t *mgr, void *tasks0) {
-	isc_result_t result = ISC_R_SUCCESS;
-	isc_task_t *task = NULL;
-	json_object *obj = NULL, *array = NULL, *taskobj = NULL;
-	json_object *tasks = (json_object *)tasks0;
-
-	LOCK(&mgr->lock);
-
-	/*
-	 * Write out the thread-model, and some details about each depending
-	 * on which type is enabled.
-	 */
-	obj = json_object_new_string("threaded");
-	CHECKMEM(obj);
-	json_object_object_add(tasks, "thread-model", obj);
-
-	obj = json_object_new_int(mgr->default_quantum);
-	CHECKMEM(obj);
-	json_object_object_add(tasks, "default-quantum", obj);
-
-	array = json_object_new_array();
-	CHECKMEM(array);
-
-	for (task = ISC_LIST_HEAD(mgr->tasks); task != NULL;
-	     task = ISC_LIST_NEXT(task, link))
-	{
-		char buf[255];
-
-		LOCK(&task->lock);
-
-		taskobj = json_object_new_object();
-		CHECKMEM(taskobj);
-		json_object_array_add(array, taskobj);
-
-		snprintf(buf, sizeof(buf), "%p", task);
-		obj = json_object_new_string(buf);
-		CHECKMEM(obj);
-		json_object_object_add(taskobj, "id", obj);
-
-		if (task->name[0] != 0) {
-			obj = json_object_new_string(task->name);
-			CHECKMEM(obj);
-			json_object_object_add(taskobj, "name", obj);
-		}
-
-		obj = json_object_new_int(
-			isc_refcount_current(&task->references));
-		CHECKMEM(obj);
-		json_object_object_add(taskobj, "references", obj);
-
-		obj = json_object_new_string(statenames[task->state]);
-		CHECKMEM(obj);
-		json_object_object_add(taskobj, "state", obj);
-
-		obj = json_object_new_int(task->quantum);
-		CHECKMEM(obj);
-		json_object_object_add(taskobj, "quantum", obj);
-
-		obj = json_object_new_int(task->nevents);
-		CHECKMEM(obj);
-		json_object_object_add(taskobj, "events", obj);
-
-		UNLOCK(&task->lock);
-	}
-
-	json_object_object_add(tasks, "tasks", array);
-	array = NULL;
-	result = ISC_R_SUCCESS;
-
-error:
-	if (array != NULL) {
-		json_object_put(array);
-	}
-
-	if (task != NULL) {
-		UNLOCK(&task->lock);
-	}
-	UNLOCK(&mgr->lock);
-
-	return result;
-}
-#endif /* ifdef HAVE_JSON_C */
diff --git a/lib/isc/time.c b/lib/isc/time.c
--- a/lib/isc/time.c
+++ b/lib/isc/time.c
@@ -19,7 +19,6 @@
 #include <stdbool.h>
 #include <stdlib.h>
 #include <sys/time.h> /* Required for struct timeval on some platforms. */
-#include <syslog.h>
 #include <time.h>
 
 #include <isc/log.h>
@@ -375,7 +374,8 @@ isc_time_formattimestamp(const isc_time_t *t, char *buf, unsigned int len) {
 	REQUIRE(len > 0);
 
 	now = (time_t)t->seconds;
-	flen = strftime(buf, len, "%d-%b-%Y %X", localtime_r(&now, &tm));
+	INSIST(localtime_s(&tm, &now) == 0);
+	flen = strftime(buf, len, "%d-%b-%Y %X", &tm);
 	INSIST(flen < len);
 	if (flen != 0) {
 		snprintf(buf + flen, len - flen, ".%03u",
@@ -401,8 +401,8 @@ isc_time_formathttptimestamp(const isc_time_t *t, char *buf, unsigned int len) {
 	 * %b (29+)
 	 */
 	now = (time_t)t->seconds;
-	flen = strftime(buf, len, "%a, %d %b %Y %H:%M:%S GMT",
-			gmtime_r(&now, &tm));
+	INSIST(gmtime_s(&tm, &now) == 0);
+	flen = strftime(buf, len, "%a, %d %b %Y %H:%M:%S GMT", &tm);
 	INSIST(flen < len);
 }
 
@@ -439,7 +439,8 @@ isc_time_formatISO8601L(const isc_time_t *t, char *buf, unsigned int len) {
 	REQUIRE(len > 0);
 
 	now = (time_t)t->seconds;
-	flen = strftime(buf, len, "%Y-%m-%dT%H:%M:%S", localtime_r(&now, &tm));
+	INSIST(localtime_s(&tm, &now) == 0);
+	flen = strftime(buf, len, "%Y-%m-%dT%H:%M:%S", &tm);
 	INSIST(flen < len);
 }
 
@@ -455,7 +456,8 @@ isc_time_formatISO8601Lms(const isc_time_t *t, char *buf, unsigned int len) {
 	REQUIRE(len > 0);
 
 	now = (time_t)t->seconds;
-	flen = strftime(buf, len, "%Y-%m-%dT%H:%M:%S", localtime_r(&now, &tm));
+	INSIST(localtime_s(&tm, &now) == 0);
+	flen = strftime(buf, len, "%Y-%m-%dT%H:%M:%S", &tm);
 	INSIST(flen < len);
 	if (flen > 0U && len - flen >= 6) {
 		snprintf(buf + flen, len - flen, ".%03u",
@@ -475,7 +477,8 @@ isc_time_formatISO8601Lus(const isc_time_t *t, char *buf, unsigned int len) {
 	REQUIRE(len > 0);
 
 	now = (time_t)t->seconds;
-	flen = strftime(buf, len, "%Y-%m-%dT%H:%M:%S", localtime_r(&now, &tm));
+	INSIST(localtime_s(&tm, &now) == 0);
+	flen = strftime(buf, len, "%Y-%m-%dT%H:%M:%S", &tm);
 	INSIST(flen < len);
 	if (flen > 0U && len - flen >= 6) {
 		snprintf(buf + flen, len - flen, ".%06u",
@@ -495,7 +498,8 @@ isc_time_formatISO8601(const isc_time_t *t, char *buf, unsigned int len) {
 	REQUIRE(len > 0);
 
 	now = (time_t)t->seconds;
-	flen = strftime(buf, len, "%Y-%m-%dT%H:%M:%SZ", gmtime_r(&now, &tm));
+	INSIST(gmtime_s(&tm, &now) == 0);
+	flen = strftime(buf, len, "%Y-%m-%dT%H:%M:%SZ", &tm);
 	INSIST(flen < len);
 }
 
@@ -511,7 +515,8 @@ isc_time_formatISO8601ms(const isc_time_t *t, char *buf, unsigned int len) {
 	REQUIRE(len > 0);
 
 	now = (time_t)t->seconds;
-	flen = strftime(buf, len, "%Y-%m-%dT%H:%M:%SZ", gmtime_r(&now, &tm));
+	INSIST(gmtime_s(&tm, &now) == 0);
+	flen = strftime(buf, len, "%Y-%m-%dT%H:%M:%SZ", &tm);
 	INSIST(flen < len);
 	if (flen > 0U && len - flen >= 5) {
 		flen -= 1; /* rewind one character (Z) */
@@ -532,7 +537,8 @@ isc_time_formatISO8601us(const isc_time_t *t, char *buf, unsigned int len) {
 	REQUIRE(len > 0);
 
 	now = (time_t)t->seconds;
-	flen = strftime(buf, len, "%Y-%m-%dT%H:%M:%SZ", gmtime_r(&now, &tm));
+	INSIST(gmtime_s(&tm, &now) == 0);
+	flen = strftime(buf, len, "%Y-%m-%dT%H:%M:%SZ", &tm);
 	INSIST(flen < len);
 	if (flen > 0U && len - flen >= 5) {
 		flen -= 1; /* rewind one character (Z) */
@@ -554,7 +560,8 @@ isc_time_formatshorttimestamp(const isc_time_t *t, char *buf,
 	REQUIRE(len > 0);
 
 	now = (time_t)t->seconds;
-	flen = strftime(buf, len, "%Y%m%d%H%M%S", gmtime_r(&now, &tm));
+	INSIST(gmtime_s(&tm, &now) == 0);
+	flen = strftime(buf, len, "%Y%m%d%H%M%S", &tm);
 	INSIST(flen < len);
 	if (flen > 0U && len - flen >= 5) {
 		snprintf(buf + flen, len - flen, "%03u",
diff --git a/lib/isc/tls.c b/lib/isc/tls.c
--- a/lib/isc/tls.c
+++ b/lib/isc/tls.c
@@ -12,14 +12,13 @@
  */
 
 #include <inttypes.h>
-#include <netinet/in.h>
+#include <winsock2.h>
+#include <ws2tcpip.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/socket.h>
 #if HAVE_LIBNGHTTP2
 #include <nghttp2/nghttp2.h>
 #endif /* HAVE_LIBNGHTTP2 */
-#include <arpa/inet.h>
 
 #include <openssl/bn.h>
 #include <openssl/conf.h>
diff --git a/lib/isccc/Makefile.am b/lib/isccc/Makefile.am
--- a/lib/isccc/Makefile.am
+++ b/lib/isccc/Makefile.am
@@ -4,25 +4,12 @@ lib_LTLIBRARIES = libisccc.la
 
 libisccc_ladir = $(includedir)/isccc
 libisccc_la_HEADERS =			\
-	include/isccc/alist.h		\
 	include/isccc/base64.h		\
-	include/isccc/cc.h		\
-	include/isccc/ccmsg.h		\
-	include/isccc/events.h		\
-	include/isccc/sexpr.h		\
-	include/isccc/symtab.h		\
-	include/isccc/symtype.h		\
-	include/isccc/types.h		\
-	include/isccc/util.h
+	include/isccc/types.h
 
 libisccc_la_SOURCES =		\
 	$(libisccc_la_HEADERS)	\
-	alist.c			\
-	base64.c		\
-	cc.c			\
-	ccmsg.c			\
-	sexpr.c			\
-	symtab.c
+	base64.c
 
 libisccc_la_CPPFLAGS =		\
 	$(AM_CPPFLAGS)		\
diff --git a/lib/isccc/base64.c b/lib/isccc/base64.c
--- a/lib/isccc/base64.c
+++ b/lib/isccc/base64.c
@@ -35,7 +35,6 @@
 #include <isc/result.h>
 
 #include <isccc/base64.h>
-#include <isccc/util.h>
 
 isc_result_t
 isccc_base64_encode(isccc_region_t *source, int wordlength,
diff --git a/lib/isccc/include/isccc/types.h b/lib/isccc/include/isccc/types.h
--- a/lib/isccc/include/isccc/types.h
+++ b/lib/isccc/include/isccc/types.h
@@ -35,16 +35,6 @@
 
 #include <isc/result.h>
 
-/*% isccc_time_t typedef */
-typedef uint32_t isccc_time_t;
-
-/*% isccc_sexpr_t typedef */
-typedef struct isccc_sexpr isccc_sexpr_t;
-/*% isccc_dottedpair_t typedef */
-typedef struct isccc_dottedpair isccc_dottedpair_t;
-/*% isccc_symtab_t typedef */
-typedef struct isccc_symtab isccc_symtab_t;
-
 /*% iscc region structure */
 typedef struct isccc_region {
 	unsigned char *rstart;
diff --git a/lib/isccfg/Makefile.am b/lib/isccfg/Makefile.am
--- a/lib/isccfg/Makefile.am
+++ b/lib/isccfg/Makefile.am
@@ -8,7 +8,6 @@ libisccfg_la_HEADERS =			\
 	include/isccfg/cfg.h		\
 	include/isccfg/duration.h	\
 	include/isccfg/grammar.h	\
-	include/isccfg/kaspconf.h	\
 	include/isccfg/log.h		\
 	include/isccfg/namedconf.h
 
@@ -17,7 +16,6 @@ libisccfg_la_SOURCES =			\
 	aclconf.c			\
 	dnsconf.c			\
 	duration.c			\
-	kaspconf.c			\
 	log.c				\
 	namedconf.c			\
 	parser.c
diff --git a/lib/isccfg/aclconf.c b/lib/isccfg/aclconf.c
--- a/lib/isccfg/aclconf.c
+++ b/lib/isccfg/aclconf.c
@@ -30,12 +30,6 @@
 
 #define LOOP_MAGIC ISC_MAGIC('L', 'O', 'O', 'P')
 
-#if defined(HAVE_GEOIP2)
-static const char *geoip_dbnames[] = {
-	"country", "city", "asnum", "isp", "domain", NULL,
-};
-#endif /* if defined(HAVE_GEOIP2) */
-
 isc_result_t
 cfg_aclconfctx_create(isc_mem_t *mctx, cfg_aclconfctx_t **ret) {
 	cfg_aclconfctx_t *actx;
@@ -51,10 +45,6 @@ cfg_aclconfctx_create(isc_mem_t *mctx, cfg_aclconfctx_t **ret) {
 	isc_mem_attach(mctx, &actx->mctx);
 	ISC_LIST_INIT(actx->named_acl_cache);
 
-#if defined(HAVE_GEOIP2)
-	actx->geoip = NULL;
-#endif /* if defined(HAVE_GEOIP2) */
-
 	*ret = actx;
 	return ISC_R_SUCCESS;
 }
@@ -245,12 +235,6 @@ count_acl_elements(const cfg_obj_t *caml, const cfg_obj_t *cctx,
 			if (negative) {
 				n++;
 			}
-#if defined(HAVE_GEOIP2)
-		} else if (cfg_obj_istuple(ce) &&
-			   cfg_obj_isvoid(cfg_tuple_get(ce, "negated")))
-		{
-			n++;
-#endif /* HAVE_GEOIP2 */
 		} else if (cfg_obj_isstring(ce)) {
 			const char *name = cfg_obj_asstring(ce);
 			if (strcasecmp(name, "localhost") == 0 ||
@@ -284,342 +268,6 @@ count_acl_elements(const cfg_obj_t *caml, const cfg_obj_t *cctx,
 	return ISC_R_SUCCESS;
 }
 
-#if defined(HAVE_GEOIP2)
-static dns_geoip_subtype_t
-get_subtype(const cfg_obj_t *obj, isc_log_t *lctx, dns_geoip_subtype_t subtype,
-	    const char *dbname) {
-	if (dbname == NULL) {
-		return subtype;
-	}
-
-	switch (subtype) {
-	case dns_geoip_countrycode:
-		if (strcasecmp(dbname, "city") == 0) {
-			return dns_geoip_city_countrycode;
-		} else if (strcasecmp(dbname, "country") == 0) {
-			return dns_geoip_country_code;
-		}
-		cfg_obj_log(obj, lctx, ISC_LOG_ERROR,
-			    "invalid database specified for "
-			    "country search: ignored");
-		return subtype;
-	case dns_geoip_countryname:
-		if (strcasecmp(dbname, "city") == 0) {
-			return dns_geoip_city_countryname;
-		} else if (strcasecmp(dbname, "country") == 0) {
-			return dns_geoip_country_name;
-		}
-		cfg_obj_log(obj, lctx, ISC_LOG_ERROR,
-			    "invalid database specified for "
-			    "country search: ignored");
-		return subtype;
-	case dns_geoip_continentcode:
-		if (strcasecmp(dbname, "city") == 0) {
-			return dns_geoip_city_continentcode;
-		} else if (strcasecmp(dbname, "country") == 0) {
-			return dns_geoip_country_continentcode;
-		}
-		cfg_obj_log(obj, lctx, ISC_LOG_ERROR,
-			    "invalid database specified for "
-			    "continent search: ignored");
-		return subtype;
-	case dns_geoip_continent:
-		if (strcasecmp(dbname, "city") == 0) {
-			return dns_geoip_city_continent;
-		} else if (strcasecmp(dbname, "country") == 0) {
-			return dns_geoip_country_continent;
-		}
-		cfg_obj_log(obj, lctx, ISC_LOG_ERROR,
-			    "invalid database specified for "
-			    "continent search: ignored");
-		return subtype;
-	case dns_geoip_region:
-		if (strcasecmp(dbname, "city") == 0) {
-			return dns_geoip_city_region;
-		}
-		cfg_obj_log(obj, lctx, ISC_LOG_ERROR,
-			    "invalid database specified for "
-			    "region/subdivision search: ignored");
-		return subtype;
-	case dns_geoip_regionname:
-		if (strcasecmp(dbname, "city") == 0) {
-			return dns_geoip_city_regionname;
-		}
-		cfg_obj_log(obj, lctx, ISC_LOG_ERROR,
-			    "invalid database specified for "
-			    "region/subdivision search: ignored");
-		return subtype;
-
-	/*
-	 * Log a warning if the wrong database was specified
-	 * on an unambiguous query
-	 */
-	case dns_geoip_city_name:
-	case dns_geoip_city_postalcode:
-	case dns_geoip_city_metrocode:
-	case dns_geoip_city_areacode:
-	case dns_geoip_city_timezonecode:
-		if (strcasecmp(dbname, "city") != 0) {
-			cfg_obj_log(obj, lctx, ISC_LOG_WARNING,
-				    "invalid database specified for "
-				    "a 'city'-only search type: ignoring");
-		}
-		return subtype;
-	case dns_geoip_isp_name:
-		if (strcasecmp(dbname, "isp") != 0) {
-			cfg_obj_log(obj, lctx, ISC_LOG_WARNING,
-				    "invalid database specified for "
-				    "an 'isp' search: ignoring");
-		}
-		return subtype;
-	case dns_geoip_org_name:
-		if (strcasecmp(dbname, "org") != 0) {
-			cfg_obj_log(obj, lctx, ISC_LOG_WARNING,
-				    "invalid database specified for "
-				    "an 'org' search: ignoring");
-		}
-		return subtype;
-	case dns_geoip_as_asnum:
-		if (strcasecmp(dbname, "asnum") != 0) {
-			cfg_obj_log(obj, lctx, ISC_LOG_WARNING,
-				    "invalid database specified for "
-				    "an 'asnum' search: ignoring");
-		}
-		return subtype;
-	case dns_geoip_domain_name:
-		if (strcasecmp(dbname, "domain") != 0) {
-			cfg_obj_log(obj, lctx, ISC_LOG_WARNING,
-				    "invalid database specified for "
-				    "a 'domain' search: ignoring");
-		}
-		return subtype;
-	case dns_geoip_netspeed_id:
-		if (strcasecmp(dbname, "netspeed") != 0) {
-			cfg_obj_log(obj, lctx, ISC_LOG_WARNING,
-				    "invalid database specified for "
-				    "a 'netspeed' search: ignoring");
-		}
-		return subtype;
-	default:
-		UNREACHABLE();
-	}
-}
-
-static bool
-geoip_can_answer(dns_aclelement_t *elt, cfg_aclconfctx_t *ctx) {
-	if (ctx->geoip == NULL) {
-		return true;
-	}
-
-	switch (elt->geoip_elem.subtype) {
-	case dns_geoip_countrycode:
-	case dns_geoip_countryname:
-	case dns_geoip_continentcode:
-	case dns_geoip_continent:
-		if (ctx->geoip->country != NULL || ctx->geoip->city != NULL) {
-			return true;
-		}
-		break;
-	case dns_geoip_country_code:
-	case dns_geoip_country_name:
-	case dns_geoip_country_continentcode:
-	case dns_geoip_country_continent:
-		if (ctx->geoip->country != NULL) {
-			return true;
-		}
-		/* city db can answer these too, so: */
-		FALLTHROUGH;
-	case dns_geoip_region:
-	case dns_geoip_regionname:
-	case dns_geoip_city_countrycode:
-	case dns_geoip_city_countryname:
-	case dns_geoip_city_region:
-	case dns_geoip_city_regionname:
-	case dns_geoip_city_name:
-	case dns_geoip_city_postalcode:
-	case dns_geoip_city_metrocode:
-	case dns_geoip_city_areacode:
-	case dns_geoip_city_continentcode:
-	case dns_geoip_city_continent:
-	case dns_geoip_city_timezonecode:
-		if (ctx->geoip->city != NULL) {
-			return true;
-		}
-		break;
-	case dns_geoip_isp_name:
-		if (ctx->geoip->isp != NULL) {
-			return true;
-		}
-		break;
-	case dns_geoip_as_asnum:
-	case dns_geoip_org_name:
-		if (ctx->geoip->as != NULL) {
-			return true;
-		}
-		break;
-	case dns_geoip_domain_name:
-		if (ctx->geoip->domain != NULL) {
-			return true;
-		}
-		break;
-	default:
-		break;
-	}
-
-	return false;
-}
-
-static isc_result_t
-parse_geoip_element(const cfg_obj_t *obj, isc_log_t *lctx,
-		    cfg_aclconfctx_t *ctx, dns_aclelement_t *dep) {
-	const cfg_obj_t *ge;
-	const char *dbname = NULL;
-	const char *stype = NULL, *search = NULL;
-	dns_geoip_subtype_t subtype;
-	dns_aclelement_t de;
-	size_t len;
-
-	REQUIRE(dep != NULL);
-
-	de = *dep;
-
-	ge = cfg_tuple_get(obj, "db");
-	if (!cfg_obj_isvoid(ge)) {
-		int i;
-
-		dbname = cfg_obj_asstring(ge);
-
-		for (i = 0; geoip_dbnames[i] != NULL; i++) {
-			if (strcasecmp(dbname, geoip_dbnames[i]) == 0) {
-				break;
-			}
-		}
-		if (geoip_dbnames[i] == NULL) {
-			cfg_obj_log(obj, lctx, ISC_LOG_ERROR,
-				    "database '%s' is not defined for GeoIP2",
-				    dbname);
-			return ISC_R_UNEXPECTED;
-		}
-	}
-
-	stype = cfg_obj_asstring(cfg_tuple_get(obj, "subtype"));
-	search = cfg_obj_asstring(cfg_tuple_get(obj, "search"));
-	len = strlen(search);
-
-	if (len == 0) {
-		cfg_obj_log(obj, lctx, ISC_LOG_ERROR,
-			    "zero-length geoip search field");
-		return ISC_R_FAILURE;
-	}
-
-	if (strcasecmp(stype, "country") == 0 && len == 2) {
-		/* Two-letter country code */
-		subtype = dns_geoip_countrycode;
-		strlcpy(de.geoip_elem.as_string, search,
-			sizeof(de.geoip_elem.as_string));
-	} else if (strcasecmp(stype, "country") == 0 && len == 3) {
-		/* Three-letter country code */
-		cfg_obj_log(obj, lctx, ISC_LOG_ERROR,
-			    "three-letter country codes are unavailable "
-			    "in GeoIP2 databases");
-		return ISC_R_FAILURE;
-	} else if (strcasecmp(stype, "country") == 0) {
-		/* Country name */
-		subtype = dns_geoip_countryname;
-		strlcpy(de.geoip_elem.as_string, search,
-			sizeof(de.geoip_elem.as_string));
-	} else if (strcasecmp(stype, "continent") == 0 && len == 2) {
-		/* Two-letter continent code */
-		subtype = dns_geoip_continentcode;
-		strlcpy(de.geoip_elem.as_string, search,
-			sizeof(de.geoip_elem.as_string));
-	} else if (strcasecmp(stype, "continent") == 0) {
-		subtype = dns_geoip_continent;
-		strlcpy(de.geoip_elem.as_string, search,
-			sizeof(de.geoip_elem.as_string));
-	} else if ((strcasecmp(stype, "region") == 0 ||
-		    strcasecmp(stype, "subdivision") == 0) &&
-		   len == 2)
-	{
-		/* Two-letter region code */
-		subtype = dns_geoip_region;
-		strlcpy(de.geoip_elem.as_string, search,
-			sizeof(de.geoip_elem.as_string));
-	} else if (strcasecmp(stype, "region") == 0 ||
-		   strcasecmp(stype, "subdivision") == 0)
-	{
-		/* Region name */
-		subtype = dns_geoip_regionname;
-		strlcpy(de.geoip_elem.as_string, search,
-			sizeof(de.geoip_elem.as_string));
-	} else if (strcasecmp(stype, "city") == 0) {
-		/* City name */
-		subtype = dns_geoip_city_name;
-		strlcpy(de.geoip_elem.as_string, search,
-			sizeof(de.geoip_elem.as_string));
-	} else if (strcasecmp(stype, "postal") == 0 ||
-		   strcasecmp(stype, "postalcode") == 0)
-	{
-		if (len < 7) {
-			subtype = dns_geoip_city_postalcode;
-			strlcpy(de.geoip_elem.as_string, search,
-				sizeof(de.geoip_elem.as_string));
-		} else {
-			cfg_obj_log(obj, lctx, ISC_LOG_ERROR,
-				    "geoiop postal code (%s) too long", search);
-			return ISC_R_FAILURE;
-		}
-	} else if (strcasecmp(stype, "metro") == 0 ||
-		   strcasecmp(stype, "metrocode") == 0)
-	{
-		subtype = dns_geoip_city_metrocode;
-		de.geoip_elem.as_int = atoi(search);
-	} else if (strcasecmp(stype, "tz") == 0 ||
-		   strcasecmp(stype, "timezone") == 0)
-	{
-		subtype = dns_geoip_city_timezonecode;
-		strlcpy(de.geoip_elem.as_string, search,
-			sizeof(de.geoip_elem.as_string));
-	} else if (strcasecmp(stype, "isp") == 0) {
-		subtype = dns_geoip_isp_name;
-		strlcpy(de.geoip_elem.as_string, search,
-			sizeof(de.geoip_elem.as_string));
-	} else if (strcasecmp(stype, "asnum") == 0) {
-		subtype = dns_geoip_as_asnum;
-		strlcpy(de.geoip_elem.as_string, search,
-			sizeof(de.geoip_elem.as_string));
-	} else if (strcasecmp(stype, "org") == 0) {
-		subtype = dns_geoip_org_name;
-		strlcpy(de.geoip_elem.as_string, search,
-			sizeof(de.geoip_elem.as_string));
-	} else if (strcasecmp(stype, "domain") == 0) {
-		subtype = dns_geoip_domain_name;
-		strlcpy(de.geoip_elem.as_string, search,
-			sizeof(de.geoip_elem.as_string));
-	} else {
-		cfg_obj_log(obj, lctx, ISC_LOG_ERROR,
-			    "type '%s' is unavailable "
-			    "in GeoIP2 databases",
-			    stype);
-		return ISC_R_FAILURE;
-	}
-
-	de.geoip_elem.subtype = get_subtype(obj, lctx, subtype, dbname);
-
-	if (!geoip_can_answer(&de, ctx)) {
-		cfg_obj_log(obj, lctx, ISC_LOG_ERROR,
-			    "no GeoIP2 database installed which can answer "
-			    "queries of type '%s'",
-			    stype);
-		return ISC_R_FAILURE;
-	}
-
-	*dep = de;
-
-	return ISC_R_SUCCESS;
-}
-#endif /* HAVE_GEOIP2 */
-
 isc_result_t
 cfg_acl_fromconfig(const cfg_obj_t *caml, const cfg_obj_t *cctx,
 		   isc_log_t *lctx, cfg_aclconfctx_t *ctx, isc_mem_t *mctx,
@@ -889,18 +537,6 @@ cfg_acl_fromconfig2(const cfg_obj_t *acl_data, const cfg_obj_t *cctx,
 			if (result != ISC_R_SUCCESS) {
 				goto cleanup;
 			}
-#if defined(HAVE_GEOIP2)
-		} else if (cfg_obj_istuple(ce) &&
-			   cfg_obj_isvoid(cfg_tuple_get(ce, "negated")))
-		{
-			INSIST(dacl->length < dacl->alloc);
-			result = parse_geoip_element(ce, lctx, ctx, de);
-			if (result != ISC_R_SUCCESS) {
-				goto cleanup;
-			}
-			de->type = dns_aclelementtype_geoip;
-			de->negative = neg;
-#endif /* HAVE_GEOIP2 */
 		} else if (cfg_obj_isstring(ce)) {
 			/* ACL name. */
 			const char *name = cfg_obj_asstring(ce);
diff --git a/lib/isccfg/include/isccfg/aclconf.h b/lib/isccfg/include/isccfg/aclconf.h
--- a/lib/isccfg/include/isccfg/aclconf.h
+++ b/lib/isccfg/include/isccfg/aclconf.h
@@ -17,7 +17,6 @@
 
 #include <isc/lang.h>
 
-#include <dns/geoip.h>
 #include <dns/types.h>
 
 #include <isccfg/cfg.h>
@@ -25,9 +24,6 @@
 typedef struct cfg_aclconfctx {
 	ISC_LIST(dns_acl_t) named_acl_cache;
 	isc_mem_t *mctx;
-#if defined(HAVE_GEOIP2)
-	dns_geoip_databases_t *geoip;
-#endif /* if defined(HAVE_GEOIP2) */
 	isc_refcount_t references;
 } cfg_aclconfctx_t;
 
diff --git a/lib/isccfg/namedconf.c b/lib/isccfg/namedconf.c
--- a/lib/isccfg/namedconf.c
+++ b/lib/isccfg/namedconf.c
@@ -1164,13 +1164,8 @@ static cfg_clausedef_t namedconf_clauses[] = {
 	{ "options", &cfg_type_options, 0 },
 	{ "parental-agents", &cfg_type_remoteservers, CFG_CLAUSEFLAG_MULTI },
 	{ "primaries", &cfg_type_remoteservers, CFG_CLAUSEFLAG_MULTI },
-#if defined(HAVE_LIBXML2) || defined(HAVE_JSON_C)
-	{ "statistics-channels", &cfg_type_statschannels,
-	  CFG_CLAUSEFLAG_MULTI },
-#else
 	{ "statistics-channels", &cfg_type_statschannels,
 	  CFG_CLAUSEFLAG_MULTI | CFG_CLAUSEFLAG_NOTCONFIGURED },
-#endif
 	{ "tls", &cfg_type_tlsconf, CFG_CLAUSEFLAG_MULTI },
 	{ "view", &cfg_type_view, CFG_CLAUSEFLAG_MULTI },
 	{ NULL, NULL, 0 }
@@ -1231,31 +1226,16 @@ static cfg_clausedef_t options_clauses[] = {
 	{ "datasize", &cfg_type_size, CFG_CLAUSEFLAG_DEPRECATED },
 	{ "deallocate-on-exit", NULL, CFG_CLAUSEFLAG_ANCIENT },
 	{ "directory", &cfg_type_qstring, CFG_CLAUSEFLAG_CALLBACK },
-#ifdef HAVE_DNSTAP
-	{ "dnstap-output", &cfg_type_dnstapoutput, 0 },
-	{ "dnstap-identity", &cfg_type_serverid, 0 },
-	{ "dnstap-version", &cfg_type_qstringornone, 0 },
-#else  /* ifdef HAVE_DNSTAP */
 	{ "dnstap-output", &cfg_type_dnstapoutput,
 	  CFG_CLAUSEFLAG_NOTCONFIGURED },
 	{ "dnstap-identity", &cfg_type_serverid, CFG_CLAUSEFLAG_NOTCONFIGURED },
 	{ "dnstap-version", &cfg_type_qstringornone,
 	  CFG_CLAUSEFLAG_NOTCONFIGURED },
-#endif /* ifdef HAVE_DNSTAP */
 	{ "dscp", &cfg_type_uint32, CFG_CLAUSEFLAG_OBSOLETE },
 	{ "dump-file", &cfg_type_qstring, 0 },
 	{ "fake-iquery", NULL, CFG_CLAUSEFLAG_ANCIENT },
 	{ "files", &cfg_type_size, CFG_CLAUSEFLAG_DEPRECATED },
 	{ "flush-zones-on-shutdown", &cfg_type_boolean, 0 },
-#ifdef HAVE_DNSTAP
-	{ "fstrm-set-buffer-hint", &cfg_type_uint32, 0 },
-	{ "fstrm-set-flush-timeout", &cfg_type_uint32, 0 },
-	{ "fstrm-set-input-queue-size", &cfg_type_uint32, 0 },
-	{ "fstrm-set-output-notify-threshold", &cfg_type_uint32, 0 },
-	{ "fstrm-set-output-queue-model", &cfg_type_fstrm_model, 0 },
-	{ "fstrm-set-output-queue-size", &cfg_type_uint32, 0 },
-	{ "fstrm-set-reopen-interval", &cfg_type_duration, 0 },
-#else  /* ifdef HAVE_DNSTAP */
 	{ "fstrm-set-buffer-hint", &cfg_type_uint32,
 	  CFG_CLAUSEFLAG_NOTCONFIGURED },
 	{ "fstrm-set-flush-timeout", &cfg_type_uint32,
@@ -1270,13 +1250,8 @@ static cfg_clausedef_t options_clauses[] = {
 	  CFG_CLAUSEFLAG_NOTCONFIGURED },
 	{ "fstrm-set-reopen-interval", &cfg_type_duration,
 	  CFG_CLAUSEFLAG_NOTCONFIGURED },
-#endif /* HAVE_DNSTAP */
-#if defined(HAVE_GEOIP2)
-	{ "geoip-directory", &cfg_type_qstringornone, 0 },
-#else  /* if defined(HAVE_GEOIP2) */
 	{ "geoip-directory", &cfg_type_qstringornone,
 	  CFG_CLAUSEFLAG_NOTCONFIGURED },
-#endif /* HAVE_GEOIP2 */
 	{ "geoip-use-ecs", NULL, CFG_CLAUSEFLAG_ANCIENT },
 	{ "has-old-clients", NULL, CFG_CLAUSEFLAG_ANCIENT },
 	{ "heartbeat-interval", &cfg_type_uint32, CFG_CLAUSEFLAG_DEPRECATED },
@@ -2076,11 +2051,7 @@ static cfg_clausedef_t view_clauses[] = {
 	{ "dnssec-must-be-secure", &cfg_type_mustbesecure,
 	  CFG_CLAUSEFLAG_MULTI | CFG_CLAUSEFLAG_DEPRECATED },
 	{ "dnssec-validation", &cfg_type_boolorauto, 0 },
-#ifdef HAVE_DNSTAP
-	{ "dnstap", &cfg_type_dnstap, 0 },
-#else  /* ifdef HAVE_DNSTAP */
 	{ "dnstap", &cfg_type_dnstap, CFG_CLAUSEFLAG_NOTCONFIGURED },
-#endif /* HAVE_DNSTAP */
 	{ "dual-stack-servers", &cfg_type_nameportiplist, 0 },
 	{ "edns-udp-size", &cfg_type_uint32, 0 },
 	{ "empty-contact", &cfg_type_astring, 0 },
@@ -2099,11 +2070,7 @@ static cfg_clausedef_t view_clauses[] = {
 	{ "ipv4only-server", &cfg_type_astring, 0 },
 	{ "ixfr-from-differences", &cfg_type_ixfrdifftype, 0 },
 	{ "lame-ttl", &cfg_type_duration, 0 },
-#ifdef HAVE_LMDB
-	{ "lmdb-mapsize", &cfg_type_sizeval, 0 },
-#else  /* ifdef HAVE_LMDB */
 	{ "lmdb-mapsize", &cfg_type_sizeval, CFG_CLAUSEFLAG_NOTCONFIGURED },
-#endif /* ifdef HAVE_LMDB */
 	{ "max-acache-size", NULL, CFG_CLAUSEFLAG_ANCIENT },
 	{ "max-cache-size", &cfg_type_sizeorpercent, 0 },
 	{ "max-cache-ttl", &cfg_type_duration, 0 },
diff --git a/lib/isccfg/parser.c b/lib/isccfg/parser.c
--- a/lib/isccfg/parser.c
+++ b/lib/isccfg/parser.c
@@ -50,7 +50,6 @@
 #include <isc/dir.h>
 #include <isc/errno.h>
 #include <isc/formatcheck.h>
-#include <isc/glob.h>
 #include <isc/lex.h>
 #include <isc/log.h>
 #include <isc/mem.h>
@@ -139,17 +138,6 @@ static void
 parser_complain(cfg_parser_t *pctx, bool is_warning, unsigned int flags,
 		const char *format, va_list args);
 
-#if defined(HAVE_GEOIP2)
-static isc_result_t
-parse_geoip(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret);
-
-static void
-print_geoip(cfg_printer_t *pctx, const cfg_obj_t *obj);
-
-static void
-doc_geoip(cfg_printer_t *pctx, const cfg_type_t *type);
-#endif /* HAVE_GEOIP2 */
-
 /*
  * Data representations.  These correspond to members of the
  * "value" union in struct cfg_obj (except "void", which does
@@ -1582,91 +1570,6 @@ cfg_type_t cfg_type_bracketed_text = { "bracketed_text", parse_btext,
 				       print_btext,	 doc_btext,
 				       &cfg_rep_string,	 NULL };
 
-#if defined(HAVE_GEOIP2)
-/*
- * "geoip" ACL element:
- * geoip [ db <database> ] search-type <string>
- */
-static const char *geoiptype_enums[] = {
-	"area",	      "areacode",  "asnum",	  "city",     "continent",
-	"country",    "country3",  "countryname", "domain",   "isp",
-	"metro",      "metrocode", "netspeed",	  "org",      "postal",
-	"postalcode", "region",	   "regionname",  "timezone", "tz",
-	NULL
-};
-static cfg_type_t cfg_type_geoiptype = { "geoiptype",	    cfg_parse_enum,
-					 cfg_print_ustring, cfg_doc_enum,
-					 &cfg_rep_string,   &geoiptype_enums };
-
-static cfg_tuplefielddef_t geoip_fields[] = {
-	{ "negated", &cfg_type_void, 0 },
-	{ "db", &cfg_type_astring, 0 },
-	{ "subtype", &cfg_type_geoiptype, 0 },
-	{ "search", &cfg_type_astring, 0 },
-	{ NULL, NULL, 0 }
-};
-
-static cfg_type_t cfg_type_geoip = { "geoip",	parse_geoip,	print_geoip,
-				     doc_geoip, &cfg_rep_tuple, geoip_fields };
-
-static isc_result_t
-parse_geoip(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
-	isc_result_t result;
-	cfg_obj_t *obj = NULL;
-	const cfg_tuplefielddef_t *fields = type->of;
-
-	CHECK(cfg_create_tuple(pctx, type, &obj));
-	CHECK(cfg_parse_void(pctx, NULL, &obj->value.tuple[0]));
-
-	/* Parse the optional "db" field. */
-	CHECK(cfg_peektoken(pctx, 0));
-	if (pctx->token.type == isc_tokentype_string) {
-		CHECK(cfg_gettoken(pctx, 0));
-		if (strcasecmp(TOKEN_STRING(pctx), "db") == 0 &&
-		    obj->value.tuple[1] == NULL)
-		{
-			CHECK(cfg_parse_obj(pctx, fields[1].type,
-					    &obj->value.tuple[1]));
-		} else {
-			CHECK(cfg_parse_void(pctx, NULL, &obj->value.tuple[1]));
-			cfg_ungettoken(pctx);
-		}
-	}
-
-	CHECK(cfg_parse_obj(pctx, fields[2].type, &obj->value.tuple[2]));
-	CHECK(cfg_parse_obj(pctx, fields[3].type, &obj->value.tuple[3]));
-
-	*ret = obj;
-	return ISC_R_SUCCESS;
-
-cleanup:
-	CLEANUP_OBJ(obj);
-	return result;
-}
-
-static void
-print_geoip(cfg_printer_t *pctx, const cfg_obj_t *obj) {
-	if (obj->value.tuple[1]->type->print != cfg_print_void) {
-		cfg_print_cstr(pctx, " db ");
-		cfg_print_obj(pctx, obj->value.tuple[1]);
-	}
-	cfg_print_obj(pctx, obj->value.tuple[2]);
-	cfg_print_obj(pctx, obj->value.tuple[3]);
-}
-
-static void
-doc_geoip(cfg_printer_t *pctx, const cfg_type_t *type) {
-	UNUSED(type);
-	cfg_print_cstr(pctx, "[ db ");
-	cfg_doc_obj(pctx, &cfg_type_astring);
-	cfg_print_cstr(pctx, " ]");
-	cfg_print_cstr(pctx, " ");
-	cfg_doc_enum(pctx, &cfg_type_geoiptype);
-	cfg_print_cstr(pctx, " ");
-	cfg_doc_obj(pctx, &cfg_type_astring);
-}
-#endif /* HAVE_GEOIP2 */
-
 static cfg_type_t cfg_type_addrmatchelt;
 static cfg_type_t cfg_type_negated;
 
@@ -1688,15 +1591,10 @@ parse_addrmatchelt(cfg_parser_t *pctx, const cfg_type_t *type,
 		} else if (pctx->token.type == isc_tokentype_string &&
 			   (strcasecmp(TOKEN_STRING(pctx), "geoip") == 0))
 		{
-#if defined(HAVE_GEOIP2)
-			CHECK(cfg_gettoken(pctx, 0));
-			CHECK(cfg_parse_obj(pctx, &cfg_type_geoip, ret));
-#else  /* if defined(HAVE_GEOIP2) */
 			cfg_parser_error(pctx, CFG_LOG_NEAR,
 					 "'geoip' "
 					 "not supported in this build");
 			return ISC_R_UNEXPECTEDTOKEN;
-#endif /* if defined(HAVE_GEOIP2) */
 		} else {
 			if (cfg_lookingat_netaddr(
 				    pctx, CFG_ADDR_V4OK | CFG_ADDR_V4PREFIXOK |
@@ -2230,19 +2128,8 @@ cfg_parse_mapbody(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
 					    &includename));
 			CHECK(parse_semicolon(pctx));
 
-			/* Allow include to specify a pattern that follows
-			 * the same rules as the shell e.g "/path/zone*.conf" */
-			glob_t glob_obj;
-			CHECK(isc_glob(includename->value.string.base,
-				       &glob_obj));
-			cfg_obj_destroy(pctx, &includename);
-
-			for (size_t i = 0; i < glob_obj.gl_pathc; ++i) {
-				CHECK(parser_openfile(pctx,
-						      glob_obj.gl_pathv[i]));
-			}
-
-			isc_globfree(&glob_obj);
+			CHECK(parser_openfile(pctx,
+					      includename->value.string.base));
 
 			goto redo;
 		}
